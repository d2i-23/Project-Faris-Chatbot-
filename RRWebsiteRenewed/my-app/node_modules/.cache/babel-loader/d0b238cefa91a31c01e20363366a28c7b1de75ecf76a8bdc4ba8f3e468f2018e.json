{"ast":null,"code":"/**\r\n * Copyright(c) Live2D Inc. All rights reserved.\r\n *\r\n * Use of this source code is governed by the Live2D Open Software license\r\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\r\n */\n\nimport { Live2DCubismFramework as cubismphysicsinternal } from './cubismphysicsinternal';\nimport { Live2DCubismFramework as cubismmodel } from '../model/cubismmodel';\nimport { Live2DCubismFramework as cubismvector2 } from '../math/cubismvector2';\nimport { Live2DCubismFramework as cubismmath } from '../math/cubismmath';\nimport { Live2DCubismFramework as cubismphysicsjson } from './cubismphysicsjson';\nvar CubismPhysicsJson = cubismphysicsjson.CubismPhysicsJson;\nvar CubismMath = cubismmath.CubismMath;\nvar CubismPhysicsRig = cubismphysicsinternal.CubismPhysicsRig;\nvar CubismPhysicsSubRig = cubismphysicsinternal.CubismPhysicsSubRig;\nvar CubismPhysicsInput = cubismphysicsinternal.CubismPhysicsInput;\nvar CubismPhysicsOutput = cubismphysicsinternal.CubismPhysicsOutput;\nvar CubismPhysicsParticle = cubismphysicsinternal.CubismPhysicsParticle;\nvar CubismPhysicsSource = cubismphysicsinternal.CubismPhysicsSource;\nvar CubismPhysicsTargetType = cubismphysicsinternal.CubismPhysicsTargetType;\nvar CubismPhysicsNormalization = cubismphysicsinternal.CubismPhysicsNormalization;\nvar CubismVector2 = cubismvector2.CubismVector2;\nvar CubismModel = cubismmodel.CubismModel;\nexport let Live2DCubismFramework;\n(function (_Live2DCubismFramework) {\n  // physics types tags.\n  const PhysicsTypeTagX = 'X';\n  const PhysicsTypeTagY = 'Y';\n  const PhysicsTypeTagAngle = 'Angle';\n\n  // Constant of air resistance.\n  const AirResistance = 5.0;\n\n  // Constant of maximum weight of input and output ratio.\n  const MaximumWeight = 100.0;\n\n  // Constant of threshold of movement.\n  const MovementThreshold = 0.001;\n\n  /**\r\n   * 物理演算クラス\r\n   */\n  class CubismPhysics {\n    /**\r\n     * インスタンスの作成\r\n     * @param buffer    physics3.jsonが読み込まれているバッファ\r\n     * @param size      バッファのサイズ\r\n     * @return 作成されたインスタンス\r\n     */\n    static create(buffer, size) {\n      const ret = new CubismPhysics();\n      ret.parse(buffer, size);\n      ret._physicsRig.gravity.y = 0;\n      return ret;\n    }\n\n    /**\r\n     * インスタンスを破棄する\r\n     * @param physics 破棄するインスタンス\r\n     */\n    static delete(physics) {\n      if (physics != null) {\n        physics.release();\n        physics = null;\n      }\n    }\n\n    /**\r\n     * 物理演算の評価\r\n     * @param model 物理演算の結果を適用するモデル\r\n     * @param deltaTimeSeconds デルタ時間[秒]\r\n     */\n    evaluate(model, deltaTimeSeconds) {\n      let totalAngle;\n      let weight;\n      let radAngle;\n      let outputValue;\n      const totalTranslation = new CubismVector2();\n      let currentSetting;\n      let currentInput;\n      let currentOutput;\n      let currentParticles;\n      let parameterValue;\n      let parameterMaximumValue;\n      let parameterMinimumValue;\n      let parameterDefaultValue;\n      parameterValue = model.getModel().parameters.values;\n      parameterMaximumValue = model.getModel().parameters.maximumValues;\n      parameterMinimumValue = model.getModel().parameters.minimumValues;\n      parameterDefaultValue = model.getModel().parameters.defaultValues;\n      for (let settingIndex = 0; settingIndex < this._physicsRig.subRigCount; ++settingIndex) {\n        totalAngle = {\n          angle: 0.0\n        };\n        totalTranslation.x = 0.0;\n        totalTranslation.y = 0.0;\n        currentSetting = this._physicsRig.settings.at(settingIndex);\n        currentInput = this._physicsRig.inputs.get(currentSetting.baseInputIndex);\n        currentOutput = this._physicsRig.outputs.get(currentSetting.baseOutputIndex);\n        currentParticles = this._physicsRig.particles.get(currentSetting.baseParticleIndex);\n\n        // Load input parameters\n        for (let i = 0; i < currentSetting.inputCount; ++i) {\n          weight = currentInput[i].weight / MaximumWeight;\n          if (currentInput[i].sourceParameterIndex == -1) {\n            currentInput[i].sourceParameterIndex = model.getParameterIndex(currentInput[i].source.id);\n          }\n          currentInput[i].getNormalizedParameterValue(totalTranslation, totalAngle, parameterValue[currentInput[i].sourceParameterIndex], parameterMinimumValue[currentInput[i].sourceParameterIndex], parameterMaximumValue[currentInput[i].sourceParameterIndex], parameterDefaultValue[currentInput[i].sourceParameterIndex], currentSetting.normalizationPosition, currentSetting.normalizationAngle, currentInput[0].reflect, weight);\n        }\n        radAngle = CubismMath.degreesToRadian(-totalAngle.angle);\n        totalTranslation.x = totalTranslation.x * CubismMath.cos(radAngle) - totalTranslation.y * CubismMath.sin(radAngle);\n        totalTranslation.y = totalTranslation.x * CubismMath.sin(radAngle) + totalTranslation.y * CubismMath.cos(radAngle);\n\n        // Calculate particles position.\n        updateParticles(currentParticles, currentSetting.particleCount, totalTranslation, totalAngle.angle, this._options.wind, MovementThreshold * currentSetting.normalizationPosition.maximum, deltaTimeSeconds, AirResistance);\n\n        // Update output parameters.\n        for (let i = 0; i < currentSetting.outputCount; ++i) {\n          const particleIndex = currentOutput[i].vertexIndex;\n          if (particleIndex < 1 || particleIndex >= currentSetting.particleCount) {\n            break;\n          }\n          if (currentOutput[i].destinationParameterIndex == -1) {\n            currentOutput[i].destinationParameterIndex = model.getParameterIndex(currentOutput[i].destination.id);\n          }\n          const translation = new CubismVector2();\n          translation.x = currentParticles[particleIndex].position.x - currentParticles[particleIndex - 1].position.x;\n          translation.y = currentParticles[particleIndex].position.y - currentParticles[particleIndex - 1].position.y;\n          outputValue = currentOutput[i].getValue(translation, currentParticles, particleIndex, currentOutput[i].reflect, this._options.gravity);\n          const destinationParameterIndex = currentOutput[i].destinationParameterIndex;\n          const outParameterValue = !Float32Array.prototype.slice && 'subarray' in Float32Array.prototype ? JSON.parse(JSON.stringify(parameterValue.subarray(destinationParameterIndex))) // 値渡しするため、JSON.parse, JSON.stringify\n          : parameterValue.slice(destinationParameterIndex);\n          updateOutputParameterValue(outParameterValue, parameterMinimumValue[destinationParameterIndex], parameterMaximumValue[destinationParameterIndex], outputValue, currentOutput[i]);\n\n          // 値を反映\n          for (let offset = destinationParameterIndex, outParamIndex = 0; offset < parameterValue.length; offset++, outParamIndex++) {\n            parameterValue[offset] = outParameterValue[outParamIndex];\n          }\n        }\n      }\n    }\n\n    /**\r\n     * オプションの設定\r\n     * @param options オプション\r\n     */\n    setOptions(options) {\n      this._options = options;\n    }\n\n    /**\r\n     * オプションの取得\r\n     * @return オプション\r\n     */\n    getOption() {\n      return this._options;\n    }\n\n    /**\r\n     * コンストラクタ\r\n     */\n    constructor() {\n      this._physicsRig = void 0;\n      // 物理演算のデータ\n      this._options = void 0;\n      this._physicsRig = null;\n\n      // set default options\n      this._options = new Options();\n      this._options.gravity.y = -1.0;\n      this._options.gravity.x = 0;\n      this._options.wind.x = 0;\n      this._options.wind.y = 0;\n    }\n\n    /**\r\n     * デストラクタ相当の処理\r\n     */\n    release() {\n      this._physicsRig = void 0;\n      this._physicsRig = null;\n    }\n\n    /**\r\n     * physics3.jsonをパースする。\r\n     * @param physicsJson physics3.jsonが読み込まれているバッファ\r\n     * @param size バッファのサイズ\r\n     */\n    parse(physicsJson, size) {\n      this._physicsRig = new CubismPhysicsRig();\n      let json = new CubismPhysicsJson(physicsJson, size);\n      this._physicsRig.gravity = json.getGravity();\n      this._physicsRig.wind = json.getWind();\n      this._physicsRig.subRigCount = json.getSubRigCount();\n      this._physicsRig.settings.updateSize(this._physicsRig.subRigCount, CubismPhysicsSubRig, true);\n      this._physicsRig.inputs.updateSize(json.getTotalInputCount(), CubismPhysicsInput, true);\n      this._physicsRig.outputs.updateSize(json.getTotalOutputCount(), CubismPhysicsOutput, true);\n      this._physicsRig.particles.updateSize(json.getVertexCount(), CubismPhysicsParticle, true);\n      let inputIndex = 0,\n        outputIndex = 0,\n        particleIndex = 0;\n      for (let i = 0; i < this._physicsRig.settings.getSize(); ++i) {\n        this._physicsRig.settings.at(i).normalizationPosition.minimum = json.getNormalizationPositionMinimumValue(i);\n        this._physicsRig.settings.at(i).normalizationPosition.maximum = json.getNormalizationPositionMaximumValue(i);\n        this._physicsRig.settings.at(i).normalizationPosition.defalut = json.getNormalizationPositionDefaultValue(i);\n        this._physicsRig.settings.at(i).normalizationAngle.minimum = json.getNormalizationAngleMinimumValue(i);\n        this._physicsRig.settings.at(i).normalizationAngle.maximum = json.getNormalizationAngleMaximumValue(i);\n        this._physicsRig.settings.at(i).normalizationAngle.defalut = json.getNormalizationAngleDefaultValue(i);\n\n        // Input\n        this._physicsRig.settings.at(i).inputCount = json.getInputCount(i);\n        this._physicsRig.settings.at(i).baseInputIndex = inputIndex;\n        for (let j = 0; j < this._physicsRig.settings.at(i).inputCount; ++j) {\n          this._physicsRig.inputs.at(inputIndex + j).sourceParameterIndex = -1;\n          this._physicsRig.inputs.at(inputIndex + j).weight = json.getInputWeight(i, j);\n          this._physicsRig.inputs.at(inputIndex + j).reflect = json.getInputReflect(i, j);\n          if (json.getInputType(i, j) == PhysicsTypeTagX) {\n            this._physicsRig.inputs.at(inputIndex + j).type = CubismPhysicsSource.CubismPhysicsSource_X;\n            this._physicsRig.inputs.at(inputIndex + j).getNormalizedParameterValue = getInputTranslationXFromNormalizedParameterValue;\n          } else if (json.getInputType(i, j) == PhysicsTypeTagY) {\n            this._physicsRig.inputs.at(inputIndex + j).type = CubismPhysicsSource.CubismPhysicsSource_Y;\n            this._physicsRig.inputs.at(inputIndex + j).getNormalizedParameterValue = getInputTranslationYFromNormalizedParamterValue;\n          } else if (json.getInputType(i, j) == PhysicsTypeTagAngle) {\n            this._physicsRig.inputs.at(inputIndex + j).type = CubismPhysicsSource.CubismPhysicsSource_Angle;\n            this._physicsRig.inputs.at(inputIndex + j).getNormalizedParameterValue = getInputAngleFromNormalizedParameterValue;\n          }\n          this._physicsRig.inputs.at(inputIndex + j).source.targetType = CubismPhysicsTargetType.CubismPhysicsTargetType_Parameter;\n          this._physicsRig.inputs.at(inputIndex + j).source.id = json.getInputSourceId(i, j);\n        }\n        inputIndex += this._physicsRig.settings.at(i).inputCount;\n\n        // Output\n        this._physicsRig.settings.at(i).outputCount = json.getOutputCount(i);\n        this._physicsRig.settings.at(i).baseOutputIndex = outputIndex;\n        for (let j = 0; j < this._physicsRig.settings.at(i).outputCount; ++j) {\n          this._physicsRig.outputs.at(outputIndex + j).destinationParameterIndex = -1;\n          this._physicsRig.outputs.at(outputIndex + j).vertexIndex = json.getOutputVertexIndex(i, j);\n          this._physicsRig.outputs.at(outputIndex + j).angleScale = json.getOutputAngleScale(i, j);\n          this._physicsRig.outputs.at(outputIndex + j).weight = json.getOutputWeight(i, j);\n          this._physicsRig.outputs.at(outputIndex + j).destination.targetType = CubismPhysicsTargetType.CubismPhysicsTargetType_Parameter;\n          this._physicsRig.outputs.at(outputIndex + j).destination.id = json.getOutputDestinationId(i, j);\n          if (json.getOutputType(i, j) == PhysicsTypeTagX) {\n            this._physicsRig.outputs.at(outputIndex + j).type = CubismPhysicsSource.CubismPhysicsSource_X;\n            this._physicsRig.outputs.at(outputIndex + j).getValue = getOutputTranslationX;\n            this._physicsRig.outputs.at(outputIndex + j).getScale = getOutputScaleTranslationX;\n          } else if (json.getOutputType(i, j) == PhysicsTypeTagY) {\n            this._physicsRig.outputs.at(outputIndex + j).type = CubismPhysicsSource.CubismPhysicsSource_Y;\n            this._physicsRig.outputs.at(outputIndex + j).getValue = getOutputTranslationY;\n            this._physicsRig.outputs.at(outputIndex + j).getScale = getOutputScaleTranslationY;\n          } else if (json.getOutputType(i, j) == PhysicsTypeTagAngle) {\n            this._physicsRig.outputs.at(outputIndex + j).type = CubismPhysicsSource.CubismPhysicsSource_Angle;\n            this._physicsRig.outputs.at(outputIndex + j).getValue = getOutputAngle;\n            this._physicsRig.outputs.at(outputIndex + j).getScale = getOutputScaleAngle;\n          }\n          this._physicsRig.outputs.at(outputIndex + j).reflect = json.getOutputReflect(i, j);\n        }\n        outputIndex += this._physicsRig.settings.at(i).outputCount;\n\n        // Particle\n        this._physicsRig.settings.at(i).particleCount = json.getParticleCount(i);\n        this._physicsRig.settings.at(i).baseParticleIndex = particleIndex;\n        for (let j = 0; j < this._physicsRig.settings.at(i).particleCount; ++j) {\n          this._physicsRig.particles.at(particleIndex + j).mobility = json.getParticleMobility(i, j);\n          this._physicsRig.particles.at(particleIndex + j).delay = json.getParticleDelay(i, j);\n          this._physicsRig.particles.at(particleIndex + j).acceleration = json.getParticleAcceleration(i, j);\n          this._physicsRig.particles.at(particleIndex + j).radius = json.getParticleRadius(i, j);\n          this._physicsRig.particles.at(particleIndex + j).position = json.getParticlePosition(i, j);\n        }\n        particleIndex += this._physicsRig.settings.at(i).particleCount;\n      }\n      this.initialize();\n      json.release();\n      json = void 0;\n      json = null;\n    }\n\n    /**\r\n     * 初期化する\r\n     */\n    initialize() {\n      let strand;\n      let currentSetting;\n      let radius;\n      for (let settingIndex = 0; settingIndex < this._physicsRig.subRigCount; ++settingIndex) {\n        currentSetting = this._physicsRig.settings.at(settingIndex);\n        strand = this._physicsRig.particles.get(currentSetting.baseParticleIndex);\n\n        // Initialize the top of particle.\n        strand[0].initialPosition = new CubismVector2(0.0, 0.0);\n        strand[0].lastPosition = new CubismVector2(strand[0].initialPosition.x, strand[0].initialPosition.y);\n        strand[0].lastGravity = new CubismVector2(0.0, -1.0);\n        strand[0].lastGravity.y *= -1.0;\n        strand[0].velocity = new CubismVector2(0.0, 0.0);\n        strand[0].force = new CubismVector2(0.0, 0.0);\n\n        // Initialize paritcles.\n        for (let i = 1; i < currentSetting.particleCount; ++i) {\n          radius = new CubismVector2(0.0, 0.0);\n          radius.y = strand[i].radius;\n          strand[i].initialPosition = new CubismVector2(strand[i - 1].initialPosition.x + radius.x, strand[i - 1].initialPosition.y + radius.y);\n          strand[i].position = new CubismVector2(strand[i].initialPosition.x, strand[i].initialPosition.y);\n          strand[i].lastPosition = new CubismVector2(strand[i].initialPosition.x, strand[i].initialPosition.y);\n          strand[i].lastGravity = new CubismVector2(0.0, -1.0);\n          strand[i].lastGravity.y *= -1.0;\n          strand[i].velocity = new CubismVector2(0.0, 0.0);\n          strand[i].force = new CubismVector2(0.0, 0.0);\n        }\n      }\n    }\n\n    // オプション\n  }\n  _Live2DCubismFramework.CubismPhysics = CubismPhysics;\n  class Options {\n    constructor() {\n      this.gravity = void 0;\n      // 重力方向\n      this.wind = void 0;\n      this.gravity = new CubismVector2(0, 0);\n      this.wind = new CubismVector2(0, 0);\n    }\n\n    // 風の方向\n  }\n  _Live2DCubismFramework.Options = Options;\n  /**\r\n   * Gets sign.\r\n   *\r\n   * @param value Evaluation target value.\r\n   *\r\n   * @return Sign of value.\r\n   */\n  function sign(value) {\n    let ret = 0;\n    if (value > 0.0) {\n      ret = 1;\n    } else if (value < 0.0) {\n      ret = -1;\n    }\n    return ret;\n  }\n  function getInputTranslationXFromNormalizedParameterValue(targetTranslation, targetAngle, value, parameterMinimumValue, parameterMaximumValue, parameterDefaultValue, normalizationPosition, normalizationAngle, isInverted, weight) {\n    targetTranslation.x += normalizeParameterValue(value, parameterMinimumValue, parameterMaximumValue, parameterDefaultValue, normalizationPosition.minimum, normalizationPosition.maximum, normalizationPosition.defalut, isInverted) * weight;\n  }\n  function getInputTranslationYFromNormalizedParamterValue(targetTranslation, targetAngle, value, parameterMinimumValue, parameterMaximumValue, parameterDefaultValue, normalizationPosition, normalizationAngle, isInverted, weight) {\n    targetTranslation.y += normalizeParameterValue(value, parameterMinimumValue, parameterMaximumValue, parameterDefaultValue, normalizationPosition.minimum, normalizationPosition.maximum, normalizationPosition.defalut, isInverted) * weight;\n  }\n  function getInputAngleFromNormalizedParameterValue(targetTranslation, targetAngle, value, parameterMinimumValue, parameterMaximumValue, parameterDefaultValue, normalizaitionPosition, normalizationAngle, isInverted, weight) {\n    targetAngle.angle += normalizeParameterValue(value, parameterMinimumValue, parameterMaximumValue, parameterDefaultValue, normalizationAngle.minimum, normalizationAngle.maximum, normalizationAngle.defalut, isInverted) * weight;\n  }\n  function getOutputTranslationX(translation, particles, particleIndex, isInverted, parentGravity) {\n    let outputValue = translation.x;\n    if (isInverted) {\n      outputValue *= -1.0;\n    }\n    return outputValue;\n  }\n  function getOutputTranslationY(translation, particles, particleIndex, isInverted, parentGravity) {\n    let outputValue = translation.y;\n    if (isInverted) {\n      outputValue *= -1.0;\n    }\n    return outputValue;\n  }\n  function getOutputAngle(translation, particles, particleIndex, isInverted, parentGravity) {\n    let outputValue;\n    if (particleIndex >= 2) {\n      parentGravity = particles[particleIndex - 1].position.substract(particles[particleIndex - 2].position);\n    } else {\n      parentGravity = parentGravity.multiplyByScaler(-1.0);\n    }\n    outputValue = CubismMath.directionToRadian(parentGravity, translation);\n    if (isInverted) {\n      outputValue *= -1.0;\n    }\n    return outputValue;\n  }\n  function getRangeValue(min, max) {\n    const maxValue = CubismMath.max(min, max);\n    const minValue = CubismMath.min(min, max);\n    return CubismMath.abs(maxValue - minValue);\n  }\n  function getDefaultValue(min, max) {\n    const minValue = CubismMath.min(min, max);\n    return minValue + getRangeValue(min, max) / 2.0;\n  }\n  function getOutputScaleTranslationX(translationScale, angleScale) {\n    return JSON.parse(JSON.stringify(translationScale.x));\n  }\n  function getOutputScaleTranslationY(translationScale, angleScale) {\n    return JSON.parse(JSON.stringify(translationScale.y));\n  }\n  function getOutputScaleAngle(translationScale, angleScale) {\n    return JSON.parse(JSON.stringify(angleScale));\n  }\n\n  /**\r\n   * Updates particles.\r\n   *\r\n   * @param strand                Target array of particle.\r\n   * @param strandCount           Count of particle.\r\n   * @param totalTranslation      Total translation value.\r\n   * @param totalAngle            Total angle.\r\n   * @param windDirection         Direction of Wind.\r\n   * @param thresholdValue        Threshold of movement.\r\n   * @param deltaTimeSeconds      Delta time.\r\n   * @param airResistance         Air resistance.\r\n   */\n  function updateParticles(strand, strandCount, totalTranslation, totalAngle, windDirection, thresholdValue, deltaTimeSeconds, airResistance) {\n    let totalRadian;\n    let delay;\n    let radian;\n    let currentGravity;\n    let direction = new CubismVector2(0.0, 0.0);\n    let velocity = new CubismVector2(0.0, 0.0);\n    let force = new CubismVector2(0.0, 0.0);\n    let newDirection = new CubismVector2(0.0, 0.0);\n    strand[0].position = new CubismVector2(totalTranslation.x, totalTranslation.y);\n    totalRadian = CubismMath.degreesToRadian(totalAngle);\n    currentGravity = CubismMath.radianToDirection(totalRadian);\n    currentGravity.normalize();\n    for (let i = 1; i < strandCount; ++i) {\n      strand[i].force = currentGravity.multiplyByScaler(strand[i].acceleration).add(windDirection);\n      strand[i].lastPosition = new CubismVector2(strand[i].position.x, strand[i].position.y);\n      delay = strand[i].delay * deltaTimeSeconds * 30.0;\n      direction = strand[i].position.substract(strand[i - 1].position);\n      radian = CubismMath.directionToRadian(strand[i].lastGravity, currentGravity) / airResistance;\n      direction.x = CubismMath.cos(radian) * direction.x - direction.y * CubismMath.sin(radian);\n      direction.y = CubismMath.sin(radian) * direction.x + direction.y * CubismMath.cos(radian);\n      strand[i].position = strand[i - 1].position.add(direction);\n      velocity = strand[i].velocity.multiplyByScaler(delay);\n      force = strand[i].force.multiplyByScaler(delay).multiplyByScaler(delay);\n      strand[i].position = strand[i].position.add(velocity).add(force);\n      newDirection = strand[i].position.substract(strand[i - 1].position);\n      newDirection.normalize();\n      strand[i].position = strand[i - 1].position.add(newDirection.multiplyByScaler(strand[i].radius));\n      if (CubismMath.abs(strand[i].position.x) < thresholdValue) {\n        strand[i].position.x = 0.0;\n      }\n      if (delay != 0.0) {\n        strand[i].velocity = strand[i].position.substract(strand[i].lastPosition);\n        strand[i].velocity = strand[i].velocity.divisionByScalar(delay);\n        strand[i].velocity = strand[i].velocity.multiplyByScaler(strand[i].mobility);\n      }\n      strand[i].force = new CubismVector2(0.0, 0.0);\n      strand[i].lastGravity = new CubismVector2(currentGravity.x, currentGravity.y);\n    }\n  }\n\n  /**\r\n   * Updates output parameter value.\r\n   * @param parameterValue            Target parameter value.\r\n   * @param parameterValueMinimum     Minimum of parameter value.\r\n   * @param parameterValueMaximum     Maximum of parameter value.\r\n   * @param translation               Translation value.\r\n   */\n  function updateOutputParameterValue(parameterValue, parameterValueMinimum, parameterValueMaximum, translation, output) {\n    let outputScale;\n    let value;\n    let weight;\n    outputScale = output.getScale(output.translationScale, output.angleScale);\n    value = translation * outputScale;\n    if (value < parameterValueMinimum) {\n      if (value < output.valueBelowMinimum) {\n        output.valueBelowMinimum = value;\n      }\n      value = parameterValueMinimum;\n    } else if (value > parameterValueMaximum) {\n      if (value > output.valueExceededMaximum) {\n        output.valueExceededMaximum = value;\n      }\n      value = parameterValueMaximum;\n    }\n    weight = output.weight / MaximumWeight;\n    if (weight >= 1.0) {\n      parameterValue[0] = value;\n    } else {\n      value = parameterValue[0] * (1.0 - weight) + value * weight;\n      parameterValue[0] = value;\n    }\n  }\n  function normalizeParameterValue(value, parameterMinimum, parameterMaximum, parameterDefault, normalizedMinimum, normalizedMaximum, normalizedDefault, isInverted) {\n    let result = 0.0;\n    const maxValue = CubismMath.max(parameterMaximum, parameterMinimum);\n    if (maxValue < value) {\n      value = maxValue;\n    }\n    const minValue = CubismMath.min(parameterMaximum, parameterMinimum);\n    if (minValue > value) {\n      value = minValue;\n    }\n    const minNormValue = CubismMath.min(normalizedMinimum, normalizedMaximum);\n    const maxNormValue = CubismMath.max(normalizedMinimum, normalizedMaximum);\n    const middleNormValue = normalizedDefault;\n    const middleValue = getDefaultValue(minValue, maxValue);\n    const paramValue = value - middleValue;\n    switch (sign(paramValue)) {\n      case 1:\n        {\n          const nLength = maxNormValue - middleNormValue;\n          const pLength = maxValue - middleValue;\n          if (pLength != 0.0) {\n            result = paramValue * (nLength / pLength);\n            result += middleNormValue;\n          }\n          break;\n        }\n      case -1:\n        {\n          const nLength = minNormValue - middleNormValue;\n          const pLength = minValue - middleValue;\n          if (pLength != 0.0) {\n            result = paramValue * (nLength / pLength);\n            result += middleNormValue;\n          }\n          break;\n        }\n      case 0:\n        {\n          result = middleNormValue;\n          break;\n        }\n      default:\n        {\n          break;\n        }\n    }\n    return isInverted ? result : result * -1.0;\n  }\n})(Live2DCubismFramework || (Live2DCubismFramework = {}));","map":{"version":3,"names":["Live2DCubismFramework","cubismphysicsinternal","cubismmodel","cubismvector2","cubismmath","cubismphysicsjson","CubismPhysicsJson","CubismMath","CubismPhysicsRig","CubismPhysicsSubRig","CubismPhysicsInput","CubismPhysicsOutput","CubismPhysicsParticle","CubismPhysicsSource","CubismPhysicsTargetType","CubismPhysicsNormalization","CubismVector2","CubismModel","_Live2DCubismFramework","PhysicsTypeTagX","PhysicsTypeTagY","PhysicsTypeTagAngle","AirResistance","MaximumWeight","MovementThreshold","CubismPhysics","create","buffer","size","ret","parse","_physicsRig","gravity","y","delete","physics","release","evaluate","model","deltaTimeSeconds","totalAngle","weight","radAngle","outputValue","totalTranslation","currentSetting","currentInput","currentOutput","currentParticles","parameterValue","parameterMaximumValue","parameterMinimumValue","parameterDefaultValue","getModel","parameters","values","maximumValues","minimumValues","defaultValues","settingIndex","subRigCount","angle","x","settings","at","inputs","get","baseInputIndex","outputs","baseOutputIndex","particles","baseParticleIndex","i","inputCount","sourceParameterIndex","getParameterIndex","source","id","getNormalizedParameterValue","normalizationPosition","normalizationAngle","reflect","degreesToRadian","cos","sin","updateParticles","particleCount","_options","wind","maximum","outputCount","particleIndex","vertexIndex","destinationParameterIndex","destination","translation","position","getValue","outParameterValue","Float32Array","prototype","slice","JSON","stringify","subarray","updateOutputParameterValue","offset","outParamIndex","length","setOptions","options","getOption","constructor","Options","physicsJson","json","getGravity","getWind","getSubRigCount","updateSize","getTotalInputCount","getTotalOutputCount","getVertexCount","inputIndex","outputIndex","getSize","minimum","getNormalizationPositionMinimumValue","getNormalizationPositionMaximumValue","defalut","getNormalizationPositionDefaultValue","getNormalizationAngleMinimumValue","getNormalizationAngleMaximumValue","getNormalizationAngleDefaultValue","getInputCount","j","getInputWeight","getInputReflect","getInputType","type","CubismPhysicsSource_X","getInputTranslationXFromNormalizedParameterValue","CubismPhysicsSource_Y","getInputTranslationYFromNormalizedParamterValue","CubismPhysicsSource_Angle","getInputAngleFromNormalizedParameterValue","targetType","CubismPhysicsTargetType_Parameter","getInputSourceId","getOutputCount","getOutputVertexIndex","angleScale","getOutputAngleScale","getOutputWeight","getOutputDestinationId","getOutputType","getOutputTranslationX","getScale","getOutputScaleTranslationX","getOutputTranslationY","getOutputScaleTranslationY","getOutputAngle","getOutputScaleAngle","getOutputReflect","getParticleCount","mobility","getParticleMobility","delay","getParticleDelay","acceleration","getParticleAcceleration","radius","getParticleRadius","getParticlePosition","initialize","strand","initialPosition","lastPosition","lastGravity","velocity","force","sign","value","targetTranslation","targetAngle","isInverted","normalizeParameterValue","normalizaitionPosition","parentGravity","substract","multiplyByScaler","directionToRadian","getRangeValue","min","max","maxValue","minValue","abs","getDefaultValue","translationScale","strandCount","windDirection","thresholdValue","airResistance","totalRadian","radian","currentGravity","direction","newDirection","radianToDirection","normalize","add","divisionByScalar","parameterValueMinimum","parameterValueMaximum","output","outputScale","valueBelowMinimum","valueExceededMaximum","parameterMinimum","parameterMaximum","parameterDefault","normalizedMinimum","normalizedMaximum","normalizedDefault","result","minNormValue","maxNormValue","middleNormValue","middleValue","paramValue","nLength","pLength"],"sources":["C:/Users/cleyc/OneDrive/Documents/RR/RRWebsiteRenewed/my-app/src/mylive2d/react-live2d/Samples/TypeScript/Demo/Framework/src/physics/cubismphysics.ts"],"sourcesContent":["/**\r\n * Copyright(c) Live2D Inc. All rights reserved.\r\n *\r\n * Use of this source code is governed by the Live2D Open Software license\r\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\r\n */\r\n\r\nimport { Live2DCubismFramework as cubismphysicsinternal } from './cubismphysicsinternal';\r\nimport { Live2DCubismFramework as cubismmodel } from '../model/cubismmodel';\r\nimport { Live2DCubismFramework as cubismvector2 } from '../math/cubismvector2';\r\nimport { Live2DCubismFramework as cubismmath } from '../math/cubismmath';\r\nimport { Live2DCubismFramework as cubismphysicsjson } from './cubismphysicsjson';\r\nimport CubismPhysicsJson = cubismphysicsjson.CubismPhysicsJson;\r\nimport CubismMath = cubismmath.CubismMath;\r\nimport CubismPhysicsRig = cubismphysicsinternal.CubismPhysicsRig;\r\nimport CubismPhysicsSubRig = cubismphysicsinternal.CubismPhysicsSubRig;\r\nimport CubismPhysicsInput = cubismphysicsinternal.CubismPhysicsInput;\r\nimport CubismPhysicsOutput = cubismphysicsinternal.CubismPhysicsOutput;\r\nimport CubismPhysicsParticle = cubismphysicsinternal.CubismPhysicsParticle;\r\nimport CubismPhysicsSource = cubismphysicsinternal.CubismPhysicsSource;\r\nimport CubismPhysicsTargetType = cubismphysicsinternal.CubismPhysicsTargetType;\r\nimport CubismPhysicsNormalization = cubismphysicsinternal.CubismPhysicsNormalization;\r\nimport CubismVector2 = cubismvector2.CubismVector2;\r\nimport CubismModel = cubismmodel.CubismModel;\r\n\r\nexport namespace Live2DCubismFramework {\r\n  // physics types tags.\r\n  const PhysicsTypeTagX = 'X';\r\n  const PhysicsTypeTagY = 'Y';\r\n  const PhysicsTypeTagAngle = 'Angle';\r\n\r\n  // Constant of air resistance.\r\n  const AirResistance = 5.0;\r\n\r\n  // Constant of maximum weight of input and output ratio.\r\n  const MaximumWeight = 100.0;\r\n\r\n  // Constant of threshold of movement.\r\n  const MovementThreshold = 0.001;\r\n\r\n  /**\r\n   * 物理演算クラス\r\n   */\r\n  export class CubismPhysics {\r\n    /**\r\n     * インスタンスの作成\r\n     * @param buffer    physics3.jsonが読み込まれているバッファ\r\n     * @param size      バッファのサイズ\r\n     * @return 作成されたインスタンス\r\n     */\r\n    public static create(buffer: ArrayBuffer, size: number): CubismPhysics {\r\n      const ret: CubismPhysics = new CubismPhysics();\r\n\r\n      ret.parse(buffer, size);\r\n      ret._physicsRig.gravity.y = 0;\r\n\r\n      return ret;\r\n    }\r\n\r\n    /**\r\n     * インスタンスを破棄する\r\n     * @param physics 破棄するインスタンス\r\n     */\r\n    public static delete(physics: CubismPhysics): void {\r\n      if (physics != null) {\r\n        physics.release();\r\n        physics = null;\r\n      }\r\n    }\r\n\r\n    /**\r\n     * 物理演算の評価\r\n     * @param model 物理演算の結果を適用するモデル\r\n     * @param deltaTimeSeconds デルタ時間[秒]\r\n     */\r\n    public evaluate(model: CubismModel, deltaTimeSeconds: number): void {\r\n      let totalAngle: { angle: number };\r\n      let weight: number;\r\n      let radAngle: number;\r\n      let outputValue: number;\r\n      const totalTranslation: CubismVector2 = new CubismVector2();\r\n      let currentSetting: CubismPhysicsSubRig;\r\n      let currentInput: CubismPhysicsInput[];\r\n      let currentOutput: CubismPhysicsOutput[];\r\n      let currentParticles: CubismPhysicsParticle[];\r\n\r\n      let parameterValue: Float32Array;\r\n      let parameterMaximumValue: Float32Array;\r\n      let parameterMinimumValue: Float32Array;\r\n      let parameterDefaultValue: Float32Array;\r\n\r\n      parameterValue = model.getModel().parameters.values;\r\n      parameterMaximumValue = model.getModel().parameters.maximumValues;\r\n      parameterMinimumValue = model.getModel().parameters.minimumValues;\r\n      parameterDefaultValue = model.getModel().parameters.defaultValues;\r\n\r\n      for (\r\n        let settingIndex = 0;\r\n        settingIndex < this._physicsRig.subRigCount;\r\n        ++settingIndex\r\n      ) {\r\n        totalAngle = { angle: 0.0 };\r\n        totalTranslation.x = 0.0;\r\n        totalTranslation.y = 0.0;\r\n        currentSetting = this._physicsRig.settings.at(settingIndex);\r\n        currentInput = this._physicsRig.inputs.get(\r\n          currentSetting.baseInputIndex\r\n        );\r\n        currentOutput = this._physicsRig.outputs.get(\r\n          currentSetting.baseOutputIndex\r\n        );\r\n        currentParticles = this._physicsRig.particles.get(\r\n          currentSetting.baseParticleIndex\r\n        );\r\n\r\n        // Load input parameters\r\n        for (let i = 0; i < currentSetting.inputCount; ++i) {\r\n          weight = currentInput[i].weight / MaximumWeight;\r\n\r\n          if (currentInput[i].sourceParameterIndex == -1) {\r\n            currentInput[i].sourceParameterIndex = model.getParameterIndex(\r\n              currentInput[i].source.id\r\n            );\r\n          }\r\n\r\n          currentInput[i].getNormalizedParameterValue(\r\n            totalTranslation,\r\n            totalAngle,\r\n            parameterValue[currentInput[i].sourceParameterIndex],\r\n            parameterMinimumValue[currentInput[i].sourceParameterIndex],\r\n            parameterMaximumValue[currentInput[i].sourceParameterIndex],\r\n            parameterDefaultValue[currentInput[i].sourceParameterIndex],\r\n            currentSetting.normalizationPosition,\r\n            currentSetting.normalizationAngle,\r\n            currentInput[0].reflect,\r\n            weight\r\n          );\r\n        }\r\n\r\n        radAngle = CubismMath.degreesToRadian(-totalAngle.angle);\r\n\r\n        totalTranslation.x =\r\n          totalTranslation.x * CubismMath.cos(radAngle) -\r\n          totalTranslation.y * CubismMath.sin(radAngle);\r\n        totalTranslation.y =\r\n          totalTranslation.x * CubismMath.sin(radAngle) +\r\n          totalTranslation.y * CubismMath.cos(radAngle);\r\n\r\n        // Calculate particles position.\r\n        updateParticles(\r\n          currentParticles,\r\n          currentSetting.particleCount,\r\n          totalTranslation,\r\n          totalAngle.angle,\r\n          this._options.wind,\r\n          MovementThreshold * currentSetting.normalizationPosition.maximum,\r\n          deltaTimeSeconds,\r\n          AirResistance\r\n        );\r\n\r\n        // Update output parameters.\r\n        for (let i = 0; i < currentSetting.outputCount; ++i) {\r\n          const particleIndex = currentOutput[i].vertexIndex;\r\n\r\n          if (\r\n            particleIndex < 1 ||\r\n            particleIndex >= currentSetting.particleCount\r\n          ) {\r\n            break;\r\n          }\r\n\r\n          if (currentOutput[i].destinationParameterIndex == -1) {\r\n            currentOutput[\r\n              i\r\n            ].destinationParameterIndex = model.getParameterIndex(\r\n              currentOutput[i].destination.id\r\n            );\r\n          }\r\n\r\n          const translation: CubismVector2 = new CubismVector2();\r\n          translation.x =\r\n            currentParticles[particleIndex].position.x -\r\n            currentParticles[particleIndex - 1].position.x;\r\n          translation.y =\r\n            currentParticles[particleIndex].position.y -\r\n            currentParticles[particleIndex - 1].position.y;\r\n\r\n          outputValue = currentOutput[i].getValue(\r\n            translation,\r\n            currentParticles,\r\n            particleIndex,\r\n            currentOutput[i].reflect,\r\n            this._options.gravity\r\n          );\r\n\r\n          const destinationParameterIndex: number =\r\n            currentOutput[i].destinationParameterIndex;\r\n          const outParameterValue: Float32Array =\r\n            !Float32Array.prototype.slice &&\r\n            'subarray' in Float32Array.prototype\r\n              ? JSON.parse(\r\n                  JSON.stringify(\r\n                    parameterValue.subarray(destinationParameterIndex)\r\n                  )\r\n                ) // 値渡しするため、JSON.parse, JSON.stringify\r\n              : parameterValue.slice(destinationParameterIndex);\r\n\r\n          updateOutputParameterValue(\r\n            outParameterValue,\r\n            parameterMinimumValue[destinationParameterIndex],\r\n            parameterMaximumValue[destinationParameterIndex],\r\n            outputValue,\r\n            currentOutput[i]\r\n          );\r\n\r\n          // 値を反映\r\n          for (\r\n            let offset: number = destinationParameterIndex, outParamIndex = 0;\r\n            offset < parameterValue.length;\r\n            offset++, outParamIndex++\r\n          ) {\r\n            parameterValue[offset] = outParameterValue[outParamIndex];\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    /**\r\n     * オプションの設定\r\n     * @param options オプション\r\n     */\r\n    public setOptions(options: Options): void {\r\n      this._options = options;\r\n    }\r\n\r\n    /**\r\n     * オプションの取得\r\n     * @return オプション\r\n     */\r\n    public getOption(): Options {\r\n      return this._options;\r\n    }\r\n\r\n    /**\r\n     * コンストラクタ\r\n     */\r\n    public constructor() {\r\n      this._physicsRig = null;\r\n\r\n      // set default options\r\n      this._options = new Options();\r\n      this._options.gravity.y = -1.0;\r\n      this._options.gravity.x = 0;\r\n      this._options.wind.x = 0;\r\n      this._options.wind.y = 0;\r\n    }\r\n\r\n    /**\r\n     * デストラクタ相当の処理\r\n     */\r\n    public release(): void {\r\n      this._physicsRig = void 0;\r\n      this._physicsRig = null;\r\n    }\r\n\r\n    /**\r\n     * physics3.jsonをパースする。\r\n     * @param physicsJson physics3.jsonが読み込まれているバッファ\r\n     * @param size バッファのサイズ\r\n     */\r\n    public parse(physicsJson: ArrayBuffer, size: number): void {\r\n      this._physicsRig = new CubismPhysicsRig();\r\n\r\n      let json: CubismPhysicsJson = new CubismPhysicsJson(physicsJson, size);\r\n\r\n      this._physicsRig.gravity = json.getGravity();\r\n      this._physicsRig.wind = json.getWind();\r\n      this._physicsRig.subRigCount = json.getSubRigCount();\r\n\r\n      this._physicsRig.settings.updateSize(\r\n        this._physicsRig.subRigCount,\r\n        CubismPhysicsSubRig,\r\n        true\r\n      );\r\n      this._physicsRig.inputs.updateSize(\r\n        json.getTotalInputCount(),\r\n        CubismPhysicsInput,\r\n        true\r\n      );\r\n      this._physicsRig.outputs.updateSize(\r\n        json.getTotalOutputCount(),\r\n        CubismPhysicsOutput,\r\n        true\r\n      );\r\n      this._physicsRig.particles.updateSize(\r\n        json.getVertexCount(),\r\n        CubismPhysicsParticle,\r\n        true\r\n      );\r\n\r\n      let inputIndex = 0,\r\n        outputIndex = 0,\r\n        particleIndex = 0;\r\n\r\n      for (let i = 0; i < this._physicsRig.settings.getSize(); ++i) {\r\n        this._physicsRig.settings.at(\r\n          i\r\n        ).normalizationPosition.minimum = json.getNormalizationPositionMinimumValue(\r\n          i\r\n        );\r\n        this._physicsRig.settings.at(\r\n          i\r\n        ).normalizationPosition.maximum = json.getNormalizationPositionMaximumValue(\r\n          i\r\n        );\r\n        this._physicsRig.settings.at(\r\n          i\r\n        ).normalizationPosition.defalut = json.getNormalizationPositionDefaultValue(\r\n          i\r\n        );\r\n\r\n        this._physicsRig.settings.at(\r\n          i\r\n        ).normalizationAngle.minimum = json.getNormalizationAngleMinimumValue(\r\n          i\r\n        );\r\n        this._physicsRig.settings.at(\r\n          i\r\n        ).normalizationAngle.maximum = json.getNormalizationAngleMaximumValue(\r\n          i\r\n        );\r\n        this._physicsRig.settings.at(\r\n          i\r\n        ).normalizationAngle.defalut = json.getNormalizationAngleDefaultValue(\r\n          i\r\n        );\r\n\r\n        // Input\r\n        this._physicsRig.settings.at(i).inputCount = json.getInputCount(i);\r\n        this._physicsRig.settings.at(i).baseInputIndex = inputIndex;\r\n\r\n        for (let j = 0; j < this._physicsRig.settings.at(i).inputCount; ++j) {\r\n          this._physicsRig.inputs.at(inputIndex + j).sourceParameterIndex = -1;\r\n          this._physicsRig.inputs.at(\r\n            inputIndex + j\r\n          ).weight = json.getInputWeight(i, j);\r\n          this._physicsRig.inputs.at(\r\n            inputIndex + j\r\n          ).reflect = json.getInputReflect(i, j);\r\n\r\n          if (json.getInputType(i, j) == PhysicsTypeTagX) {\r\n            this._physicsRig.inputs.at(inputIndex + j).type =\r\n              CubismPhysicsSource.CubismPhysicsSource_X;\r\n            this._physicsRig.inputs.at(\r\n              inputIndex + j\r\n            ).getNormalizedParameterValue = getInputTranslationXFromNormalizedParameterValue;\r\n          } else if (json.getInputType(i, j) == PhysicsTypeTagY) {\r\n            this._physicsRig.inputs.at(inputIndex + j).type =\r\n              CubismPhysicsSource.CubismPhysicsSource_Y;\r\n            this._physicsRig.inputs.at(\r\n              inputIndex + j\r\n            ).getNormalizedParameterValue = getInputTranslationYFromNormalizedParamterValue;\r\n          } else if (json.getInputType(i, j) == PhysicsTypeTagAngle) {\r\n            this._physicsRig.inputs.at(inputIndex + j).type =\r\n              CubismPhysicsSource.CubismPhysicsSource_Angle;\r\n            this._physicsRig.inputs.at(\r\n              inputIndex + j\r\n            ).getNormalizedParameterValue = getInputAngleFromNormalizedParameterValue;\r\n          }\r\n\r\n          this._physicsRig.inputs.at(inputIndex + j).source.targetType =\r\n            CubismPhysicsTargetType.CubismPhysicsTargetType_Parameter;\r\n          this._physicsRig.inputs.at(\r\n            inputIndex + j\r\n          ).source.id = json.getInputSourceId(i, j);\r\n        }\r\n        inputIndex += this._physicsRig.settings.at(i).inputCount;\r\n\r\n        // Output\r\n        this._physicsRig.settings.at(i).outputCount = json.getOutputCount(i);\r\n        this._physicsRig.settings.at(i).baseOutputIndex = outputIndex;\r\n\r\n        for (let j = 0; j < this._physicsRig.settings.at(i).outputCount; ++j) {\r\n          this._physicsRig.outputs.at(\r\n            outputIndex + j\r\n          ).destinationParameterIndex = -1;\r\n          this._physicsRig.outputs.at(\r\n            outputIndex + j\r\n          ).vertexIndex = json.getOutputVertexIndex(i, j);\r\n          this._physicsRig.outputs.at(\r\n            outputIndex + j\r\n          ).angleScale = json.getOutputAngleScale(i, j);\r\n          this._physicsRig.outputs.at(\r\n            outputIndex + j\r\n          ).weight = json.getOutputWeight(i, j);\r\n          this._physicsRig.outputs.at(outputIndex + j).destination.targetType =\r\n            CubismPhysicsTargetType.CubismPhysicsTargetType_Parameter;\r\n\r\n          this._physicsRig.outputs.at(\r\n            outputIndex + j\r\n          ).destination.id = json.getOutputDestinationId(i, j);\r\n\r\n          if (json.getOutputType(i, j) == PhysicsTypeTagX) {\r\n            this._physicsRig.outputs.at(outputIndex + j).type =\r\n              CubismPhysicsSource.CubismPhysicsSource_X;\r\n            this._physicsRig.outputs.at(\r\n              outputIndex + j\r\n            ).getValue = getOutputTranslationX;\r\n            this._physicsRig.outputs.at(\r\n              outputIndex + j\r\n            ).getScale = getOutputScaleTranslationX;\r\n          } else if (json.getOutputType(i, j) == PhysicsTypeTagY) {\r\n            this._physicsRig.outputs.at(outputIndex + j).type =\r\n              CubismPhysicsSource.CubismPhysicsSource_Y;\r\n            this._physicsRig.outputs.at(\r\n              outputIndex + j\r\n            ).getValue = getOutputTranslationY;\r\n            this._physicsRig.outputs.at(\r\n              outputIndex + j\r\n            ).getScale = getOutputScaleTranslationY;\r\n          } else if (json.getOutputType(i, j) == PhysicsTypeTagAngle) {\r\n            this._physicsRig.outputs.at(outputIndex + j).type =\r\n              CubismPhysicsSource.CubismPhysicsSource_Angle;\r\n            this._physicsRig.outputs.at(\r\n              outputIndex + j\r\n            ).getValue = getOutputAngle;\r\n            this._physicsRig.outputs.at(\r\n              outputIndex + j\r\n            ).getScale = getOutputScaleAngle;\r\n          }\r\n\r\n          this._physicsRig.outputs.at(\r\n            outputIndex + j\r\n          ).reflect = json.getOutputReflect(i, j);\r\n        }\r\n        outputIndex += this._physicsRig.settings.at(i).outputCount;\r\n\r\n        // Particle\r\n        this._physicsRig.settings.at(i).particleCount = json.getParticleCount(\r\n          i\r\n        );\r\n        this._physicsRig.settings.at(i).baseParticleIndex = particleIndex;\r\n\r\n        for (\r\n          let j = 0;\r\n          j < this._physicsRig.settings.at(i).particleCount;\r\n          ++j\r\n        ) {\r\n          this._physicsRig.particles.at(\r\n            particleIndex + j\r\n          ).mobility = json.getParticleMobility(i, j);\r\n          this._physicsRig.particles.at(\r\n            particleIndex + j\r\n          ).delay = json.getParticleDelay(i, j);\r\n          this._physicsRig.particles.at(\r\n            particleIndex + j\r\n          ).acceleration = json.getParticleAcceleration(i, j);\r\n          this._physicsRig.particles.at(\r\n            particleIndex + j\r\n          ).radius = json.getParticleRadius(i, j);\r\n          this._physicsRig.particles.at(\r\n            particleIndex + j\r\n          ).position = json.getParticlePosition(i, j);\r\n        }\r\n\r\n        particleIndex += this._physicsRig.settings.at(i).particleCount;\r\n      }\r\n\r\n      this.initialize();\r\n\r\n      json.release();\r\n      json = void 0;\r\n      json = null;\r\n    }\r\n\r\n    /**\r\n     * 初期化する\r\n     */\r\n    public initialize(): void {\r\n      let strand: CubismPhysicsParticle[];\r\n      let currentSetting: CubismPhysicsSubRig;\r\n      let radius: CubismVector2;\r\n\r\n      for (\r\n        let settingIndex = 0;\r\n        settingIndex < this._physicsRig.subRigCount;\r\n        ++settingIndex\r\n      ) {\r\n        currentSetting = this._physicsRig.settings.at(settingIndex);\r\n        strand = this._physicsRig.particles.get(\r\n          currentSetting.baseParticleIndex\r\n        );\r\n\r\n        // Initialize the top of particle.\r\n        strand[0].initialPosition = new CubismVector2(0.0, 0.0);\r\n        strand[0].lastPosition = new CubismVector2(\r\n          strand[0].initialPosition.x,\r\n          strand[0].initialPosition.y\r\n        );\r\n        strand[0].lastGravity = new CubismVector2(0.0, -1.0);\r\n        strand[0].lastGravity.y *= -1.0;\r\n        strand[0].velocity = new CubismVector2(0.0, 0.0);\r\n        strand[0].force = new CubismVector2(0.0, 0.0);\r\n\r\n        // Initialize paritcles.\r\n        for (let i = 1; i < currentSetting.particleCount; ++i) {\r\n          radius = new CubismVector2(0.0, 0.0);\r\n          radius.y = strand[i].radius;\r\n          strand[i].initialPosition = new CubismVector2(\r\n            strand[i - 1].initialPosition.x + radius.x,\r\n            strand[i - 1].initialPosition.y + radius.y\r\n          );\r\n          strand[i].position = new CubismVector2(\r\n            strand[i].initialPosition.x,\r\n            strand[i].initialPosition.y\r\n          );\r\n          strand[i].lastPosition = new CubismVector2(\r\n            strand[i].initialPosition.x,\r\n            strand[i].initialPosition.y\r\n          );\r\n          strand[i].lastGravity = new CubismVector2(0.0, -1.0);\r\n          strand[i].lastGravity.y *= -1.0;\r\n          strand[i].velocity = new CubismVector2(0.0, 0.0);\r\n          strand[i].force = new CubismVector2(0.0, 0.0);\r\n        }\r\n      }\r\n    }\r\n\r\n    _physicsRig: CubismPhysicsRig; // 物理演算のデータ\r\n    _options: Options; // オプション\r\n  }\r\n\r\n  /**\r\n   * 物理演算のオプション\r\n   */\r\n  export class Options {\r\n    constructor() {\r\n      this.gravity = new CubismVector2(0, 0);\r\n      this.wind = new CubismVector2(0, 0);\r\n    }\r\n\r\n    gravity: CubismVector2; // 重力方向\r\n    wind: CubismVector2; // 風の方向\r\n  }\r\n\r\n  /**\r\n   * Gets sign.\r\n   *\r\n   * @param value Evaluation target value.\r\n   *\r\n   * @return Sign of value.\r\n   */\r\n  function sign(value: number): number {\r\n    let ret = 0;\r\n\r\n    if (value > 0.0) {\r\n      ret = 1;\r\n    } else if (value < 0.0) {\r\n      ret = -1;\r\n    }\r\n\r\n    return ret;\r\n  }\r\n\r\n  function getInputTranslationXFromNormalizedParameterValue(\r\n    targetTranslation: CubismVector2,\r\n    targetAngle: { angle: number },\r\n    value: number,\r\n    parameterMinimumValue: number,\r\n    parameterMaximumValue: number,\r\n    parameterDefaultValue: number,\r\n    normalizationPosition: CubismPhysicsNormalization,\r\n    normalizationAngle: CubismPhysicsNormalization,\r\n    isInverted: boolean,\r\n    weight: number\r\n  ): void {\r\n    targetTranslation.x +=\r\n      normalizeParameterValue(\r\n        value,\r\n        parameterMinimumValue,\r\n        parameterMaximumValue,\r\n        parameterDefaultValue,\r\n        normalizationPosition.minimum,\r\n        normalizationPosition.maximum,\r\n        normalizationPosition.defalut,\r\n        isInverted\r\n      ) * weight;\r\n  }\r\n\r\n  function getInputTranslationYFromNormalizedParamterValue(\r\n    targetTranslation: CubismVector2,\r\n    targetAngle: { angle: number },\r\n    value: number,\r\n    parameterMinimumValue: number,\r\n    parameterMaximumValue: number,\r\n    parameterDefaultValue: number,\r\n    normalizationPosition: CubismPhysicsNormalization,\r\n    normalizationAngle: CubismPhysicsNormalization,\r\n    isInverted: boolean,\r\n    weight: number\r\n  ): void {\r\n    targetTranslation.y +=\r\n      normalizeParameterValue(\r\n        value,\r\n        parameterMinimumValue,\r\n        parameterMaximumValue,\r\n        parameterDefaultValue,\r\n        normalizationPosition.minimum,\r\n        normalizationPosition.maximum,\r\n        normalizationPosition.defalut,\r\n        isInverted\r\n      ) * weight;\r\n  }\r\n\r\n  function getInputAngleFromNormalizedParameterValue(\r\n    targetTranslation: CubismVector2,\r\n    targetAngle: { angle: number },\r\n    value: number,\r\n    parameterMinimumValue: number,\r\n    parameterMaximumValue: number,\r\n    parameterDefaultValue: number,\r\n    normalizaitionPosition: CubismPhysicsNormalization,\r\n    normalizationAngle: CubismPhysicsNormalization,\r\n    isInverted: boolean,\r\n    weight: number\r\n  ): void {\r\n    targetAngle.angle +=\r\n      normalizeParameterValue(\r\n        value,\r\n        parameterMinimumValue,\r\n        parameterMaximumValue,\r\n        parameterDefaultValue,\r\n        normalizationAngle.minimum,\r\n        normalizationAngle.maximum,\r\n        normalizationAngle.defalut,\r\n        isInverted\r\n      ) * weight;\r\n  }\r\n\r\n  function getOutputTranslationX(\r\n    translation: CubismVector2,\r\n    particles: CubismPhysicsParticle[],\r\n    particleIndex: number,\r\n    isInverted: boolean,\r\n    parentGravity: CubismVector2\r\n  ): number {\r\n    let outputValue: number = translation.x;\r\n\r\n    if (isInverted) {\r\n      outputValue *= -1.0;\r\n    }\r\n\r\n    return outputValue;\r\n  }\r\n\r\n  function getOutputTranslationY(\r\n    translation: CubismVector2,\r\n    particles: CubismPhysicsParticle[],\r\n    particleIndex: number,\r\n    isInverted: boolean,\r\n    parentGravity: CubismVector2\r\n  ): number {\r\n    let outputValue: number = translation.y;\r\n\r\n    if (isInverted) {\r\n      outputValue *= -1.0;\r\n    }\r\n    return outputValue;\r\n  }\r\n\r\n  function getOutputAngle(\r\n    translation: CubismVector2,\r\n    particles: CubismPhysicsParticle[],\r\n    particleIndex: number,\r\n    isInverted: boolean,\r\n    parentGravity: CubismVector2\r\n  ): number {\r\n    let outputValue: number;\r\n\r\n    if (particleIndex >= 2) {\r\n      parentGravity = particles[particleIndex - 1].position.substract(\r\n        particles[particleIndex - 2].position\r\n      );\r\n    } else {\r\n      parentGravity = parentGravity.multiplyByScaler(-1.0);\r\n    }\r\n\r\n    outputValue = CubismMath.directionToRadian(parentGravity, translation);\r\n\r\n    if (isInverted) {\r\n      outputValue *= -1.0;\r\n    }\r\n\r\n    return outputValue;\r\n  }\r\n\r\n  function getRangeValue(min: number, max: number): number {\r\n    const maxValue: number = CubismMath.max(min, max);\r\n    const minValue: number = CubismMath.min(min, max);\r\n\r\n    return CubismMath.abs(maxValue - minValue);\r\n  }\r\n\r\n  function getDefaultValue(min: number, max: number): number {\r\n    const minValue: number = CubismMath.min(min, max);\r\n    return minValue + getRangeValue(min, max) / 2.0;\r\n  }\r\n\r\n  function getOutputScaleTranslationX(\r\n    translationScale: CubismVector2,\r\n    angleScale: number\r\n  ): number {\r\n    return JSON.parse(JSON.stringify(translationScale.x));\r\n  }\r\n\r\n  function getOutputScaleTranslationY(\r\n    translationScale: CubismVector2,\r\n    angleScale: number\r\n  ): number {\r\n    return JSON.parse(JSON.stringify(translationScale.y));\r\n  }\r\n\r\n  function getOutputScaleAngle(\r\n    translationScale: CubismVector2,\r\n    angleScale: number\r\n  ): number {\r\n    return JSON.parse(JSON.stringify(angleScale));\r\n  }\r\n\r\n  /**\r\n   * Updates particles.\r\n   *\r\n   * @param strand                Target array of particle.\r\n   * @param strandCount           Count of particle.\r\n   * @param totalTranslation      Total translation value.\r\n   * @param totalAngle            Total angle.\r\n   * @param windDirection         Direction of Wind.\r\n   * @param thresholdValue        Threshold of movement.\r\n   * @param deltaTimeSeconds      Delta time.\r\n   * @param airResistance         Air resistance.\r\n   */\r\n  function updateParticles(\r\n    strand: CubismPhysicsParticle[],\r\n    strandCount: number,\r\n    totalTranslation: CubismVector2,\r\n    totalAngle: number,\r\n    windDirection: CubismVector2,\r\n    thresholdValue: number,\r\n    deltaTimeSeconds: number,\r\n    airResistance: number\r\n  ) {\r\n    let totalRadian: number;\r\n    let delay: number;\r\n    let radian: number;\r\n    let currentGravity: CubismVector2;\r\n    let direction: CubismVector2 = new CubismVector2(0.0, 0.0);\r\n    let velocity: CubismVector2 = new CubismVector2(0.0, 0.0);\r\n    let force: CubismVector2 = new CubismVector2(0.0, 0.0);\r\n    let newDirection: CubismVector2 = new CubismVector2(0.0, 0.0);\r\n\r\n    strand[0].position = new CubismVector2(\r\n      totalTranslation.x,\r\n      totalTranslation.y\r\n    );\r\n\r\n    totalRadian = CubismMath.degreesToRadian(totalAngle);\r\n    currentGravity = CubismMath.radianToDirection(totalRadian);\r\n    currentGravity.normalize();\r\n\r\n    for (let i = 1; i < strandCount; ++i) {\r\n      strand[i].force = currentGravity\r\n        .multiplyByScaler(strand[i].acceleration)\r\n        .add(windDirection);\r\n\r\n      strand[i].lastPosition = new CubismVector2(\r\n        strand[i].position.x,\r\n        strand[i].position.y\r\n      );\r\n\r\n      delay = strand[i].delay * deltaTimeSeconds * 30.0;\r\n\r\n      direction = strand[i].position.substract(strand[i - 1].position);\r\n\r\n      radian =\r\n        CubismMath.directionToRadian(strand[i].lastGravity, currentGravity) /\r\n        airResistance;\r\n\r\n      direction.x =\r\n        CubismMath.cos(radian) * direction.x -\r\n        direction.y * CubismMath.sin(radian);\r\n      direction.y =\r\n        CubismMath.sin(radian) * direction.x +\r\n        direction.y * CubismMath.cos(radian);\r\n\r\n      strand[i].position = strand[i - 1].position.add(direction);\r\n\r\n      velocity = strand[i].velocity.multiplyByScaler(delay);\r\n      force = strand[i].force.multiplyByScaler(delay).multiplyByScaler(delay);\r\n\r\n      strand[i].position = strand[i].position.add(velocity).add(force);\r\n\r\n      newDirection = strand[i].position.substract(strand[i - 1].position);\r\n      newDirection.normalize();\r\n\r\n      strand[i].position = strand[i - 1].position.add(\r\n        newDirection.multiplyByScaler(strand[i].radius)\r\n      );\r\n\r\n      if (CubismMath.abs(strand[i].position.x) < thresholdValue) {\r\n        strand[i].position.x = 0.0;\r\n      }\r\n\r\n      if (delay != 0.0) {\r\n        strand[i].velocity = strand[i].position.substract(\r\n          strand[i].lastPosition\r\n        );\r\n        strand[i].velocity = strand[i].velocity.divisionByScalar(delay);\r\n        strand[i].velocity = strand[i].velocity.multiplyByScaler(\r\n          strand[i].mobility\r\n        );\r\n      }\r\n\r\n      strand[i].force = new CubismVector2(0.0, 0.0);\r\n      strand[i].lastGravity = new CubismVector2(\r\n        currentGravity.x,\r\n        currentGravity.y\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Updates output parameter value.\r\n   * @param parameterValue            Target parameter value.\r\n   * @param parameterValueMinimum     Minimum of parameter value.\r\n   * @param parameterValueMaximum     Maximum of parameter value.\r\n   * @param translation               Translation value.\r\n   */\r\n  function updateOutputParameterValue(\r\n    parameterValue: Float32Array,\r\n    parameterValueMinimum: number,\r\n    parameterValueMaximum: number,\r\n    translation: number,\r\n    output: CubismPhysicsOutput\r\n  ): void {\r\n    let outputScale: number;\r\n    let value: number;\r\n    let weight: number;\r\n\r\n    outputScale = output.getScale(output.translationScale, output.angleScale);\r\n\r\n    value = translation * outputScale;\r\n\r\n    if (value < parameterValueMinimum) {\r\n      if (value < output.valueBelowMinimum) {\r\n        output.valueBelowMinimum = value;\r\n      }\r\n\r\n      value = parameterValueMinimum;\r\n    } else if (value > parameterValueMaximum) {\r\n      if (value > output.valueExceededMaximum) {\r\n        output.valueExceededMaximum = value;\r\n      }\r\n\r\n      value = parameterValueMaximum;\r\n    }\r\n\r\n    weight = output.weight / MaximumWeight;\r\n\r\n    if (weight >= 1.0) {\r\n      parameterValue[0] = value;\r\n    } else {\r\n      value = parameterValue[0] * (1.0 - weight) + value * weight;\r\n      parameterValue[0] = value;\r\n    }\r\n  }\r\n\r\n  function normalizeParameterValue(\r\n    value: number,\r\n    parameterMinimum: number,\r\n    parameterMaximum: number,\r\n    parameterDefault: number,\r\n    normalizedMinimum: number,\r\n    normalizedMaximum: number,\r\n    normalizedDefault: number,\r\n    isInverted: boolean\r\n  ) {\r\n    let result = 0.0;\r\n\r\n    const maxValue: number = CubismMath.max(parameterMaximum, parameterMinimum);\r\n\r\n    if (maxValue < value) {\r\n      value = maxValue;\r\n    }\r\n\r\n    const minValue: number = CubismMath.min(parameterMaximum, parameterMinimum);\r\n\r\n    if (minValue > value) {\r\n      value = minValue;\r\n    }\r\n\r\n    const minNormValue: number = CubismMath.min(\r\n      normalizedMinimum,\r\n      normalizedMaximum\r\n    );\r\n    const maxNormValue: number = CubismMath.max(\r\n      normalizedMinimum,\r\n      normalizedMaximum\r\n    );\r\n    const middleNormValue: number = normalizedDefault;\r\n\r\n    const middleValue: number = getDefaultValue(minValue, maxValue);\r\n    const paramValue: number = value - middleValue;\r\n\r\n    switch (sign(paramValue)) {\r\n      case 1: {\r\n        const nLength: number = maxNormValue - middleNormValue;\r\n        const pLength: number = maxValue - middleValue;\r\n\r\n        if (pLength != 0.0) {\r\n          result = paramValue * (nLength / pLength);\r\n          result += middleNormValue;\r\n        }\r\n\r\n        break;\r\n      }\r\n      case -1: {\r\n        const nLength: number = minNormValue - middleNormValue;\r\n        const pLength: number = minValue - middleValue;\r\n\r\n        if (pLength != 0.0) {\r\n          result = paramValue * (nLength / pLength);\r\n          result += middleNormValue;\r\n        }\r\n\r\n        break;\r\n      }\r\n      case 0: {\r\n        result = middleNormValue;\r\n\r\n        break;\r\n      }\r\n      default: {\r\n        break;\r\n      }\r\n    }\r\n\r\n    return isInverted ? result : result * -1.0;\r\n  }\r\n}\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASA,qBAAqB,IAAIC,qBAAqB,QAAQ,yBAAyB;AACxF,SAASD,qBAAqB,IAAIE,WAAW,QAAQ,sBAAsB;AAC3E,SAASF,qBAAqB,IAAIG,aAAa,QAAQ,uBAAuB;AAC9E,SAASH,qBAAqB,IAAII,UAAU,QAAQ,oBAAoB;AACxE,SAASJ,qBAAqB,IAAIK,iBAAiB,QAAQ,qBAAqB;AAAC,IAC1EC,iBAAiB,GAAGD,iBAAiB,CAACC,iBAAiB;AAAA,IACvDC,UAAU,GAAGH,UAAU,CAACG,UAAU;AAAA,IAClCC,gBAAgB,GAAGP,qBAAqB,CAACO,gBAAgB;AAAA,IACzDC,mBAAmB,GAAGR,qBAAqB,CAACQ,mBAAmB;AAAA,IAC/DC,kBAAkB,GAAGT,qBAAqB,CAACS,kBAAkB;AAAA,IAC7DC,mBAAmB,GAAGV,qBAAqB,CAACU,mBAAmB;AAAA,IAC/DC,qBAAqB,GAAGX,qBAAqB,CAACW,qBAAqB;AAAA,IACnEC,mBAAmB,GAAGZ,qBAAqB,CAACY,mBAAmB;AAAA,IAC/DC,uBAAuB,GAAGb,qBAAqB,CAACa,uBAAuB;AAAA,IACvEC,0BAA0B,GAAGd,qBAAqB,CAACc,0BAA0B;AAAA,IAC7EC,aAAa,GAAGb,aAAa,CAACa,aAAa;AAAA,IAC3CC,WAAW,GAAGf,WAAW,CAACe,WAAW;AAE5C,WAAAjB,qBAAA;AA25BC,WAAAkB,sBAAA;EA15BC;EACA,MAAMC,eAAe,GAAG,GAAG;EAC3B,MAAMC,eAAe,GAAG,GAAG;EAC3B,MAAMC,mBAAmB,GAAG,OAAO;;EAEnC;EACA,MAAMC,aAAa,GAAG,GAAG;;EAEzB;EACA,MAAMC,aAAa,GAAG,KAAK;;EAE3B;EACA,MAAMC,iBAAiB,GAAG,KAAK;;EAE/B;AACF;AACA;EACS,MAAMC,aAAa,CAAC;IACzB;AACJ;AACA;AACA;AACA;AACA;IACI,OAAcC,MAAMA,CAACC,MAAmB,EAAEC,IAAY,EAAiB;MACrE,MAAMC,GAAkB,GAAG,IAAIJ,aAAa,CAAC,CAAC;MAE9CI,GAAG,CAACC,KAAK,CAACH,MAAM,EAAEC,IAAI,CAAC;MACvBC,GAAG,CAACE,WAAW,CAACC,OAAO,CAACC,CAAC,GAAG,CAAC;MAE7B,OAAOJ,GAAG;IACZ;;IAEA;AACJ;AACA;AACA;IACI,OAAcK,MAAMA,CAACC,OAAsB,EAAQ;MACjD,IAAIA,OAAO,IAAI,IAAI,EAAE;QACnBA,OAAO,CAACC,OAAO,CAAC,CAAC;QACjBD,OAAO,GAAG,IAAI;MAChB;IACF;;IAEA;AACJ;AACA;AACA;AACA;IACWE,QAAQA,CAACC,KAAkB,EAAEC,gBAAwB,EAAQ;MAClE,IAAIC,UAA6B;MACjC,IAAIC,MAAc;MAClB,IAAIC,QAAgB;MACpB,IAAIC,WAAmB;MACvB,MAAMC,gBAA+B,GAAG,IAAI5B,aAAa,CAAC,CAAC;MAC3D,IAAI6B,cAAmC;MACvC,IAAIC,YAAkC;MACtC,IAAIC,aAAoC;MACxC,IAAIC,gBAAyC;MAE7C,IAAIC,cAA4B;MAChC,IAAIC,qBAAmC;MACvC,IAAIC,qBAAmC;MACvC,IAAIC,qBAAmC;MAEvCH,cAAc,GAAGX,KAAK,CAACe,QAAQ,CAAC,CAAC,CAACC,UAAU,CAACC,MAAM;MACnDL,qBAAqB,GAAGZ,KAAK,CAACe,QAAQ,CAAC,CAAC,CAACC,UAAU,CAACE,aAAa;MACjEL,qBAAqB,GAAGb,KAAK,CAACe,QAAQ,CAAC,CAAC,CAACC,UAAU,CAACG,aAAa;MACjEL,qBAAqB,GAAGd,KAAK,CAACe,QAAQ,CAAC,CAAC,CAACC,UAAU,CAACI,aAAa;MAEjE,KACE,IAAIC,YAAY,GAAG,CAAC,EACpBA,YAAY,GAAG,IAAI,CAAC5B,WAAW,CAAC6B,WAAW,EAC3C,EAAED,YAAY,EACd;QACAnB,UAAU,GAAG;UAAEqB,KAAK,EAAE;QAAI,CAAC;QAC3BjB,gBAAgB,CAACkB,CAAC,GAAG,GAAG;QACxBlB,gBAAgB,CAACX,CAAC,GAAG,GAAG;QACxBY,cAAc,GAAG,IAAI,CAACd,WAAW,CAACgC,QAAQ,CAACC,EAAE,CAACL,YAAY,CAAC;QAC3Db,YAAY,GAAG,IAAI,CAACf,WAAW,CAACkC,MAAM,CAACC,GAAG,CACxCrB,cAAc,CAACsB,cACjB,CAAC;QACDpB,aAAa,GAAG,IAAI,CAAChB,WAAW,CAACqC,OAAO,CAACF,GAAG,CAC1CrB,cAAc,CAACwB,eACjB,CAAC;QACDrB,gBAAgB,GAAG,IAAI,CAACjB,WAAW,CAACuC,SAAS,CAACJ,GAAG,CAC/CrB,cAAc,CAAC0B,iBACjB,CAAC;;QAED;QACA,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG3B,cAAc,CAAC4B,UAAU,EAAE,EAAED,CAAC,EAAE;UAClD/B,MAAM,GAAGK,YAAY,CAAC0B,CAAC,CAAC,CAAC/B,MAAM,GAAGlB,aAAa;UAE/C,IAAIuB,YAAY,CAAC0B,CAAC,CAAC,CAACE,oBAAoB,IAAI,CAAC,CAAC,EAAE;YAC9C5B,YAAY,CAAC0B,CAAC,CAAC,CAACE,oBAAoB,GAAGpC,KAAK,CAACqC,iBAAiB,CAC5D7B,YAAY,CAAC0B,CAAC,CAAC,CAACI,MAAM,CAACC,EACzB,CAAC;UACH;UAEA/B,YAAY,CAAC0B,CAAC,CAAC,CAACM,2BAA2B,CACzClC,gBAAgB,EAChBJ,UAAU,EACVS,cAAc,CAACH,YAAY,CAAC0B,CAAC,CAAC,CAACE,oBAAoB,CAAC,EACpDvB,qBAAqB,CAACL,YAAY,CAAC0B,CAAC,CAAC,CAACE,oBAAoB,CAAC,EAC3DxB,qBAAqB,CAACJ,YAAY,CAAC0B,CAAC,CAAC,CAACE,oBAAoB,CAAC,EAC3DtB,qBAAqB,CAACN,YAAY,CAAC0B,CAAC,CAAC,CAACE,oBAAoB,CAAC,EAC3D7B,cAAc,CAACkC,qBAAqB,EACpClC,cAAc,CAACmC,kBAAkB,EACjClC,YAAY,CAAC,CAAC,CAAC,CAACmC,OAAO,EACvBxC,MACF,CAAC;QACH;QAEAC,QAAQ,GAAGnC,UAAU,CAAC2E,eAAe,CAAC,CAAC1C,UAAU,CAACqB,KAAK,CAAC;QAExDjB,gBAAgB,CAACkB,CAAC,GAChBlB,gBAAgB,CAACkB,CAAC,GAAGvD,UAAU,CAAC4E,GAAG,CAACzC,QAAQ,CAAC,GAC7CE,gBAAgB,CAACX,CAAC,GAAG1B,UAAU,CAAC6E,GAAG,CAAC1C,QAAQ,CAAC;QAC/CE,gBAAgB,CAACX,CAAC,GAChBW,gBAAgB,CAACkB,CAAC,GAAGvD,UAAU,CAAC6E,GAAG,CAAC1C,QAAQ,CAAC,GAC7CE,gBAAgB,CAACX,CAAC,GAAG1B,UAAU,CAAC4E,GAAG,CAACzC,QAAQ,CAAC;;QAE/C;QACA2C,eAAe,CACbrC,gBAAgB,EAChBH,cAAc,CAACyC,aAAa,EAC5B1C,gBAAgB,EAChBJ,UAAU,CAACqB,KAAK,EAChB,IAAI,CAAC0B,QAAQ,CAACC,IAAI,EAClBhE,iBAAiB,GAAGqB,cAAc,CAACkC,qBAAqB,CAACU,OAAO,EAChElD,gBAAgB,EAChBjB,aACF,CAAC;;QAED;QACA,KAAK,IAAIkD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG3B,cAAc,CAAC6C,WAAW,EAAE,EAAElB,CAAC,EAAE;UACnD,MAAMmB,aAAa,GAAG5C,aAAa,CAACyB,CAAC,CAAC,CAACoB,WAAW;UAElD,IACED,aAAa,GAAG,CAAC,IACjBA,aAAa,IAAI9C,cAAc,CAACyC,aAAa,EAC7C;YACA;UACF;UAEA,IAAIvC,aAAa,CAACyB,CAAC,CAAC,CAACqB,yBAAyB,IAAI,CAAC,CAAC,EAAE;YACpD9C,aAAa,CACXyB,CAAC,CACF,CAACqB,yBAAyB,GAAGvD,KAAK,CAACqC,iBAAiB,CACnD5B,aAAa,CAACyB,CAAC,CAAC,CAACsB,WAAW,CAACjB,EAC/B,CAAC;UACH;UAEA,MAAMkB,WAA0B,GAAG,IAAI/E,aAAa,CAAC,CAAC;UACtD+E,WAAW,CAACjC,CAAC,GACXd,gBAAgB,CAAC2C,aAAa,CAAC,CAACK,QAAQ,CAAClC,CAAC,GAC1Cd,gBAAgB,CAAC2C,aAAa,GAAG,CAAC,CAAC,CAACK,QAAQ,CAAClC,CAAC;UAChDiC,WAAW,CAAC9D,CAAC,GACXe,gBAAgB,CAAC2C,aAAa,CAAC,CAACK,QAAQ,CAAC/D,CAAC,GAC1Ce,gBAAgB,CAAC2C,aAAa,GAAG,CAAC,CAAC,CAACK,QAAQ,CAAC/D,CAAC;UAEhDU,WAAW,GAAGI,aAAa,CAACyB,CAAC,CAAC,CAACyB,QAAQ,CACrCF,WAAW,EACX/C,gBAAgB,EAChB2C,aAAa,EACb5C,aAAa,CAACyB,CAAC,CAAC,CAACS,OAAO,EACxB,IAAI,CAACM,QAAQ,CAACvD,OAChB,CAAC;UAED,MAAM6D,yBAAiC,GACrC9C,aAAa,CAACyB,CAAC,CAAC,CAACqB,yBAAyB;UAC5C,MAAMK,iBAA+B,GACnC,CAACC,YAAY,CAACC,SAAS,CAACC,KAAK,IAC7B,UAAU,IAAIF,YAAY,CAACC,SAAS,GAChCE,IAAI,CAACxE,KAAK,CACRwE,IAAI,CAACC,SAAS,CACZtD,cAAc,CAACuD,QAAQ,CAACX,yBAAyB,CACnD,CACF,CAAC,CAAC;UAAA,EACF5C,cAAc,CAACoD,KAAK,CAACR,yBAAyB,CAAC;UAErDY,0BAA0B,CACxBP,iBAAiB,EACjB/C,qBAAqB,CAAC0C,yBAAyB,CAAC,EAChD3C,qBAAqB,CAAC2C,yBAAyB,CAAC,EAChDlD,WAAW,EACXI,aAAa,CAACyB,CAAC,CACjB,CAAC;;UAED;UACA,KACE,IAAIkC,MAAc,GAAGb,yBAAyB,EAAEc,aAAa,GAAG,CAAC,EACjED,MAAM,GAAGzD,cAAc,CAAC2D,MAAM,EAC9BF,MAAM,EAAE,EAAEC,aAAa,EAAE,EACzB;YACA1D,cAAc,CAACyD,MAAM,CAAC,GAAGR,iBAAiB,CAACS,aAAa,CAAC;UAC3D;QACF;MACF;IACF;;IAEA;AACJ;AACA;AACA;IACWE,UAAUA,CAACC,OAAgB,EAAQ;MACxC,IAAI,CAACvB,QAAQ,GAAGuB,OAAO;IACzB;;IAEA;AACJ;AACA;AACA;IACWC,SAASA,CAAA,EAAY;MAC1B,OAAO,IAAI,CAACxB,QAAQ;IACtB;;IAEA;AACJ;AACA;IACWyB,WAAWA,CAAA,EAAG;MAAA,KA0RrBjF,WAAW;MAAoB;MAAA,KAC/BwD,QAAQ;MA1RN,IAAI,CAACxD,WAAW,GAAG,IAAI;;MAEvB;MACA,IAAI,CAACwD,QAAQ,GAAG,IAAI0B,OAAO,CAAC,CAAC;MAC7B,IAAI,CAAC1B,QAAQ,CAACvD,OAAO,CAACC,CAAC,GAAG,CAAC,GAAG;MAC9B,IAAI,CAACsD,QAAQ,CAACvD,OAAO,CAAC8B,CAAC,GAAG,CAAC;MAC3B,IAAI,CAACyB,QAAQ,CAACC,IAAI,CAAC1B,CAAC,GAAG,CAAC;MACxB,IAAI,CAACyB,QAAQ,CAACC,IAAI,CAACvD,CAAC,GAAG,CAAC;IAC1B;;IAEA;AACJ;AACA;IACWG,OAAOA,CAAA,EAAS;MACrB,IAAI,CAACL,WAAW,GAAG,KAAK,CAAC;MACzB,IAAI,CAACA,WAAW,GAAG,IAAI;IACzB;;IAEA;AACJ;AACA;AACA;AACA;IACWD,KAAKA,CAACoF,WAAwB,EAAEtF,IAAY,EAAQ;MACzD,IAAI,CAACG,WAAW,GAAG,IAAIvB,gBAAgB,CAAC,CAAC;MAEzC,IAAI2G,IAAuB,GAAG,IAAI7G,iBAAiB,CAAC4G,WAAW,EAAEtF,IAAI,CAAC;MAEtE,IAAI,CAACG,WAAW,CAACC,OAAO,GAAGmF,IAAI,CAACC,UAAU,CAAC,CAAC;MAC5C,IAAI,CAACrF,WAAW,CAACyD,IAAI,GAAG2B,IAAI,CAACE,OAAO,CAAC,CAAC;MACtC,IAAI,CAACtF,WAAW,CAAC6B,WAAW,GAAGuD,IAAI,CAACG,cAAc,CAAC,CAAC;MAEpD,IAAI,CAACvF,WAAW,CAACgC,QAAQ,CAACwD,UAAU,CAClC,IAAI,CAACxF,WAAW,CAAC6B,WAAW,EAC5BnD,mBAAmB,EACnB,IACF,CAAC;MACD,IAAI,CAACsB,WAAW,CAACkC,MAAM,CAACsD,UAAU,CAChCJ,IAAI,CAACK,kBAAkB,CAAC,CAAC,EACzB9G,kBAAkB,EAClB,IACF,CAAC;MACD,IAAI,CAACqB,WAAW,CAACqC,OAAO,CAACmD,UAAU,CACjCJ,IAAI,CAACM,mBAAmB,CAAC,CAAC,EAC1B9G,mBAAmB,EACnB,IACF,CAAC;MACD,IAAI,CAACoB,WAAW,CAACuC,SAAS,CAACiD,UAAU,CACnCJ,IAAI,CAACO,cAAc,CAAC,CAAC,EACrB9G,qBAAqB,EACrB,IACF,CAAC;MAED,IAAI+G,UAAU,GAAG,CAAC;QAChBC,WAAW,GAAG,CAAC;QACfjC,aAAa,GAAG,CAAC;MAEnB,KAAK,IAAInB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACzC,WAAW,CAACgC,QAAQ,CAAC8D,OAAO,CAAC,CAAC,EAAE,EAAErD,CAAC,EAAE;QAC5D,IAAI,CAACzC,WAAW,CAACgC,QAAQ,CAACC,EAAE,CAC1BQ,CACF,CAAC,CAACO,qBAAqB,CAAC+C,OAAO,GAAGX,IAAI,CAACY,oCAAoC,CACzEvD,CACF,CAAC;QACD,IAAI,CAACzC,WAAW,CAACgC,QAAQ,CAACC,EAAE,CAC1BQ,CACF,CAAC,CAACO,qBAAqB,CAACU,OAAO,GAAG0B,IAAI,CAACa,oCAAoC,CACzExD,CACF,CAAC;QACD,IAAI,CAACzC,WAAW,CAACgC,QAAQ,CAACC,EAAE,CAC1BQ,CACF,CAAC,CAACO,qBAAqB,CAACkD,OAAO,GAAGd,IAAI,CAACe,oCAAoC,CACzE1D,CACF,CAAC;QAED,IAAI,CAACzC,WAAW,CAACgC,QAAQ,CAACC,EAAE,CAC1BQ,CACF,CAAC,CAACQ,kBAAkB,CAAC8C,OAAO,GAAGX,IAAI,CAACgB,iCAAiC,CACnE3D,CACF,CAAC;QACD,IAAI,CAACzC,WAAW,CAACgC,QAAQ,CAACC,EAAE,CAC1BQ,CACF,CAAC,CAACQ,kBAAkB,CAACS,OAAO,GAAG0B,IAAI,CAACiB,iCAAiC,CACnE5D,CACF,CAAC;QACD,IAAI,CAACzC,WAAW,CAACgC,QAAQ,CAACC,EAAE,CAC1BQ,CACF,CAAC,CAACQ,kBAAkB,CAACiD,OAAO,GAAGd,IAAI,CAACkB,iCAAiC,CACnE7D,CACF,CAAC;;QAED;QACA,IAAI,CAACzC,WAAW,CAACgC,QAAQ,CAACC,EAAE,CAACQ,CAAC,CAAC,CAACC,UAAU,GAAG0C,IAAI,CAACmB,aAAa,CAAC9D,CAAC,CAAC;QAClE,IAAI,CAACzC,WAAW,CAACgC,QAAQ,CAACC,EAAE,CAACQ,CAAC,CAAC,CAACL,cAAc,GAAGwD,UAAU;QAE3D,KAAK,IAAIY,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACxG,WAAW,CAACgC,QAAQ,CAACC,EAAE,CAACQ,CAAC,CAAC,CAACC,UAAU,EAAE,EAAE8D,CAAC,EAAE;UACnE,IAAI,CAACxG,WAAW,CAACkC,MAAM,CAACD,EAAE,CAAC2D,UAAU,GAAGY,CAAC,CAAC,CAAC7D,oBAAoB,GAAG,CAAC,CAAC;UACpE,IAAI,CAAC3C,WAAW,CAACkC,MAAM,CAACD,EAAE,CACxB2D,UAAU,GAAGY,CACf,CAAC,CAAC9F,MAAM,GAAG0E,IAAI,CAACqB,cAAc,CAAChE,CAAC,EAAE+D,CAAC,CAAC;UACpC,IAAI,CAACxG,WAAW,CAACkC,MAAM,CAACD,EAAE,CACxB2D,UAAU,GAAGY,CACf,CAAC,CAACtD,OAAO,GAAGkC,IAAI,CAACsB,eAAe,CAACjE,CAAC,EAAE+D,CAAC,CAAC;UAEtC,IAAIpB,IAAI,CAACuB,YAAY,CAAClE,CAAC,EAAE+D,CAAC,CAAC,IAAIpH,eAAe,EAAE;YAC9C,IAAI,CAACY,WAAW,CAACkC,MAAM,CAACD,EAAE,CAAC2D,UAAU,GAAGY,CAAC,CAAC,CAACI,IAAI,GAC7C9H,mBAAmB,CAAC+H,qBAAqB;YAC3C,IAAI,CAAC7G,WAAW,CAACkC,MAAM,CAACD,EAAE,CACxB2D,UAAU,GAAGY,CACf,CAAC,CAACzD,2BAA2B,GAAG+D,gDAAgD;UAClF,CAAC,MAAM,IAAI1B,IAAI,CAACuB,YAAY,CAAClE,CAAC,EAAE+D,CAAC,CAAC,IAAInH,eAAe,EAAE;YACrD,IAAI,CAACW,WAAW,CAACkC,MAAM,CAACD,EAAE,CAAC2D,UAAU,GAAGY,CAAC,CAAC,CAACI,IAAI,GAC7C9H,mBAAmB,CAACiI,qBAAqB;YAC3C,IAAI,CAAC/G,WAAW,CAACkC,MAAM,CAACD,EAAE,CACxB2D,UAAU,GAAGY,CACf,CAAC,CAACzD,2BAA2B,GAAGiE,+CAA+C;UACjF,CAAC,MAAM,IAAI5B,IAAI,CAACuB,YAAY,CAAClE,CAAC,EAAE+D,CAAC,CAAC,IAAIlH,mBAAmB,EAAE;YACzD,IAAI,CAACU,WAAW,CAACkC,MAAM,CAACD,EAAE,CAAC2D,UAAU,GAAGY,CAAC,CAAC,CAACI,IAAI,GAC7C9H,mBAAmB,CAACmI,yBAAyB;YAC/C,IAAI,CAACjH,WAAW,CAACkC,MAAM,CAACD,EAAE,CACxB2D,UAAU,GAAGY,CACf,CAAC,CAACzD,2BAA2B,GAAGmE,yCAAyC;UAC3E;UAEA,IAAI,CAAClH,WAAW,CAACkC,MAAM,CAACD,EAAE,CAAC2D,UAAU,GAAGY,CAAC,CAAC,CAAC3D,MAAM,CAACsE,UAAU,GAC1DpI,uBAAuB,CAACqI,iCAAiC;UAC3D,IAAI,CAACpH,WAAW,CAACkC,MAAM,CAACD,EAAE,CACxB2D,UAAU,GAAGY,CACf,CAAC,CAAC3D,MAAM,CAACC,EAAE,GAAGsC,IAAI,CAACiC,gBAAgB,CAAC5E,CAAC,EAAE+D,CAAC,CAAC;QAC3C;QACAZ,UAAU,IAAI,IAAI,CAAC5F,WAAW,CAACgC,QAAQ,CAACC,EAAE,CAACQ,CAAC,CAAC,CAACC,UAAU;;QAExD;QACA,IAAI,CAAC1C,WAAW,CAACgC,QAAQ,CAACC,EAAE,CAACQ,CAAC,CAAC,CAACkB,WAAW,GAAGyB,IAAI,CAACkC,cAAc,CAAC7E,CAAC,CAAC;QACpE,IAAI,CAACzC,WAAW,CAACgC,QAAQ,CAACC,EAAE,CAACQ,CAAC,CAAC,CAACH,eAAe,GAAGuD,WAAW;QAE7D,KAAK,IAAIW,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACxG,WAAW,CAACgC,QAAQ,CAACC,EAAE,CAACQ,CAAC,CAAC,CAACkB,WAAW,EAAE,EAAE6C,CAAC,EAAE;UACpE,IAAI,CAACxG,WAAW,CAACqC,OAAO,CAACJ,EAAE,CACzB4D,WAAW,GAAGW,CAChB,CAAC,CAAC1C,yBAAyB,GAAG,CAAC,CAAC;UAChC,IAAI,CAAC9D,WAAW,CAACqC,OAAO,CAACJ,EAAE,CACzB4D,WAAW,GAAGW,CAChB,CAAC,CAAC3C,WAAW,GAAGuB,IAAI,CAACmC,oBAAoB,CAAC9E,CAAC,EAAE+D,CAAC,CAAC;UAC/C,IAAI,CAACxG,WAAW,CAACqC,OAAO,CAACJ,EAAE,CACzB4D,WAAW,GAAGW,CAChB,CAAC,CAACgB,UAAU,GAAGpC,IAAI,CAACqC,mBAAmB,CAAChF,CAAC,EAAE+D,CAAC,CAAC;UAC7C,IAAI,CAACxG,WAAW,CAACqC,OAAO,CAACJ,EAAE,CACzB4D,WAAW,GAAGW,CAChB,CAAC,CAAC9F,MAAM,GAAG0E,IAAI,CAACsC,eAAe,CAACjF,CAAC,EAAE+D,CAAC,CAAC;UACrC,IAAI,CAACxG,WAAW,CAACqC,OAAO,CAACJ,EAAE,CAAC4D,WAAW,GAAGW,CAAC,CAAC,CAACzC,WAAW,CAACoD,UAAU,GACjEpI,uBAAuB,CAACqI,iCAAiC;UAE3D,IAAI,CAACpH,WAAW,CAACqC,OAAO,CAACJ,EAAE,CACzB4D,WAAW,GAAGW,CAChB,CAAC,CAACzC,WAAW,CAACjB,EAAE,GAAGsC,IAAI,CAACuC,sBAAsB,CAAClF,CAAC,EAAE+D,CAAC,CAAC;UAEpD,IAAIpB,IAAI,CAACwC,aAAa,CAACnF,CAAC,EAAE+D,CAAC,CAAC,IAAIpH,eAAe,EAAE;YAC/C,IAAI,CAACY,WAAW,CAACqC,OAAO,CAACJ,EAAE,CAAC4D,WAAW,GAAGW,CAAC,CAAC,CAACI,IAAI,GAC/C9H,mBAAmB,CAAC+H,qBAAqB;YAC3C,IAAI,CAAC7G,WAAW,CAACqC,OAAO,CAACJ,EAAE,CACzB4D,WAAW,GAAGW,CAChB,CAAC,CAACtC,QAAQ,GAAG2D,qBAAqB;YAClC,IAAI,CAAC7H,WAAW,CAACqC,OAAO,CAACJ,EAAE,CACzB4D,WAAW,GAAGW,CAChB,CAAC,CAACsB,QAAQ,GAAGC,0BAA0B;UACzC,CAAC,MAAM,IAAI3C,IAAI,CAACwC,aAAa,CAACnF,CAAC,EAAE+D,CAAC,CAAC,IAAInH,eAAe,EAAE;YACtD,IAAI,CAACW,WAAW,CAACqC,OAAO,CAACJ,EAAE,CAAC4D,WAAW,GAAGW,CAAC,CAAC,CAACI,IAAI,GAC/C9H,mBAAmB,CAACiI,qBAAqB;YAC3C,IAAI,CAAC/G,WAAW,CAACqC,OAAO,CAACJ,EAAE,CACzB4D,WAAW,GAAGW,CAChB,CAAC,CAACtC,QAAQ,GAAG8D,qBAAqB;YAClC,IAAI,CAAChI,WAAW,CAACqC,OAAO,CAACJ,EAAE,CACzB4D,WAAW,GAAGW,CAChB,CAAC,CAACsB,QAAQ,GAAGG,0BAA0B;UACzC,CAAC,MAAM,IAAI7C,IAAI,CAACwC,aAAa,CAACnF,CAAC,EAAE+D,CAAC,CAAC,IAAIlH,mBAAmB,EAAE;YAC1D,IAAI,CAACU,WAAW,CAACqC,OAAO,CAACJ,EAAE,CAAC4D,WAAW,GAAGW,CAAC,CAAC,CAACI,IAAI,GAC/C9H,mBAAmB,CAACmI,yBAAyB;YAC/C,IAAI,CAACjH,WAAW,CAACqC,OAAO,CAACJ,EAAE,CACzB4D,WAAW,GAAGW,CAChB,CAAC,CAACtC,QAAQ,GAAGgE,cAAc;YAC3B,IAAI,CAAClI,WAAW,CAACqC,OAAO,CAACJ,EAAE,CACzB4D,WAAW,GAAGW,CAChB,CAAC,CAACsB,QAAQ,GAAGK,mBAAmB;UAClC;UAEA,IAAI,CAACnI,WAAW,CAACqC,OAAO,CAACJ,EAAE,CACzB4D,WAAW,GAAGW,CAChB,CAAC,CAACtD,OAAO,GAAGkC,IAAI,CAACgD,gBAAgB,CAAC3F,CAAC,EAAE+D,CAAC,CAAC;QACzC;QACAX,WAAW,IAAI,IAAI,CAAC7F,WAAW,CAACgC,QAAQ,CAACC,EAAE,CAACQ,CAAC,CAAC,CAACkB,WAAW;;QAE1D;QACA,IAAI,CAAC3D,WAAW,CAACgC,QAAQ,CAACC,EAAE,CAACQ,CAAC,CAAC,CAACc,aAAa,GAAG6B,IAAI,CAACiD,gBAAgB,CACnE5F,CACF,CAAC;QACD,IAAI,CAACzC,WAAW,CAACgC,QAAQ,CAACC,EAAE,CAACQ,CAAC,CAAC,CAACD,iBAAiB,GAAGoB,aAAa;QAEjE,KACE,IAAI4C,CAAC,GAAG,CAAC,EACTA,CAAC,GAAG,IAAI,CAACxG,WAAW,CAACgC,QAAQ,CAACC,EAAE,CAACQ,CAAC,CAAC,CAACc,aAAa,EACjD,EAAEiD,CAAC,EACH;UACA,IAAI,CAACxG,WAAW,CAACuC,SAAS,CAACN,EAAE,CAC3B2B,aAAa,GAAG4C,CAClB,CAAC,CAAC8B,QAAQ,GAAGlD,IAAI,CAACmD,mBAAmB,CAAC9F,CAAC,EAAE+D,CAAC,CAAC;UAC3C,IAAI,CAACxG,WAAW,CAACuC,SAAS,CAACN,EAAE,CAC3B2B,aAAa,GAAG4C,CAClB,CAAC,CAACgC,KAAK,GAAGpD,IAAI,CAACqD,gBAAgB,CAAChG,CAAC,EAAE+D,CAAC,CAAC;UACrC,IAAI,CAACxG,WAAW,CAACuC,SAAS,CAACN,EAAE,CAC3B2B,aAAa,GAAG4C,CAClB,CAAC,CAACkC,YAAY,GAAGtD,IAAI,CAACuD,uBAAuB,CAAClG,CAAC,EAAE+D,CAAC,CAAC;UACnD,IAAI,CAACxG,WAAW,CAACuC,SAAS,CAACN,EAAE,CAC3B2B,aAAa,GAAG4C,CAClB,CAAC,CAACoC,MAAM,GAAGxD,IAAI,CAACyD,iBAAiB,CAACpG,CAAC,EAAE+D,CAAC,CAAC;UACvC,IAAI,CAACxG,WAAW,CAACuC,SAAS,CAACN,EAAE,CAC3B2B,aAAa,GAAG4C,CAClB,CAAC,CAACvC,QAAQ,GAAGmB,IAAI,CAAC0D,mBAAmB,CAACrG,CAAC,EAAE+D,CAAC,CAAC;QAC7C;QAEA5C,aAAa,IAAI,IAAI,CAAC5D,WAAW,CAACgC,QAAQ,CAACC,EAAE,CAACQ,CAAC,CAAC,CAACc,aAAa;MAChE;MAEA,IAAI,CAACwF,UAAU,CAAC,CAAC;MAEjB3D,IAAI,CAAC/E,OAAO,CAAC,CAAC;MACd+E,IAAI,GAAG,KAAK,CAAC;MACbA,IAAI,GAAG,IAAI;IACb;;IAEA;AACJ;AACA;IACW2D,UAAUA,CAAA,EAAS;MACxB,IAAIC,MAA+B;MACnC,IAAIlI,cAAmC;MACvC,IAAI8H,MAAqB;MAEzB,KACE,IAAIhH,YAAY,GAAG,CAAC,EACpBA,YAAY,GAAG,IAAI,CAAC5B,WAAW,CAAC6B,WAAW,EAC3C,EAAED,YAAY,EACd;QACAd,cAAc,GAAG,IAAI,CAACd,WAAW,CAACgC,QAAQ,CAACC,EAAE,CAACL,YAAY,CAAC;QAC3DoH,MAAM,GAAG,IAAI,CAAChJ,WAAW,CAACuC,SAAS,CAACJ,GAAG,CACrCrB,cAAc,CAAC0B,iBACjB,CAAC;;QAED;QACAwG,MAAM,CAAC,CAAC,CAAC,CAACC,eAAe,GAAG,IAAIhK,aAAa,CAAC,GAAG,EAAE,GAAG,CAAC;QACvD+J,MAAM,CAAC,CAAC,CAAC,CAACE,YAAY,GAAG,IAAIjK,aAAa,CACxC+J,MAAM,CAAC,CAAC,CAAC,CAACC,eAAe,CAAClH,CAAC,EAC3BiH,MAAM,CAAC,CAAC,CAAC,CAACC,eAAe,CAAC/I,CAC5B,CAAC;QACD8I,MAAM,CAAC,CAAC,CAAC,CAACG,WAAW,GAAG,IAAIlK,aAAa,CAAC,GAAG,EAAE,CAAC,GAAG,CAAC;QACpD+J,MAAM,CAAC,CAAC,CAAC,CAACG,WAAW,CAACjJ,CAAC,IAAI,CAAC,GAAG;QAC/B8I,MAAM,CAAC,CAAC,CAAC,CAACI,QAAQ,GAAG,IAAInK,aAAa,CAAC,GAAG,EAAE,GAAG,CAAC;QAChD+J,MAAM,CAAC,CAAC,CAAC,CAACK,KAAK,GAAG,IAAIpK,aAAa,CAAC,GAAG,EAAE,GAAG,CAAC;;QAE7C;QACA,KAAK,IAAIwD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG3B,cAAc,CAACyC,aAAa,EAAE,EAAEd,CAAC,EAAE;UACrDmG,MAAM,GAAG,IAAI3J,aAAa,CAAC,GAAG,EAAE,GAAG,CAAC;UACpC2J,MAAM,CAAC1I,CAAC,GAAG8I,MAAM,CAACvG,CAAC,CAAC,CAACmG,MAAM;UAC3BI,MAAM,CAACvG,CAAC,CAAC,CAACwG,eAAe,GAAG,IAAIhK,aAAa,CAC3C+J,MAAM,CAACvG,CAAC,GAAG,CAAC,CAAC,CAACwG,eAAe,CAAClH,CAAC,GAAG6G,MAAM,CAAC7G,CAAC,EAC1CiH,MAAM,CAACvG,CAAC,GAAG,CAAC,CAAC,CAACwG,eAAe,CAAC/I,CAAC,GAAG0I,MAAM,CAAC1I,CAC3C,CAAC;UACD8I,MAAM,CAACvG,CAAC,CAAC,CAACwB,QAAQ,GAAG,IAAIhF,aAAa,CACpC+J,MAAM,CAACvG,CAAC,CAAC,CAACwG,eAAe,CAAClH,CAAC,EAC3BiH,MAAM,CAACvG,CAAC,CAAC,CAACwG,eAAe,CAAC/I,CAC5B,CAAC;UACD8I,MAAM,CAACvG,CAAC,CAAC,CAACyG,YAAY,GAAG,IAAIjK,aAAa,CACxC+J,MAAM,CAACvG,CAAC,CAAC,CAACwG,eAAe,CAAClH,CAAC,EAC3BiH,MAAM,CAACvG,CAAC,CAAC,CAACwG,eAAe,CAAC/I,CAC5B,CAAC;UACD8I,MAAM,CAACvG,CAAC,CAAC,CAAC0G,WAAW,GAAG,IAAIlK,aAAa,CAAC,GAAG,EAAE,CAAC,GAAG,CAAC;UACpD+J,MAAM,CAACvG,CAAC,CAAC,CAAC0G,WAAW,CAACjJ,CAAC,IAAI,CAAC,GAAG;UAC/B8I,MAAM,CAACvG,CAAC,CAAC,CAAC2G,QAAQ,GAAG,IAAInK,aAAa,CAAC,GAAG,EAAE,GAAG,CAAC;UAChD+J,MAAM,CAACvG,CAAC,CAAC,CAAC4G,KAAK,GAAG,IAAIpK,aAAa,CAAC,GAAG,EAAE,GAAG,CAAC;QAC/C;MACF;IACF;;IAGmB;EACrB;EAACE,sBAAA,CAAAO,aAAA,GAAAA,aAAA;EAKM,MAAMwF,OAAO,CAAC;IACnBD,WAAWA,CAAA,EAAG;MAAA,KAKdhF,OAAO;MAAiB;MAAA,KACxBwD,IAAI;MALF,IAAI,CAACxD,OAAO,GAAG,IAAIhB,aAAa,CAAC,CAAC,EAAE,CAAC,CAAC;MACtC,IAAI,CAACwE,IAAI,GAAG,IAAIxE,aAAa,CAAC,CAAC,EAAE,CAAC,CAAC;IACrC;;IAGqB;EACvB;EAACE,sBAAA,CAAA+F,OAAA,GAAAA,OAAA;EAED;AACF;AACA;AACA;AACA;AACA;AACA;EACE,SAASoE,IAAIA,CAACC,KAAa,EAAU;IACnC,IAAIzJ,GAAG,GAAG,CAAC;IAEX,IAAIyJ,KAAK,GAAG,GAAG,EAAE;MACfzJ,GAAG,GAAG,CAAC;IACT,CAAC,MAAM,IAAIyJ,KAAK,GAAG,GAAG,EAAE;MACtBzJ,GAAG,GAAG,CAAC,CAAC;IACV;IAEA,OAAOA,GAAG;EACZ;EAEA,SAASgH,gDAAgDA,CACvD0C,iBAAgC,EAChCC,WAA8B,EAC9BF,KAAa,EACbnI,qBAA6B,EAC7BD,qBAA6B,EAC7BE,qBAA6B,EAC7B2B,qBAAiD,EACjDC,kBAA8C,EAC9CyG,UAAmB,EACnBhJ,MAAc,EACR;IACN8I,iBAAiB,CAACzH,CAAC,IACjB4H,uBAAuB,CACrBJ,KAAK,EACLnI,qBAAqB,EACrBD,qBAAqB,EACrBE,qBAAqB,EACrB2B,qBAAqB,CAAC+C,OAAO,EAC7B/C,qBAAqB,CAACU,OAAO,EAC7BV,qBAAqB,CAACkD,OAAO,EAC7BwD,UACF,CAAC,GAAGhJ,MAAM;EACd;EAEA,SAASsG,+CAA+CA,CACtDwC,iBAAgC,EAChCC,WAA8B,EAC9BF,KAAa,EACbnI,qBAA6B,EAC7BD,qBAA6B,EAC7BE,qBAA6B,EAC7B2B,qBAAiD,EACjDC,kBAA8C,EAC9CyG,UAAmB,EACnBhJ,MAAc,EACR;IACN8I,iBAAiB,CAACtJ,CAAC,IACjByJ,uBAAuB,CACrBJ,KAAK,EACLnI,qBAAqB,EACrBD,qBAAqB,EACrBE,qBAAqB,EACrB2B,qBAAqB,CAAC+C,OAAO,EAC7B/C,qBAAqB,CAACU,OAAO,EAC7BV,qBAAqB,CAACkD,OAAO,EAC7BwD,UACF,CAAC,GAAGhJ,MAAM;EACd;EAEA,SAASwG,yCAAyCA,CAChDsC,iBAAgC,EAChCC,WAA8B,EAC9BF,KAAa,EACbnI,qBAA6B,EAC7BD,qBAA6B,EAC7BE,qBAA6B,EAC7BuI,sBAAkD,EAClD3G,kBAA8C,EAC9CyG,UAAmB,EACnBhJ,MAAc,EACR;IACN+I,WAAW,CAAC3H,KAAK,IACf6H,uBAAuB,CACrBJ,KAAK,EACLnI,qBAAqB,EACrBD,qBAAqB,EACrBE,qBAAqB,EACrB4B,kBAAkB,CAAC8C,OAAO,EAC1B9C,kBAAkB,CAACS,OAAO,EAC1BT,kBAAkB,CAACiD,OAAO,EAC1BwD,UACF,CAAC,GAAGhJ,MAAM;EACd;EAEA,SAASmH,qBAAqBA,CAC5B7D,WAA0B,EAC1BzB,SAAkC,EAClCqB,aAAqB,EACrB8F,UAAmB,EACnBG,aAA4B,EACpB;IACR,IAAIjJ,WAAmB,GAAGoD,WAAW,CAACjC,CAAC;IAEvC,IAAI2H,UAAU,EAAE;MACd9I,WAAW,IAAI,CAAC,GAAG;IACrB;IAEA,OAAOA,WAAW;EACpB;EAEA,SAASoH,qBAAqBA,CAC5BhE,WAA0B,EAC1BzB,SAAkC,EAClCqB,aAAqB,EACrB8F,UAAmB,EACnBG,aAA4B,EACpB;IACR,IAAIjJ,WAAmB,GAAGoD,WAAW,CAAC9D,CAAC;IAEvC,IAAIwJ,UAAU,EAAE;MACd9I,WAAW,IAAI,CAAC,GAAG;IACrB;IACA,OAAOA,WAAW;EACpB;EAEA,SAASsH,cAAcA,CACrBlE,WAA0B,EAC1BzB,SAAkC,EAClCqB,aAAqB,EACrB8F,UAAmB,EACnBG,aAA4B,EACpB;IACR,IAAIjJ,WAAmB;IAEvB,IAAIgD,aAAa,IAAI,CAAC,EAAE;MACtBiG,aAAa,GAAGtH,SAAS,CAACqB,aAAa,GAAG,CAAC,CAAC,CAACK,QAAQ,CAAC6F,SAAS,CAC7DvH,SAAS,CAACqB,aAAa,GAAG,CAAC,CAAC,CAACK,QAC/B,CAAC;IACH,CAAC,MAAM;MACL4F,aAAa,GAAGA,aAAa,CAACE,gBAAgB,CAAC,CAAC,GAAG,CAAC;IACtD;IAEAnJ,WAAW,GAAGpC,UAAU,CAACwL,iBAAiB,CAACH,aAAa,EAAE7F,WAAW,CAAC;IAEtE,IAAI0F,UAAU,EAAE;MACd9I,WAAW,IAAI,CAAC,GAAG;IACrB;IAEA,OAAOA,WAAW;EACpB;EAEA,SAASqJ,aAAaA,CAACC,GAAW,EAAEC,GAAW,EAAU;IACvD,MAAMC,QAAgB,GAAG5L,UAAU,CAAC2L,GAAG,CAACD,GAAG,EAAEC,GAAG,CAAC;IACjD,MAAME,QAAgB,GAAG7L,UAAU,CAAC0L,GAAG,CAACA,GAAG,EAAEC,GAAG,CAAC;IAEjD,OAAO3L,UAAU,CAAC8L,GAAG,CAACF,QAAQ,GAAGC,QAAQ,CAAC;EAC5C;EAEA,SAASE,eAAeA,CAACL,GAAW,EAAEC,GAAW,EAAU;IACzD,MAAME,QAAgB,GAAG7L,UAAU,CAAC0L,GAAG,CAACA,GAAG,EAAEC,GAAG,CAAC;IACjD,OAAOE,QAAQ,GAAGJ,aAAa,CAACC,GAAG,EAAEC,GAAG,CAAC,GAAG,GAAG;EACjD;EAEA,SAASpC,0BAA0BA,CACjCyC,gBAA+B,EAC/BhD,UAAkB,EACV;IACR,OAAOjD,IAAI,CAACxE,KAAK,CAACwE,IAAI,CAACC,SAAS,CAACgG,gBAAgB,CAACzI,CAAC,CAAC,CAAC;EACvD;EAEA,SAASkG,0BAA0BA,CACjCuC,gBAA+B,EAC/BhD,UAAkB,EACV;IACR,OAAOjD,IAAI,CAACxE,KAAK,CAACwE,IAAI,CAACC,SAAS,CAACgG,gBAAgB,CAACtK,CAAC,CAAC,CAAC;EACvD;EAEA,SAASiI,mBAAmBA,CAC1BqC,gBAA+B,EAC/BhD,UAAkB,EACV;IACR,OAAOjD,IAAI,CAACxE,KAAK,CAACwE,IAAI,CAACC,SAAS,CAACgD,UAAU,CAAC,CAAC;EAC/C;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,SAASlE,eAAeA,CACtB0F,MAA+B,EAC/ByB,WAAmB,EACnB5J,gBAA+B,EAC/BJ,UAAkB,EAClBiK,aAA4B,EAC5BC,cAAsB,EACtBnK,gBAAwB,EACxBoK,aAAqB,EACrB;IACA,IAAIC,WAAmB;IACvB,IAAIrC,KAAa;IACjB,IAAIsC,MAAc;IAClB,IAAIC,cAA6B;IACjC,IAAIC,SAAwB,GAAG,IAAI/L,aAAa,CAAC,GAAG,EAAE,GAAG,CAAC;IAC1D,IAAImK,QAAuB,GAAG,IAAInK,aAAa,CAAC,GAAG,EAAE,GAAG,CAAC;IACzD,IAAIoK,KAAoB,GAAG,IAAIpK,aAAa,CAAC,GAAG,EAAE,GAAG,CAAC;IACtD,IAAIgM,YAA2B,GAAG,IAAIhM,aAAa,CAAC,GAAG,EAAE,GAAG,CAAC;IAE7D+J,MAAM,CAAC,CAAC,CAAC,CAAC/E,QAAQ,GAAG,IAAIhF,aAAa,CACpC4B,gBAAgB,CAACkB,CAAC,EAClBlB,gBAAgB,CAACX,CACnB,CAAC;IAED2K,WAAW,GAAGrM,UAAU,CAAC2E,eAAe,CAAC1C,UAAU,CAAC;IACpDsK,cAAc,GAAGvM,UAAU,CAAC0M,iBAAiB,CAACL,WAAW,CAAC;IAC1DE,cAAc,CAACI,SAAS,CAAC,CAAC;IAE1B,KAAK,IAAI1I,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGgI,WAAW,EAAE,EAAEhI,CAAC,EAAE;MACpCuG,MAAM,CAACvG,CAAC,CAAC,CAAC4G,KAAK,GAAG0B,cAAc,CAC7BhB,gBAAgB,CAACf,MAAM,CAACvG,CAAC,CAAC,CAACiG,YAAY,CAAC,CACxC0C,GAAG,CAACV,aAAa,CAAC;MAErB1B,MAAM,CAACvG,CAAC,CAAC,CAACyG,YAAY,GAAG,IAAIjK,aAAa,CACxC+J,MAAM,CAACvG,CAAC,CAAC,CAACwB,QAAQ,CAAClC,CAAC,EACpBiH,MAAM,CAACvG,CAAC,CAAC,CAACwB,QAAQ,CAAC/D,CACrB,CAAC;MAEDsI,KAAK,GAAGQ,MAAM,CAACvG,CAAC,CAAC,CAAC+F,KAAK,GAAGhI,gBAAgB,GAAG,IAAI;MAEjDwK,SAAS,GAAGhC,MAAM,CAACvG,CAAC,CAAC,CAACwB,QAAQ,CAAC6F,SAAS,CAACd,MAAM,CAACvG,CAAC,GAAG,CAAC,CAAC,CAACwB,QAAQ,CAAC;MAEhE6G,MAAM,GACJtM,UAAU,CAACwL,iBAAiB,CAAChB,MAAM,CAACvG,CAAC,CAAC,CAAC0G,WAAW,EAAE4B,cAAc,CAAC,GACnEH,aAAa;MAEfI,SAAS,CAACjJ,CAAC,GACTvD,UAAU,CAAC4E,GAAG,CAAC0H,MAAM,CAAC,GAAGE,SAAS,CAACjJ,CAAC,GACpCiJ,SAAS,CAAC9K,CAAC,GAAG1B,UAAU,CAAC6E,GAAG,CAACyH,MAAM,CAAC;MACtCE,SAAS,CAAC9K,CAAC,GACT1B,UAAU,CAAC6E,GAAG,CAACyH,MAAM,CAAC,GAAGE,SAAS,CAACjJ,CAAC,GACpCiJ,SAAS,CAAC9K,CAAC,GAAG1B,UAAU,CAAC4E,GAAG,CAAC0H,MAAM,CAAC;MAEtC9B,MAAM,CAACvG,CAAC,CAAC,CAACwB,QAAQ,GAAG+E,MAAM,CAACvG,CAAC,GAAG,CAAC,CAAC,CAACwB,QAAQ,CAACmH,GAAG,CAACJ,SAAS,CAAC;MAE1D5B,QAAQ,GAAGJ,MAAM,CAACvG,CAAC,CAAC,CAAC2G,QAAQ,CAACW,gBAAgB,CAACvB,KAAK,CAAC;MACrDa,KAAK,GAAGL,MAAM,CAACvG,CAAC,CAAC,CAAC4G,KAAK,CAACU,gBAAgB,CAACvB,KAAK,CAAC,CAACuB,gBAAgB,CAACvB,KAAK,CAAC;MAEvEQ,MAAM,CAACvG,CAAC,CAAC,CAACwB,QAAQ,GAAG+E,MAAM,CAACvG,CAAC,CAAC,CAACwB,QAAQ,CAACmH,GAAG,CAAChC,QAAQ,CAAC,CAACgC,GAAG,CAAC/B,KAAK,CAAC;MAEhE4B,YAAY,GAAGjC,MAAM,CAACvG,CAAC,CAAC,CAACwB,QAAQ,CAAC6F,SAAS,CAACd,MAAM,CAACvG,CAAC,GAAG,CAAC,CAAC,CAACwB,QAAQ,CAAC;MACnEgH,YAAY,CAACE,SAAS,CAAC,CAAC;MAExBnC,MAAM,CAACvG,CAAC,CAAC,CAACwB,QAAQ,GAAG+E,MAAM,CAACvG,CAAC,GAAG,CAAC,CAAC,CAACwB,QAAQ,CAACmH,GAAG,CAC7CH,YAAY,CAAClB,gBAAgB,CAACf,MAAM,CAACvG,CAAC,CAAC,CAACmG,MAAM,CAChD,CAAC;MAED,IAAIpK,UAAU,CAAC8L,GAAG,CAACtB,MAAM,CAACvG,CAAC,CAAC,CAACwB,QAAQ,CAAClC,CAAC,CAAC,GAAG4I,cAAc,EAAE;QACzD3B,MAAM,CAACvG,CAAC,CAAC,CAACwB,QAAQ,CAAClC,CAAC,GAAG,GAAG;MAC5B;MAEA,IAAIyG,KAAK,IAAI,GAAG,EAAE;QAChBQ,MAAM,CAACvG,CAAC,CAAC,CAAC2G,QAAQ,GAAGJ,MAAM,CAACvG,CAAC,CAAC,CAACwB,QAAQ,CAAC6F,SAAS,CAC/Cd,MAAM,CAACvG,CAAC,CAAC,CAACyG,YACZ,CAAC;QACDF,MAAM,CAACvG,CAAC,CAAC,CAAC2G,QAAQ,GAAGJ,MAAM,CAACvG,CAAC,CAAC,CAAC2G,QAAQ,CAACiC,gBAAgB,CAAC7C,KAAK,CAAC;QAC/DQ,MAAM,CAACvG,CAAC,CAAC,CAAC2G,QAAQ,GAAGJ,MAAM,CAACvG,CAAC,CAAC,CAAC2G,QAAQ,CAACW,gBAAgB,CACtDf,MAAM,CAACvG,CAAC,CAAC,CAAC6F,QACZ,CAAC;MACH;MAEAU,MAAM,CAACvG,CAAC,CAAC,CAAC4G,KAAK,GAAG,IAAIpK,aAAa,CAAC,GAAG,EAAE,GAAG,CAAC;MAC7C+J,MAAM,CAACvG,CAAC,CAAC,CAAC0G,WAAW,GAAG,IAAIlK,aAAa,CACvC8L,cAAc,CAAChJ,CAAC,EAChBgJ,cAAc,CAAC7K,CACjB,CAAC;IACH;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACE,SAASwE,0BAA0BA,CACjCxD,cAA4B,EAC5BoK,qBAA6B,EAC7BC,qBAA6B,EAC7BvH,WAAmB,EACnBwH,MAA2B,EACrB;IACN,IAAIC,WAAmB;IACvB,IAAIlC,KAAa;IACjB,IAAI7I,MAAc;IAElB+K,WAAW,GAAGD,MAAM,CAAC1D,QAAQ,CAAC0D,MAAM,CAAChB,gBAAgB,EAAEgB,MAAM,CAAChE,UAAU,CAAC;IAEzE+B,KAAK,GAAGvF,WAAW,GAAGyH,WAAW;IAEjC,IAAIlC,KAAK,GAAG+B,qBAAqB,EAAE;MACjC,IAAI/B,KAAK,GAAGiC,MAAM,CAACE,iBAAiB,EAAE;QACpCF,MAAM,CAACE,iBAAiB,GAAGnC,KAAK;MAClC;MAEAA,KAAK,GAAG+B,qBAAqB;IAC/B,CAAC,MAAM,IAAI/B,KAAK,GAAGgC,qBAAqB,EAAE;MACxC,IAAIhC,KAAK,GAAGiC,MAAM,CAACG,oBAAoB,EAAE;QACvCH,MAAM,CAACG,oBAAoB,GAAGpC,KAAK;MACrC;MAEAA,KAAK,GAAGgC,qBAAqB;IAC/B;IAEA7K,MAAM,GAAG8K,MAAM,CAAC9K,MAAM,GAAGlB,aAAa;IAEtC,IAAIkB,MAAM,IAAI,GAAG,EAAE;MACjBQ,cAAc,CAAC,CAAC,CAAC,GAAGqI,KAAK;IAC3B,CAAC,MAAM;MACLA,KAAK,GAAGrI,cAAc,CAAC,CAAC,CAAC,IAAI,GAAG,GAAGR,MAAM,CAAC,GAAG6I,KAAK,GAAG7I,MAAM;MAC3DQ,cAAc,CAAC,CAAC,CAAC,GAAGqI,KAAK;IAC3B;EACF;EAEA,SAASI,uBAAuBA,CAC9BJ,KAAa,EACbqC,gBAAwB,EACxBC,gBAAwB,EACxBC,gBAAwB,EACxBC,iBAAyB,EACzBC,iBAAyB,EACzBC,iBAAyB,EACzBvC,UAAmB,EACnB;IACA,IAAIwC,MAAM,GAAG,GAAG;IAEhB,MAAM9B,QAAgB,GAAG5L,UAAU,CAAC2L,GAAG,CAAC0B,gBAAgB,EAAED,gBAAgB,CAAC;IAE3E,IAAIxB,QAAQ,GAAGb,KAAK,EAAE;MACpBA,KAAK,GAAGa,QAAQ;IAClB;IAEA,MAAMC,QAAgB,GAAG7L,UAAU,CAAC0L,GAAG,CAAC2B,gBAAgB,EAAED,gBAAgB,CAAC;IAE3E,IAAIvB,QAAQ,GAAGd,KAAK,EAAE;MACpBA,KAAK,GAAGc,QAAQ;IAClB;IAEA,MAAM8B,YAAoB,GAAG3N,UAAU,CAAC0L,GAAG,CACzC6B,iBAAiB,EACjBC,iBACF,CAAC;IACD,MAAMI,YAAoB,GAAG5N,UAAU,CAAC2L,GAAG,CACzC4B,iBAAiB,EACjBC,iBACF,CAAC;IACD,MAAMK,eAAuB,GAAGJ,iBAAiB;IAEjD,MAAMK,WAAmB,GAAG/B,eAAe,CAACF,QAAQ,EAAED,QAAQ,CAAC;IAC/D,MAAMmC,UAAkB,GAAGhD,KAAK,GAAG+C,WAAW;IAE9C,QAAQhD,IAAI,CAACiD,UAAU,CAAC;MACtB,KAAK,CAAC;QAAE;UACN,MAAMC,OAAe,GAAGJ,YAAY,GAAGC,eAAe;UACtD,MAAMI,OAAe,GAAGrC,QAAQ,GAAGkC,WAAW;UAE9C,IAAIG,OAAO,IAAI,GAAG,EAAE;YAClBP,MAAM,GAAGK,UAAU,IAAIC,OAAO,GAAGC,OAAO,CAAC;YACzCP,MAAM,IAAIG,eAAe;UAC3B;UAEA;QACF;MACA,KAAK,CAAC,CAAC;QAAE;UACP,MAAMG,OAAe,GAAGL,YAAY,GAAGE,eAAe;UACtD,MAAMI,OAAe,GAAGpC,QAAQ,GAAGiC,WAAW;UAE9C,IAAIG,OAAO,IAAI,GAAG,EAAE;YAClBP,MAAM,GAAGK,UAAU,IAAIC,OAAO,GAAGC,OAAO,CAAC;YACzCP,MAAM,IAAIG,eAAe;UAC3B;UAEA;QACF;MACA,KAAK,CAAC;QAAE;UACNH,MAAM,GAAGG,eAAe;UAExB;QACF;MACA;QAAS;UACP;QACF;IACF;IAEA,OAAO3C,UAAU,GAAGwC,MAAM,GAAGA,MAAM,GAAG,CAAC,GAAG;EAC5C;AAAC,GA15BcjO,qBAAqB,KAArBA,qBAAqB"},"metadata":{},"sourceType":"module","externalDependencies":[]}