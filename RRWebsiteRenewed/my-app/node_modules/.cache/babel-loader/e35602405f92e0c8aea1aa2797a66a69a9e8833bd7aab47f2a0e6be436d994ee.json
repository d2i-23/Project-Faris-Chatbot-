{"ast":null,"code":"/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\n\nimport { CubismMotionQueueEntry } from './cubismmotionqueueentry';\nimport { csmVector } from '../type/csmvector';\n/**\n * モーション再生の管理\n *\n * モーション再生の管理用クラス。CubismMotionモーションなどACubismMotionのサブクラスを再生するために使用する。\n *\n * @note 再生中に別のモーションが StartMotion()された場合は、新しいモーションに滑らかに変化し旧モーションは中断する。\n *       表情用モーション、体用モーションなどを分けてモーション化した場合など、\n *       複数のモーションを同時に再生させる場合は、複数のCubismMotionQueueManagerインスタンスを使用する。\n */\nexport class CubismMotionQueueManager {\n  /**\n   * コンストラクタ\n   */\n  constructor() {\n    this._userTimeSeconds = void 0;\n    // デルタ時間の積算値[秒]\n    this._motions = void 0;\n    // モーション\n    this._eventCallBack = void 0;\n    // コールバック関数\n    this._eventCustomData = void 0;\n    this._userTimeSeconds = 0.0;\n    this._eventCallBack = null;\n    this._eventCustomData = null;\n    this._motions = new csmVector();\n  }\n\n  /**\n   * デストラクタ\n   */\n  release() {\n    for (let i = 0; i < this._motions.getSize(); ++i) {\n      if (this._motions.at(i)) {\n        this._motions.at(i).release();\n        this._motions.set(i, null);\n      }\n    }\n    this._motions = null;\n  }\n\n  /**\n   * 指定したモーションの開始\n   *\n   * 指定したモーションを開始する。同じタイプのモーションが既にある場合は、既存のモーションに終了フラグを立て、フェードアウトを開始させる。\n   *\n   * @param   motion          開始するモーション\n   * @param   autoDelete      再生が終了したモーションのインスタンスを削除するなら true\n   * @param   userTimeSeconds デルタ時間の積算値[秒]\n   * @return                      開始したモーションの識別番号を返す。個別のモーションが終了したか否かを判定するIsFinished()の引数で使用する。開始できない時は「-1」\n   */\n  startMotion(motion, autoDelete, userTimeSeconds) {\n    if (motion == null) {\n      return InvalidMotionQueueEntryHandleValue;\n    }\n    let motionQueueEntry = null;\n\n    // 既にモーションがあれば終了フラグを立てる\n    for (let i = 0; i < this._motions.getSize(); ++i) {\n      motionQueueEntry = this._motions.at(i);\n      if (motionQueueEntry == null) {\n        continue;\n      }\n      motionQueueEntry.setFadeOut(motionQueueEntry._motion.getFadeOutTime()); // フェードアウト設定\n    }\n\n    motionQueueEntry = new CubismMotionQueueEntry(); // 終了時に破棄する\n    motionQueueEntry._autoDelete = autoDelete;\n    motionQueueEntry._motion = motion;\n    this._motions.pushBack(motionQueueEntry);\n    return motionQueueEntry._motionQueueEntryHandle;\n  }\n\n  /**\n   * 全てのモーションの終了の確認\n   * @return true 全て終了している\n   * @return false 終了していない\n   */\n  isFinished() {\n    // ------- 処理を行う -------\n    // 既にモーションがあれば終了フラグを立てる\n\n    for (let ite = this._motions.begin(); ite.notEqual(this._motions.end());) {\n      let motionQueueEntry = ite.ptr();\n      if (motionQueueEntry == null) {\n        ite = this._motions.erase(ite); // 削除\n        continue;\n      }\n      const motion = motionQueueEntry._motion;\n      if (motion == null) {\n        motionQueueEntry.release();\n        motionQueueEntry = null;\n        ite = this._motions.erase(ite); // 削除\n        continue;\n      }\n\n      // ----- 終了済みの処理があれば削除する ------\n      if (!motionQueueEntry.isFinished()) {\n        return false;\n      } else {\n        ite.preIncrement();\n      }\n    }\n    return true;\n  }\n\n  /**\n   * 指定したモーションの終了の確認\n   * @param motionQueueEntryNumber モーションの識別番号\n   * @return true 全て終了している\n   * @return false 終了していない\n   */\n  isFinishedByHandle(motionQueueEntryNumber) {\n    for (let ite = this._motions.begin(); ite.notEqual(this._motions.end()); ite.increment()) {\n      const motionQueueEntry = ite.ptr();\n      if (motionQueueEntry == null) {\n        continue;\n      }\n      if (motionQueueEntry._motionQueueEntryHandle == motionQueueEntryNumber && !motionQueueEntry.isFinished()) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * 全てのモーションを停止する\n   */\n  stopAllMotions() {\n    // ------- 処理を行う -------\n    // 既にモーションがあれば終了フラグを立てる\n\n    for (let ite = this._motions.begin(); ite.notEqual(this._motions.end());) {\n      let motionQueueEntry = ite.ptr();\n      if (motionQueueEntry == null) {\n        ite = this._motions.erase(ite);\n        continue;\n      }\n\n      // ----- 終了済みの処理があれば削除する ------\n      motionQueueEntry.release();\n      motionQueueEntry = null;\n      ite = this._motions.erase(ite); // 削除\n    }\n  }\n\n  /**\n       * 指定したCubismMotionQueueEntryの取得\n         * @param   motionQueueEntryNumber  モーションの識別番号\n        * @return  指定したCubismMotionQueueEntry\n        * @return  null   見つからなかった\n        */\n  getCubismMotionQueueEntry(motionQueueEntryNumber) {\n    //------- 処理を行う -------\n    for (let ite = this._motions.begin(); ite.notEqual(this._motions.end()); ite.preIncrement()) {\n      const motionQueueEntry = ite.ptr();\n      if (motionQueueEntry == null) {\n        continue;\n      }\n      if (motionQueueEntry._motionQueueEntryHandle == motionQueueEntryNumber) {\n        return motionQueueEntry;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * イベントを受け取るCallbackの登録\n   *\n   * @param callback コールバック関数\n   * @param customData コールバックに返されるデータ\n   */\n  setEventCallback(callback) {\n    let customData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    this._eventCallBack = callback;\n    this._eventCustomData = customData;\n  }\n\n  /**\n   * モーションを更新して、モデルにパラメータ値を反映する。\n   *\n   * @param   model   対象のモデル\n   * @param   userTimeSeconds   デルタ時間の積算値[秒]\n   * @return  true    モデルへパラメータ値の反映あり\n   * @return  false   モデルへパラメータ値の反映なし(モーションの変化なし)\n   */\n  doUpdateMotion(model, userTimeSeconds) {\n    let updated = false;\n\n    // ------- 処理を行う --------\n    // 既にモーションがあれば終了フラグを立てる\n\n    for (let ite = this._motions.begin(); ite.notEqual(this._motions.end());) {\n      let motionQueueEntry = ite.ptr();\n      if (motionQueueEntry == null) {\n        ite = this._motions.erase(ite); // 削除\n        continue;\n      }\n      const motion = motionQueueEntry._motion;\n      if (motion == null) {\n        motionQueueEntry.release();\n        motionQueueEntry = null;\n        ite = this._motions.erase(ite); // 削除\n\n        continue;\n      }\n\n      // ------ 値を反映する ------\n      motion.updateParameters(model, motionQueueEntry, userTimeSeconds);\n      updated = true;\n\n      // ------ ユーザトリガーイベントを検査する ----\n      const firedList = motion.getFiredEvent(motionQueueEntry.getLastCheckEventSeconds() - motionQueueEntry.getStartTime(), userTimeSeconds - motionQueueEntry.getStartTime());\n      for (let i = 0; i < firedList.getSize(); ++i) {\n        this._eventCallBack(this, firedList.at(i), this._eventCustomData);\n      }\n      motionQueueEntry.setLastCheckEventSeconds(userTimeSeconds);\n\n      // ------ 終了済みの処理があれば削除する ------\n      if (motionQueueEntry.isFinished()) {\n        motionQueueEntry.release();\n        motionQueueEntry = null;\n        ite = this._motions.erase(ite); // 削除\n      } else {\n        if (motionQueueEntry.isTriggeredFadeOut()) {\n          motionQueueEntry.startFadeOut(motionQueueEntry.getFadeOutSeconds(), userTimeSeconds);\n        }\n        ite.preIncrement();\n      }\n    }\n    return updated;\n  }\n\n  // コールバックに戻されるデータ\n}\n\n/**\n * イベントのコールバック関数を定義\n *\n * イベントのコールバックに登録できる関数の型情報\n * @param caller        発火したイベントを再生させたCubismMotionQueueManager\n * @param eventValue    発火したイベントの文字列データ\n * @param customData   コールバックに返される登録時に指定されたデータ\n */\n\n/**\n * モーションの識別番号\n *\n * モーションの識別番号の定義\n */\n\nexport const InvalidMotionQueueEntryHandleValue = -1;\n\n// Namespace definition for compatibility.\nimport * as $ from './cubismmotionqueuemanager';\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport let Live2DCubismFramework;\n(function (_Live2DCubismFramework) {\n  const CubismMotionQueueManager = _Live2DCubismFramework.CubismMotionQueueManager = $.CubismMotionQueueManager;\n  const InvalidMotionQueueEntryHandleValue = _Live2DCubismFramework.InvalidMotionQueueEntryHandleValue = $.InvalidMotionQueueEntryHandleValue;\n})(Live2DCubismFramework || (Live2DCubismFramework = {}));","map":{"version":3,"names":["CubismMotionQueueEntry","csmVector","CubismMotionQueueManager","constructor","_userTimeSeconds","_motions","_eventCallBack","_eventCustomData","release","i","getSize","at","set","startMotion","motion","autoDelete","userTimeSeconds","InvalidMotionQueueEntryHandleValue","motionQueueEntry","setFadeOut","_motion","getFadeOutTime","_autoDelete","pushBack","_motionQueueEntryHandle","isFinished","ite","begin","notEqual","end","ptr","erase","preIncrement","isFinishedByHandle","motionQueueEntryNumber","increment","stopAllMotions","getCubismMotionQueueEntry","setEventCallback","callback","customData","arguments","length","undefined","doUpdateMotion","model","updated","updateParameters","firedList","getFiredEvent","getLastCheckEventSeconds","getStartTime","setLastCheckEventSeconds","isTriggeredFadeOut","startFadeOut","getFadeOutSeconds","$","Live2DCubismFramework","_Live2DCubismFramework"],"sources":["C:/Users/cleyc/OneDrive/Documents/RR/RRWebsiteRenewed/my-app/src/Samples/TypeScript/Demo/Framework/src/motion/cubismmotionqueuemanager.ts"],"sourcesContent":["/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\n\nimport { ACubismMotion } from './acubismmotion';\nimport { CubismMotionQueueEntry } from './cubismmotionqueueentry';\nimport { csmVector, iterator } from '../type/csmvector';\nimport { CubismModel } from '../model/cubismmodel';\nimport { csmString } from '../type/csmstring';\n\n/**\n * モーション再生の管理\n *\n * モーション再生の管理用クラス。CubismMotionモーションなどACubismMotionのサブクラスを再生するために使用する。\n *\n * @note 再生中に別のモーションが StartMotion()された場合は、新しいモーションに滑らかに変化し旧モーションは中断する。\n *       表情用モーション、体用モーションなどを分けてモーション化した場合など、\n *       複数のモーションを同時に再生させる場合は、複数のCubismMotionQueueManagerインスタンスを使用する。\n */\nexport class CubismMotionQueueManager {\n  /**\n   * コンストラクタ\n   */\n  public constructor() {\n    this._userTimeSeconds = 0.0;\n    this._eventCallBack = null;\n    this._eventCustomData = null;\n    this._motions = new csmVector<CubismMotionQueueEntry>();\n  }\n\n  /**\n   * デストラクタ\n   */\n  public release(): void {\n    for (let i = 0; i < this._motions.getSize(); ++i) {\n      if (this._motions.at(i)) {\n        this._motions.at(i).release();\n        this._motions.set(i, null);\n      }\n    }\n\n    this._motions = null;\n  }\n\n  /**\n   * 指定したモーションの開始\n   *\n   * 指定したモーションを開始する。同じタイプのモーションが既にある場合は、既存のモーションに終了フラグを立て、フェードアウトを開始させる。\n   *\n   * @param   motion          開始するモーション\n   * @param   autoDelete      再生が終了したモーションのインスタンスを削除するなら true\n   * @param   userTimeSeconds デルタ時間の積算値[秒]\n   * @return                      開始したモーションの識別番号を返す。個別のモーションが終了したか否かを判定するIsFinished()の引数で使用する。開始できない時は「-1」\n   */\n  public startMotion(\n    motion: ACubismMotion,\n    autoDelete: boolean,\n    userTimeSeconds: number\n  ): CubismMotionQueueEntryHandle {\n    if (motion == null) {\n      return InvalidMotionQueueEntryHandleValue;\n    }\n\n    let motionQueueEntry: CubismMotionQueueEntry = null;\n\n    // 既にモーションがあれば終了フラグを立てる\n    for (let i = 0; i < this._motions.getSize(); ++i) {\n      motionQueueEntry = this._motions.at(i);\n      if (motionQueueEntry == null) {\n        continue;\n      }\n\n      motionQueueEntry.setFadeOut(motionQueueEntry._motion.getFadeOutTime()); // フェードアウト設定\n    }\n\n    motionQueueEntry = new CubismMotionQueueEntry(); // 終了時に破棄する\n    motionQueueEntry._autoDelete = autoDelete;\n    motionQueueEntry._motion = motion;\n\n    this._motions.pushBack(motionQueueEntry);\n\n    return motionQueueEntry._motionQueueEntryHandle;\n  }\n\n  /**\n   * 全てのモーションの終了の確認\n   * @return true 全て終了している\n   * @return false 終了していない\n   */\n  public isFinished(): boolean {\n    // ------- 処理を行う -------\n    // 既にモーションがあれば終了フラグを立てる\n\n    for (\n      let ite: iterator<CubismMotionQueueEntry> = this._motions.begin();\n      ite.notEqual(this._motions.end());\n\n    ) {\n      let motionQueueEntry: CubismMotionQueueEntry = ite.ptr();\n\n      if (motionQueueEntry == null) {\n        ite = this._motions.erase(ite); // 削除\n        continue;\n      }\n\n      const motion: ACubismMotion = motionQueueEntry._motion;\n\n      if (motion == null) {\n        motionQueueEntry.release();\n        motionQueueEntry = null;\n        ite = this._motions.erase(ite); // 削除\n        continue;\n      }\n\n      // ----- 終了済みの処理があれば削除する ------\n      if (!motionQueueEntry.isFinished()) {\n        return false;\n      } else {\n        ite.preIncrement();\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * 指定したモーションの終了の確認\n   * @param motionQueueEntryNumber モーションの識別番号\n   * @return true 全て終了している\n   * @return false 終了していない\n   */\n  public isFinishedByHandle(\n    motionQueueEntryNumber: CubismMotionQueueEntryHandle\n  ): boolean {\n    for (\n      let ite: iterator<CubismMotionQueueEntry> = this._motions.begin();\n      ite.notEqual(this._motions.end());\n      ite.increment()\n    ) {\n      const motionQueueEntry: CubismMotionQueueEntry = ite.ptr();\n\n      if (motionQueueEntry == null) {\n        continue;\n      }\n\n      if (\n        motionQueueEntry._motionQueueEntryHandle == motionQueueEntryNumber &&\n        !motionQueueEntry.isFinished()\n      ) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * 全てのモーションを停止する\n   */\n  public stopAllMotions(): void {\n    // ------- 処理を行う -------\n    // 既にモーションがあれば終了フラグを立てる\n\n    for (\n      let ite: iterator<CubismMotionQueueEntry> = this._motions.begin();\n      ite.notEqual(this._motions.end());\n\n    ) {\n      let motionQueueEntry: CubismMotionQueueEntry = ite.ptr();\n\n      if (motionQueueEntry == null) {\n        ite = this._motions.erase(ite);\n\n        continue;\n      }\n\n      // ----- 終了済みの処理があれば削除する ------\n      motionQueueEntry.release();\n      motionQueueEntry = null;\n      ite = this._motions.erase(ite); // 削除\n    }\n  }\n\n  /**\n       * 指定したCubismMotionQueueEntryの取得\n\n        * @param   motionQueueEntryNumber  モーションの識別番号\n        * @return  指定したCubismMotionQueueEntry\n        * @return  null   見つからなかった\n        */\n  public getCubismMotionQueueEntry(\n    motionQueueEntryNumber: any\n  ): CubismMotionQueueEntry {\n    //------- 処理を行う -------\n    for (\n      let ite: iterator<CubismMotionQueueEntry> = this._motions.begin();\n      ite.notEqual(this._motions.end());\n      ite.preIncrement()\n    ) {\n      const motionQueueEntry: CubismMotionQueueEntry = ite.ptr();\n\n      if (motionQueueEntry == null) {\n        continue;\n      }\n\n      if (motionQueueEntry._motionQueueEntryHandle == motionQueueEntryNumber) {\n        return motionQueueEntry;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * イベントを受け取るCallbackの登録\n   *\n   * @param callback コールバック関数\n   * @param customData コールバックに返されるデータ\n   */\n  public setEventCallback(\n    callback: CubismMotionEventFunction,\n    customData: any = null\n  ): void {\n    this._eventCallBack = callback;\n    this._eventCustomData = customData;\n  }\n\n  /**\n   * モーションを更新して、モデルにパラメータ値を反映する。\n   *\n   * @param   model   対象のモデル\n   * @param   userTimeSeconds   デルタ時間の積算値[秒]\n   * @return  true    モデルへパラメータ値の反映あり\n   * @return  false   モデルへパラメータ値の反映なし(モーションの変化なし)\n   */\n  public doUpdateMotion(model: CubismModel, userTimeSeconds: number): boolean {\n    let updated = false;\n\n    // ------- 処理を行う --------\n    // 既にモーションがあれば終了フラグを立てる\n\n    for (\n      let ite: iterator<CubismMotionQueueEntry> = this._motions.begin();\n      ite.notEqual(this._motions.end());\n\n    ) {\n      let motionQueueEntry: CubismMotionQueueEntry = ite.ptr();\n\n      if (motionQueueEntry == null) {\n        ite = this._motions.erase(ite); // 削除\n        continue;\n      }\n\n      const motion: ACubismMotion = motionQueueEntry._motion;\n\n      if (motion == null) {\n        motionQueueEntry.release();\n        motionQueueEntry = null;\n        ite = this._motions.erase(ite); // 削除\n\n        continue;\n      }\n\n      // ------ 値を反映する ------\n      motion.updateParameters(model, motionQueueEntry, userTimeSeconds);\n      updated = true;\n\n      // ------ ユーザトリガーイベントを検査する ----\n      const firedList: csmVector<csmString> = motion.getFiredEvent(\n        motionQueueEntry.getLastCheckEventSeconds() -\n          motionQueueEntry.getStartTime(),\n        userTimeSeconds - motionQueueEntry.getStartTime()\n      );\n\n      for (let i = 0; i < firedList.getSize(); ++i) {\n        this._eventCallBack(this, firedList.at(i), this._eventCustomData);\n      }\n\n      motionQueueEntry.setLastCheckEventSeconds(userTimeSeconds);\n\n      // ------ 終了済みの処理があれば削除する ------\n      if (motionQueueEntry.isFinished()) {\n        motionQueueEntry.release();\n        motionQueueEntry = null;\n        ite = this._motions.erase(ite); // 削除\n      } else {\n        if (motionQueueEntry.isTriggeredFadeOut()) {\n          motionQueueEntry.startFadeOut(\n            motionQueueEntry.getFadeOutSeconds(),\n            userTimeSeconds\n          );\n        }\n        ite.preIncrement();\n      }\n    }\n\n    return updated;\n  }\n  _userTimeSeconds: number; // デルタ時間の積算値[秒]\n\n  _motions: csmVector<CubismMotionQueueEntry>; // モーション\n  _eventCallBack: CubismMotionEventFunction; // コールバック関数\n  _eventCustomData: any; // コールバックに戻されるデータ\n}\n\n/**\n * イベントのコールバック関数を定義\n *\n * イベントのコールバックに登録できる関数の型情報\n * @param caller        発火したイベントを再生させたCubismMotionQueueManager\n * @param eventValue    発火したイベントの文字列データ\n * @param customData   コールバックに返される登録時に指定されたデータ\n */\nexport interface CubismMotionEventFunction {\n  (\n    caller: CubismMotionQueueManager,\n    eventValue: csmString,\n    customData: any\n  ): void;\n}\n\n/**\n * モーションの識別番号\n *\n * モーションの識別番号の定義\n */\nexport declare type CubismMotionQueueEntryHandle = any;\nexport const InvalidMotionQueueEntryHandleValue: CubismMotionQueueEntryHandle =\n  -1;\n\n// Namespace definition for compatibility.\nimport * as $ from './cubismmotionqueuemanager';\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport namespace Live2DCubismFramework {\n  export const CubismMotionQueueManager = $.CubismMotionQueueManager;\n  export type CubismMotionQueueManager = $.CubismMotionQueueManager;\n  export const InvalidMotionQueueEntryHandleValue =\n    $.InvalidMotionQueueEntryHandleValue;\n  export type CubismMotionQueueEntryHandle = $.CubismMotionQueueEntryHandle;\n  export type CubismMotionEventFunction = $.CubismMotionEventFunction;\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;;AAGA,SAASA,sBAAsB,QAAQ,0BAA0B;AACjE,SAASC,SAAS,QAAkB,mBAAmB;AAIvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,wBAAwB,CAAC;EACpC;AACF;AACA;EACSC,WAAWA,CAAA,EAAG;IAAA,KAkRrBC,gBAAgB;IAAU;IAAA,KAE1BC,QAAQ;IAAqC;IAAA,KAC7CC,cAAc;IAA6B;IAAA,KAC3CC,gBAAgB;IArRd,IAAI,CAACH,gBAAgB,GAAG,GAAG;IAC3B,IAAI,CAACE,cAAc,GAAG,IAAI;IAC1B,IAAI,CAACC,gBAAgB,GAAG,IAAI;IAC5B,IAAI,CAACF,QAAQ,GAAG,IAAIJ,SAAS,CAAyB,CAAC;EACzD;;EAEA;AACF;AACA;EACSO,OAAOA,CAAA,EAAS;IACrB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACJ,QAAQ,CAACK,OAAO,CAAC,CAAC,EAAE,EAAED,CAAC,EAAE;MAChD,IAAI,IAAI,CAACJ,QAAQ,CAACM,EAAE,CAACF,CAAC,CAAC,EAAE;QACvB,IAAI,CAACJ,QAAQ,CAACM,EAAE,CAACF,CAAC,CAAC,CAACD,OAAO,CAAC,CAAC;QAC7B,IAAI,CAACH,QAAQ,CAACO,GAAG,CAACH,CAAC,EAAE,IAAI,CAAC;MAC5B;IACF;IAEA,IAAI,CAACJ,QAAQ,GAAG,IAAI;EACtB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACSQ,WAAWA,CAChBC,MAAqB,EACrBC,UAAmB,EACnBC,eAAuB,EACO;IAC9B,IAAIF,MAAM,IAAI,IAAI,EAAE;MAClB,OAAOG,kCAAkC;IAC3C;IAEA,IAAIC,gBAAwC,GAAG,IAAI;;IAEnD;IACA,KAAK,IAAIT,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACJ,QAAQ,CAACK,OAAO,CAAC,CAAC,EAAE,EAAED,CAAC,EAAE;MAChDS,gBAAgB,GAAG,IAAI,CAACb,QAAQ,CAACM,EAAE,CAACF,CAAC,CAAC;MACtC,IAAIS,gBAAgB,IAAI,IAAI,EAAE;QAC5B;MACF;MAEAA,gBAAgB,CAACC,UAAU,CAACD,gBAAgB,CAACE,OAAO,CAACC,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC;IAC1E;;IAEAH,gBAAgB,GAAG,IAAIlB,sBAAsB,CAAC,CAAC,CAAC,CAAC;IACjDkB,gBAAgB,CAACI,WAAW,GAAGP,UAAU;IACzCG,gBAAgB,CAACE,OAAO,GAAGN,MAAM;IAEjC,IAAI,CAACT,QAAQ,CAACkB,QAAQ,CAACL,gBAAgB,CAAC;IAExC,OAAOA,gBAAgB,CAACM,uBAAuB;EACjD;;EAEA;AACF;AACA;AACA;AACA;EACSC,UAAUA,CAAA,EAAY;IAC3B;IACA;;IAEA,KACE,IAAIC,GAAqC,GAAG,IAAI,CAACrB,QAAQ,CAACsB,KAAK,CAAC,CAAC,EACjED,GAAG,CAACE,QAAQ,CAAC,IAAI,CAACvB,QAAQ,CAACwB,GAAG,CAAC,CAAC,CAAC,GAEjC;MACA,IAAIX,gBAAwC,GAAGQ,GAAG,CAACI,GAAG,CAAC,CAAC;MAExD,IAAIZ,gBAAgB,IAAI,IAAI,EAAE;QAC5BQ,GAAG,GAAG,IAAI,CAACrB,QAAQ,CAAC0B,KAAK,CAACL,GAAG,CAAC,CAAC,CAAC;QAChC;MACF;MAEA,MAAMZ,MAAqB,GAAGI,gBAAgB,CAACE,OAAO;MAEtD,IAAIN,MAAM,IAAI,IAAI,EAAE;QAClBI,gBAAgB,CAACV,OAAO,CAAC,CAAC;QAC1BU,gBAAgB,GAAG,IAAI;QACvBQ,GAAG,GAAG,IAAI,CAACrB,QAAQ,CAAC0B,KAAK,CAACL,GAAG,CAAC,CAAC,CAAC;QAChC;MACF;;MAEA;MACA,IAAI,CAACR,gBAAgB,CAACO,UAAU,CAAC,CAAC,EAAE;QAClC,OAAO,KAAK;MACd,CAAC,MAAM;QACLC,GAAG,CAACM,YAAY,CAAC,CAAC;MACpB;IACF;IAEA,OAAO,IAAI;EACb;;EAEA;AACF;AACA;AACA;AACA;AACA;EACSC,kBAAkBA,CACvBC,sBAAoD,EAC3C;IACT,KACE,IAAIR,GAAqC,GAAG,IAAI,CAACrB,QAAQ,CAACsB,KAAK,CAAC,CAAC,EACjED,GAAG,CAACE,QAAQ,CAAC,IAAI,CAACvB,QAAQ,CAACwB,GAAG,CAAC,CAAC,CAAC,EACjCH,GAAG,CAACS,SAAS,CAAC,CAAC,EACf;MACA,MAAMjB,gBAAwC,GAAGQ,GAAG,CAACI,GAAG,CAAC,CAAC;MAE1D,IAAIZ,gBAAgB,IAAI,IAAI,EAAE;QAC5B;MACF;MAEA,IACEA,gBAAgB,CAACM,uBAAuB,IAAIU,sBAAsB,IAClE,CAAChB,gBAAgB,CAACO,UAAU,CAAC,CAAC,EAC9B;QACA,OAAO,KAAK;MACd;IACF;IACA,OAAO,IAAI;EACb;;EAEA;AACF;AACA;EACSW,cAAcA,CAAA,EAAS;IAC5B;IACA;;IAEA,KACE,IAAIV,GAAqC,GAAG,IAAI,CAACrB,QAAQ,CAACsB,KAAK,CAAC,CAAC,EACjED,GAAG,CAACE,QAAQ,CAAC,IAAI,CAACvB,QAAQ,CAACwB,GAAG,CAAC,CAAC,CAAC,GAEjC;MACA,IAAIX,gBAAwC,GAAGQ,GAAG,CAACI,GAAG,CAAC,CAAC;MAExD,IAAIZ,gBAAgB,IAAI,IAAI,EAAE;QAC5BQ,GAAG,GAAG,IAAI,CAACrB,QAAQ,CAAC0B,KAAK,CAACL,GAAG,CAAC;QAE9B;MACF;;MAEA;MACAR,gBAAgB,CAACV,OAAO,CAAC,CAAC;MAC1BU,gBAAgB,GAAG,IAAI;MACvBQ,GAAG,GAAG,IAAI,CAACrB,QAAQ,CAAC0B,KAAK,CAACL,GAAG,CAAC,CAAC,CAAC;IAClC;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;EAESW,yBAAyBA,CAC9BH,sBAA2B,EACH;IACxB;IACA,KACE,IAAIR,GAAqC,GAAG,IAAI,CAACrB,QAAQ,CAACsB,KAAK,CAAC,CAAC,EACjED,GAAG,CAACE,QAAQ,CAAC,IAAI,CAACvB,QAAQ,CAACwB,GAAG,CAAC,CAAC,CAAC,EACjCH,GAAG,CAACM,YAAY,CAAC,CAAC,EAClB;MACA,MAAMd,gBAAwC,GAAGQ,GAAG,CAACI,GAAG,CAAC,CAAC;MAE1D,IAAIZ,gBAAgB,IAAI,IAAI,EAAE;QAC5B;MACF;MAEA,IAAIA,gBAAgB,CAACM,uBAAuB,IAAIU,sBAAsB,EAAE;QACtE,OAAOhB,gBAAgB;MACzB;IACF;IAEA,OAAO,IAAI;EACb;;EAEA;AACF;AACA;AACA;AACA;AACA;EACSoB,gBAAgBA,CACrBC,QAAmC,EAE7B;IAAA,IADNC,UAAe,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,IAAI;IAEtB,IAAI,CAACnC,cAAc,GAAGiC,QAAQ;IAC9B,IAAI,CAAChC,gBAAgB,GAAGiC,UAAU;EACpC;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACSI,cAAcA,CAACC,KAAkB,EAAE7B,eAAuB,EAAW;IAC1E,IAAI8B,OAAO,GAAG,KAAK;;IAEnB;IACA;;IAEA,KACE,IAAIpB,GAAqC,GAAG,IAAI,CAACrB,QAAQ,CAACsB,KAAK,CAAC,CAAC,EACjED,GAAG,CAACE,QAAQ,CAAC,IAAI,CAACvB,QAAQ,CAACwB,GAAG,CAAC,CAAC,CAAC,GAEjC;MACA,IAAIX,gBAAwC,GAAGQ,GAAG,CAACI,GAAG,CAAC,CAAC;MAExD,IAAIZ,gBAAgB,IAAI,IAAI,EAAE;QAC5BQ,GAAG,GAAG,IAAI,CAACrB,QAAQ,CAAC0B,KAAK,CAACL,GAAG,CAAC,CAAC,CAAC;QAChC;MACF;MAEA,MAAMZ,MAAqB,GAAGI,gBAAgB,CAACE,OAAO;MAEtD,IAAIN,MAAM,IAAI,IAAI,EAAE;QAClBI,gBAAgB,CAACV,OAAO,CAAC,CAAC;QAC1BU,gBAAgB,GAAG,IAAI;QACvBQ,GAAG,GAAG,IAAI,CAACrB,QAAQ,CAAC0B,KAAK,CAACL,GAAG,CAAC,CAAC,CAAC;;QAEhC;MACF;;MAEA;MACAZ,MAAM,CAACiC,gBAAgB,CAACF,KAAK,EAAE3B,gBAAgB,EAAEF,eAAe,CAAC;MACjE8B,OAAO,GAAG,IAAI;;MAEd;MACA,MAAME,SAA+B,GAAGlC,MAAM,CAACmC,aAAa,CAC1D/B,gBAAgB,CAACgC,wBAAwB,CAAC,CAAC,GACzChC,gBAAgB,CAACiC,YAAY,CAAC,CAAC,EACjCnC,eAAe,GAAGE,gBAAgB,CAACiC,YAAY,CAAC,CAClD,CAAC;MAED,KAAK,IAAI1C,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGuC,SAAS,CAACtC,OAAO,CAAC,CAAC,EAAE,EAAED,CAAC,EAAE;QAC5C,IAAI,CAACH,cAAc,CAAC,IAAI,EAAE0C,SAAS,CAACrC,EAAE,CAACF,CAAC,CAAC,EAAE,IAAI,CAACF,gBAAgB,CAAC;MACnE;MAEAW,gBAAgB,CAACkC,wBAAwB,CAACpC,eAAe,CAAC;;MAE1D;MACA,IAAIE,gBAAgB,CAACO,UAAU,CAAC,CAAC,EAAE;QACjCP,gBAAgB,CAACV,OAAO,CAAC,CAAC;QAC1BU,gBAAgB,GAAG,IAAI;QACvBQ,GAAG,GAAG,IAAI,CAACrB,QAAQ,CAAC0B,KAAK,CAACL,GAAG,CAAC,CAAC,CAAC;MAClC,CAAC,MAAM;QACL,IAAIR,gBAAgB,CAACmC,kBAAkB,CAAC,CAAC,EAAE;UACzCnC,gBAAgB,CAACoC,YAAY,CAC3BpC,gBAAgB,CAACqC,iBAAiB,CAAC,CAAC,EACpCvC,eACF,CAAC;QACH;QACAU,GAAG,CAACM,YAAY,CAAC,CAAC;MACpB;IACF;IAEA,OAAOc,OAAO;EAChB;;EAKuB;AACzB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AASA;AACA;AACA;AACA;AACA;;AAEA,OAAO,MAAM7B,kCAAgE,GAC3E,CAAC,CAAC;;AAEJ;AACA,OAAO,KAAKuC,CAAC,MAAM,4BAA4B;AAC/C;AACA,WAAAC,qBAAA;AAOC,WAAAC,sBAAA;EANQ,MAAMxD,wBAAwB,GAAAwD,sBAAA,CAAAxD,wBAAA,GAAGsD,CAAC,CAACtD,wBAAwB;EAE3D,MAAMe,kCAAkC,GAAAyC,sBAAA,CAAAzC,kCAAA,GAC7CuC,CAAC,CAACvC,kCAAkC;AAAC,GAJxBwC,qBAAqB,KAArBA,qBAAqB"},"metadata":{},"sourceType":"module","externalDependencies":[]}