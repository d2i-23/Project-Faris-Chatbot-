{"ast":null,"code":"/**\r\n * Copyright(c) Live2D Inc. All rights reserved.\r\n *\r\n * Use of this source code is governed by the Live2D Open Software license\r\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\r\n */\n\nimport { Live2DCubismFramework as csmstring } from '../type/csmstring';\nimport { Live2DCubismFramework as csmmap } from '../type/csmmap';\nimport { Live2DCubismFramework as csmvector } from '../type/csmvector';\nimport { CubismLogInfo } from './cubismdebug';\nimport { strtod } from '../live2dcubismframework';\nvar csmVector = csmvector.csmVector;\nvar csmVector_iterator = csmvector.iterator;\nvar csmMap = csmmap.csmMap;\nvar csmMap_iterator = csmmap.iterator;\nvar csmString = csmstring.csmString;\nexport let Live2DCubismFramework;\n(function (_Live2DCubismFramework) {\n  // StaticInitializeNotForClientCall()で初期化する\n  const CSM_JSON_ERROR_TYPE_MISMATCH = 'Error: type mismatch';\n  const CSM_JSON_ERROR_INDEX_OF_BOUNDS = 'Error: index out of bounds';\n\n  /**\r\n   * パースしたJSONエレメントの要素の基底クラス。\r\n   */\n  class Value {\n    /**\r\n     * コンストラクタ\r\n     */\n    constructor() {\n      this._stringBuffer = void 0;\n    }\n\n    /**\r\n     * 要素を文字列型で返す(csmString型)\r\n     */\n\n    /**\r\n     * 要素を文字列型で返す(string)\r\n     */\n    getRawString(defaultValue, indent) {\n      return this.getString(defaultValue, indent);\n    }\n\n    /**\r\n     * 要素を数値型で返す(number)\r\n     */\n    toInt() {\n      let defaultValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      return defaultValue;\n    }\n\n    /**\r\n     * 要素を数値型で返す(number)\r\n     */\n    toFloat() {\n      let defaultValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      return defaultValue;\n    }\n\n    /**\r\n     * 要素を真偽値で返す(boolean)\r\n     */\n    toBoolean() {\n      let defaultValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      return defaultValue;\n    }\n\n    /**\r\n     * サイズを返す\r\n     */\n    getSize() {\n      return 0;\n    }\n\n    /**\r\n     * 要素を配列で返す(Value[])\r\n     */\n    getArray() {\n      let defaultValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      return defaultValue;\n    }\n\n    /**\r\n     * 要素をコンテナで返す(array)\r\n     */\n    getVector(defaultValue) {\n      return defaultValue;\n    }\n\n    /**\r\n     * 要素をマップで返す(csmMap<csmString, Value>)\r\n     */\n    getMap(defaultValue) {\n      return defaultValue;\n    }\n\n    /**\r\n     * 添字演算子[index]\r\n     */\n    getValueByIndex(index) {\n      return Value.errorValue.setErrorNotForClientCall(CSM_JSON_ERROR_TYPE_MISMATCH);\n    }\n\n    /**\r\n     * 添字演算子[string | csmString]\r\n     */\n    getValueByString(s) {\n      return Value.nullValue.setErrorNotForClientCall(CSM_JSON_ERROR_TYPE_MISMATCH);\n    }\n\n    /**\r\n     * マップのキー一覧をコンテナで返す\r\n     *\r\n     * @return マップのキーの一覧\r\n     */\n    getKeys() {\n      return Value.s_dummyKeys;\n    }\n\n    /**\r\n     * Valueの種類がエラー値ならtrue\r\n     */\n    isError() {\n      return false;\n    }\n\n    /**\r\n     * Valueの種類がnullならtrue\r\n     */\n    isNull() {\n      return false;\n    }\n\n    /**\r\n     * Valueの種類が真偽値ならtrue\r\n     */\n    isBool() {\n      return false;\n    }\n\n    /**\r\n     * Valueの種類が数値型ならtrue\r\n     */\n    isFloat() {\n      return false;\n    }\n\n    /**\r\n     * Valueの種類が文字列ならtrue\r\n     */\n    isString() {\n      return false;\n    }\n\n    /**\r\n     * Valueの種類が配列ならtrue\r\n     */\n    isArray() {\n      return false;\n    }\n\n    /**\r\n     * Valueの種類がマップ型ならtrue\r\n     */\n    isMap() {\n      return false;\n    }\n\n    /**\r\n     * 引数の値と等しければtrue\r\n     */\n\n    equals(value) {\n      return false;\n    }\n\n    /**\r\n     * Valueの値が静的ならtrue、静的なら解放しない\r\n     */\n    isStatic() {\n      return false;\n    }\n\n    /**\r\n     * Valueにエラー値をセットする\r\n     */\n    setErrorNotForClientCall(errorStr) {\n      return JsonError.errorValue;\n    }\n\n    /**\r\n     * 初期化用メソッド\r\n     */\n    static staticInitializeNotForClientCall() {\n      JsonBoolean.trueValue = new JsonBoolean(true);\n      JsonBoolean.falseValue = new JsonBoolean(false);\n      JsonError.errorValue = new JsonError('ERROR', true);\n      this.nullValue = new JsonNullvalue();\n      Value.s_dummyKeys = new csmVector();\n    }\n\n    /**\r\n     * リリース用メソッド\r\n     */\n    static staticReleaseNotForClientCall() {\n      JsonBoolean.trueValue = null;\n      JsonBoolean.falseValue = null;\n      JsonError.errorValue = null;\n      Value.nullValue = null;\n      Value.s_dummyKeys = null;\n      JsonBoolean.trueValue = null;\n      JsonBoolean.falseValue = null;\n      JsonError.errorValue = null;\n      Value.nullValue = null;\n      Value.s_dummyKeys = null;\n    }\n\n    // 一時的な返り値として返すNULL。   CubismFramework::Disposeするまではdeleteしない\n  }\n  // 文字列バッファ\n  Value.s_dummyKeys = void 0;\n  // ダミーキー\n  Value.errorValue = void 0;\n  // 一時的な返り値として返すエラー。 CubismFramework::Disposeするまではdeleteしない\n  Value.nullValue = void 0;\n  _Live2DCubismFramework.Value = Value;\n  class CubismJson {\n    /**\r\n     * コンストラクタ\r\n     */\n    constructor(buffer, length) {\n      this._error = void 0;\n      // パース時のエラー\n      this._lineCount = void 0;\n      // エラー報告に用いる行数カウント\n      this._root = void 0;\n      this._error = null;\n      this._lineCount = 0;\n      this._root = null;\n      if (buffer != undefined) {\n        this.parseBytes(buffer, length);\n      }\n    }\n\n    /**\r\n     * バイトデータから直接ロードしてパースする\r\n     *\r\n     * @param buffer バッファ\r\n     * @param size バッファサイズ\r\n     * @return CubismJsonクラスのインスタンス。失敗したらNULL\r\n     */\n    static create(buffer, size) {\n      const json = new CubismJson();\n      const succeeded = json.parseBytes(buffer, size);\n      if (!succeeded) {\n        CubismJson.delete(json);\n        return null;\n      } else {\n        return json;\n      }\n    }\n\n    /**\r\n     * パースしたJSONオブジェクトの解放処理\r\n     *\r\n     * @param instance CubismJsonクラスのインスタンス\r\n     */\n    static delete(instance) {\n      instance = null;\n    }\n\n    /**\r\n     * パースしたJSONのルート要素を返す\r\n     */\n    getRoot() {\n      return this._root;\n    }\n\n    /**\r\n     *  UnicodeのバイナリをStringに変換\r\n     *\r\n     * @param buffer 変換するバイナリデータ\r\n     * @return 変換後の文字列\r\n     */\n    arrayBufferToString(buffer) {\n      const uint8Array = new Uint8Array(buffer);\n      let str = '';\n      for (let i = 0, len = uint8Array.length; i < len; ++i) {\n        str += '%' + this.pad(uint8Array[i].toString(16));\n      }\n      str = decodeURIComponent(str);\n      return str;\n    }\n\n    /**\r\n     * エンコード、パディング\r\n     */\n    pad(n) {\n      return n.length < 2 ? '0' + n : n;\n    }\n\n    /**\r\n     * JSONのパースを実行する\r\n     * @param buffer    パース対象のデータバイト\r\n     * @param size      データバイトのサイズ\r\n     * return true : 成功\r\n     * return false: 失敗\r\n     */\n    parseBytes(buffer, size) {\n      const endPos = new Array(1); // 参照渡しにするため配列\n      const decodeBuffer = this.arrayBufferToString(buffer);\n      this._root = this.parseValue(decodeBuffer, size, 0, endPos);\n      if (this._error) {\n        let strbuf = '\\0';\n        strbuf = 'Json parse error : @line ' + (this._lineCount + 1) + '\\n';\n        this._root = new JsonString(strbuf);\n        CubismLogInfo('{0}', this._root.getRawString());\n        return false;\n      } else if (this._root == null) {\n        this._root = new JsonError(new csmString(this._error), false); // rootは解放されるのでエラーオブジェクトを別途作成する\n        return false;\n      }\n      return true;\n    }\n\n    /**\r\n     * パース時のエラー値を返す\r\n     */\n    getParseError() {\n      return this._error;\n    }\n\n    /**\r\n     * ルート要素の次の要素がファイルの終端だったらtrueを返す\r\n     */\n    checkEndOfFile() {\n      return this._root.getArray()[1].equals('EOF');\n    }\n\n    /**\r\n     * JSONエレメントからValue(float,String,Value*,Array,null,true,false)をパースする\r\n     * エレメントの書式に応じて内部でParseString(), ParseObject(), ParseArray()を呼ぶ\r\n     *\r\n     * @param   buffer      JSONエレメントのバッファ\r\n     * @param   length      パースする長さ\r\n     * @param   begin       パースを開始する位置\r\n     * @param   outEndPos   パース終了時の位置\r\n     * @return      パースから取得したValueオブジェクト\r\n     */\n    parseValue(buffer, length, begin, outEndPos) {\n      if (this._error) return null;\n      let o = null;\n      let i = begin;\n      let f;\n      for (; i < length; i++) {\n        const c = buffer[i];\n        switch (c) {\n          case '-':\n          case '.':\n          case '0':\n          case '1':\n          case '2':\n          case '3':\n          case '4':\n          case '5':\n          case '6':\n          case '7':\n          case '8':\n          case '9':\n            {\n              const afterString = new Array(1); // 参照渡しにするため\n              f = strtod(buffer.slice(i), afterString);\n              outEndPos[0] = buffer.indexOf(afterString[0]);\n              return new JsonFloat(f);\n            }\n          case '\"':\n            return new JsonString(this.parseString(buffer, length, i + 1, outEndPos));\n          // \\\"の次の文字から\n          case '[':\n            o = this.parseArray(buffer, length, i + 1, outEndPos);\n            return o;\n          case '{':\n            o = this.parseObject(buffer, length, i + 1, outEndPos);\n            return o;\n          case 'n':\n            // null以外にない\n            if (i + 3 < length) {\n              o = new JsonNullvalue(); // 解放できるようにする\n              outEndPos[0] = i + 4;\n            } else {\n              this._error = 'parse null';\n            }\n            return o;\n          case 't':\n            // true以外にない\n            if (i + 3 < length) {\n              o = JsonBoolean.trueValue;\n              outEndPos[0] = i + 4;\n            } else {\n              this._error = 'parse true';\n            }\n            return o;\n          case 'f':\n            // false以外にない\n            if (i + 4 < length) {\n              o = JsonBoolean.falseValue;\n              outEndPos[0] = i + 5;\n            } else {\n              this._error = \"illegal ',' position\";\n            }\n            return o;\n          case ',':\n            // Array separator\n            this._error = \"illegal ',' position\";\n            return null;\n          case ']':\n            // 不正な｝だがスキップする。配列の最後に不要な , があると思われる\n            outEndPos[0] = i; // 同じ文字を再処理\n            return null;\n          case '\\n':\n            this._lineCount++;\n          case ' ':\n          case '\\t':\n          case '\\r':\n          default:\n            // スキップ\n            break;\n        }\n      }\n      this._error = 'illegal end of value';\n      return null;\n    }\n\n    /**\r\n     * 次の「\"」までの文字列をパースする。\r\n     *\r\n     * @param   string  ->  パース対象の文字列\r\n     * @param   length  ->  パースする長さ\r\n     * @param   begin   ->  パースを開始する位置\r\n     * @param  outEndPos   ->  パース終了時の位置\r\n     * @return      パースした文F字列要素\r\n     */\n    parseString(string, length, begin, outEndPos) {\n      if (this._error) return null;\n      let i = begin;\n      let c, c2;\n      const ret = new csmString('');\n      let bufStart = begin; // sbufに登録されていない文字の開始位置\n\n      for (; i < length; i++) {\n        c = string[i];\n        switch (c) {\n          case '\"':\n            {\n              // 終端の”、エスケープ文字は別に処理されるのでここに来ない\n              outEndPos[0] = i + 1; // ”の次の文字\n              ret.append(string.slice(bufStart), i - bufStart); // 前の文字までを登録する\n              return ret.s;\n            }\n          case '//':\n            {\n              // エスケープの場合\n              i++; // ２文字をセットで扱う\n\n              if (i - 1 > bufStart) {\n                ret.append(string.slice(bufStart), i - bufStart); // 前の文字までを登録する\n              }\n\n              bufStart = i + 1; // エスケープ（２文字)の次の文字から\n\n              if (i < length) {\n                c2 = string[i];\n                switch (c2) {\n                  case '\\\\':\n                    ret.expansion(1, '\\\\');\n                    break;\n                  case '\"':\n                    ret.expansion(1, '\"');\n                    break;\n                  case '/':\n                    ret.expansion(1, '/');\n                    break;\n                  case 'b':\n                    ret.expansion(1, '\\b');\n                    break;\n                  case 'f':\n                    ret.expansion(1, '\\f');\n                    break;\n                  case 'n':\n                    ret.expansion(1, '\\n');\n                    break;\n                  case 'r':\n                    ret.expansion(1, '\\r');\n                    break;\n                  case 't':\n                    ret.expansion(1, '\\t');\n                    break;\n                  case 'u':\n                    this._error = 'parse string/unicord escape not supported';\n                    break;\n                  default:\n                    break;\n                }\n              } else {\n                this._error = 'parse string/escape error';\n              }\n            }\n          default:\n            {\n              break;\n            }\n        }\n      }\n      this._error = 'parse string/illegal end';\n      return null;\n    }\n\n    /**\r\n     * JSONのオブジェクトエレメントをパースしてValueオブジェクトを返す\r\n     *\r\n     * @param buffer    JSONエレメントのバッファ\r\n     * @param length    パースする長さ\r\n     * @param begin     パースを開始する位置\r\n     * @param outEndPos パース終了時の位置\r\n     * @return パースから取得したValueオブジェクト\r\n     */\n    parseObject(buffer, length, begin, outEndPos) {\n      if (this._error) return null;\n      const ret = new JsonMap();\n\n      // Key: Value\n      let key = '';\n      let i = begin;\n      let c = '';\n      const localRetEndPos2 = Array(1);\n      let ok = false;\n\n      // , が続く限りループ\n      for (; i < length; i++) {\n        FOR_LOOP: for (; i < length; i++) {\n          c = buffer[i];\n          switch (c) {\n            case '\"':\n              key = this.parseString(buffer, length, i + 1, localRetEndPos2);\n              if (this._error) {\n                return null;\n              }\n              i = localRetEndPos2[0];\n              ok = true;\n              break FOR_LOOP;\n            //-- loopから出る\n            case '}':\n              // 閉じカッコ\n              outEndPos[0] = i + 1;\n              return ret;\n            // 空\n            case ':':\n              this._error = \"illegal ':' position\";\n              break;\n            case '\\n':\n              this._lineCount++;\n            default:\n              break;\n            // スキップする文字\n          }\n        }\n\n        if (!ok) {\n          this._error = 'key not found';\n          return null;\n        }\n        ok = false;\n\n        // : をチェック\n        FOR_LOOP2: for (; i < length; i++) {\n          c = buffer[i];\n          switch (c) {\n            case ':':\n              ok = true;\n              i++;\n              break FOR_LOOP2;\n            case '}':\n              this._error = \"illegal '}' position\";\n              break;\n            case '\\n':\n              this._lineCount++;\n            // case ' ': case '\\t' : case '\\r':\n            default:\n              break;\n            // スキップする文字\n          }\n        }\n\n        if (!ok) {\n          this._error = \"':' not found\";\n          return null;\n        }\n\n        // 値をチェック\n        const value = this.parseValue(buffer, length, i, localRetEndPos2);\n        if (this._error) {\n          return null;\n        }\n        i = localRetEndPos2[0];\n\n        // ret.put(key, value);\n        ret.put(key, value);\n        FOR_LOOP3: for (; i < length; i++) {\n          c = buffer[i];\n          switch (c) {\n            case ',':\n              break FOR_LOOP3;\n            case '}':\n              outEndPos[0] = i + 1;\n              return ret;\n            // 正常終了\n            case '\\n':\n              this._lineCount++;\n            default:\n              break;\n            // スキップ\n          }\n        }\n      }\n\n      this._error = 'illegal end of perseObject';\n      return null;\n    }\n\n    /**\r\n     * 次の「\"」までの文字列をパースする。\r\n     * @param buffer    JSONエレメントのバッファ\r\n     * @param length    パースする長さ\r\n     * @param begin     パースを開始する位置\r\n     * @param outEndPos パース終了時の位置\r\n     * @return パースから取得したValueオブジェクト\r\n     */\n    parseArray(buffer, length, begin, outEndPos) {\n      if (this._error) return null;\n      let ret = new JsonArray();\n\n      // key : value\n      let i = begin;\n      let c;\n      const localRetEndpos2 = new Array(1);\n\n      // , が続く限りループ\n      for (; i < length; i++) {\n        // : をチェック\n        const value = this.parseValue(buffer, length, i, localRetEndpos2);\n        if (this._error) {\n          return null;\n        }\n        i = localRetEndpos2[0];\n        if (value) {\n          ret.add(value);\n        }\n\n        // FOR_LOOP3:\n        // boolean breakflag = false;\n        FOR_LOOP: for (; i < length; i++) {\n          c = buffer[i];\n          switch (c) {\n            case ',':\n              // breakflag = true;\n              // break; // 次のKEY, VAlUEへ\n              break FOR_LOOP;\n            case ']':\n              outEndPos[0] = i + 1;\n              return ret;\n            // 終了\n            case '\\n':\n              ++this._lineCount;\n            //case ' ': case '\\t': case '\\r':\n            default:\n              break;\n            // スキップ\n          }\n        }\n      }\n\n      ret = void 0;\n      this._error = 'illegal end of parseObject';\n      return null;\n    }\n\n    // パースされたルート要素\n  }\n  _Live2DCubismFramework.CubismJson = CubismJson;\n  class JsonFloat extends Value {\n    /**\r\n     * コンストラクタ\r\n     */\n    constructor(v) {\n      super();\n      this._value = void 0;\n      this._value = v;\n    }\n\n    /**\r\n     * Valueの種類が数値型ならtrue\r\n     */\n    isFloat() {\n      return true;\n    }\n\n    /**\r\n     * 要素を文字列で返す(csmString型)\r\n     */\n    getString(defaultValue, indent) {\n      const strbuf = '\\0';\n      this._value = parseFloat(strbuf);\n      this._stringBuffer = strbuf;\n      return this._stringBuffer;\n    }\n\n    /**\r\n     * 要素を数値型で返す(number)\r\n     */\n    toInt() {\n      let defaultValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      return parseInt(this._value.toString());\n    }\n\n    /**\r\n     * 要素を数値型で返す(number)\r\n     */\n    toFloat() {\n      let defaultValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.0;\n      return this._value;\n    }\n\n    /**\r\n     * 引数の値と等しければtrue\r\n     */\n\n    equals(value) {\n      if ('number' === typeof value) {\n        // int\n        if (Math.round(value)) {\n          return false;\n        }\n        // float\n        else {\n          return value == this._value;\n        }\n      }\n      return false;\n    }\n\n    // JSON要素の値\n  }\n  _Live2DCubismFramework.JsonFloat = JsonFloat;\n  class JsonBoolean extends Value {\n    /**\r\n     * Valueの種類が真偽値ならtrue\r\n     */\n    isBool() {\n      return true;\n    }\n\n    /**\r\n     * 要素を真偽値で返す(boolean)\r\n     */\n    toBoolean() {\n      let defaultValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      return this._boolValue;\n    }\n\n    /**\r\n     * 要素を文字列で返す(csmString型)\r\n     */\n    getString(defaultValue, indent) {\n      this._stringBuffer = this._boolValue ? 'true' : 'false';\n      return this._stringBuffer;\n    }\n\n    /**\r\n     * 引数の値と等しければtrue\r\n     */\n\n    equals(value) {\n      if ('boolean' === typeof value) {\n        return value == this._boolValue;\n      }\n      return false;\n    }\n\n    /**\r\n     * Valueの値が静的ならtrue, 静的なら解放しない\r\n     */\n    isStatic() {\n      return true;\n    }\n\n    /**\r\n     * 引数付きコンストラクタ\r\n     */\n    constructor(v) {\n      super();\n      // false\n      this._boolValue = void 0;\n      this._boolValue = v;\n    }\n\n    // JSON要素の値\n  }\n  JsonBoolean.trueValue = void 0;\n  // true\n  JsonBoolean.falseValue = void 0;\n  _Live2DCubismFramework.JsonBoolean = JsonBoolean;\n  class JsonString extends Value {\n    /**\r\n     * 引数付きコンストラクタ\r\n     */\n\n    constructor(s) {\n      super();\n      if ('string' === typeof s) {\n        this._stringBuffer = s;\n      }\n      if (s instanceof csmString) {\n        this._stringBuffer = s.s;\n      }\n    }\n\n    /**\r\n     * Valueの種類が文字列ならtrue\r\n     */\n    isString() {\n      return true;\n    }\n\n    /**\r\n     * 要素を文字列で返す(csmString型)\r\n     */\n    getString(defaultValue, indent) {\n      return this._stringBuffer;\n    }\n\n    /**\r\n     * 引数の値と等しければtrue\r\n     */\n\n    equals(value) {\n      if ('string' === typeof value) {\n        return this._stringBuffer == value;\n      }\n      if (value instanceof csmString) {\n        return this._stringBuffer == value.s;\n      }\n      return false;\n    }\n  }\n  _Live2DCubismFramework.JsonString = JsonString;\n  class JsonError extends JsonString {\n    /**\r\n     * Valueの値が静的ならtrue、静的なら解放しない\r\n     */\n    isStatic() {\n      return this._isStatic;\n    }\n\n    /**\r\n     * エラー情報をセットする\r\n     */\n    setErrorNotForClientCall(s) {\n      this._stringBuffer = s;\n      return this;\n    }\n\n    /**\r\n     * 引数付きコンストラクタ\r\n     */\n    constructor(s, isStatic) {\n      if ('string' === typeof s) {\n        super(s);\n        this._isStatic = void 0;\n      } else {\n        super(s);\n        this._isStatic = void 0;\n      }\n      this._isStatic = isStatic;\n    }\n\n    /**\r\n     * Valueの種類がエラー値ならtrue\r\n     */\n    isError() {\n      return true;\n    }\n\n    // 静的なValueかどうか\n  }\n  _Live2DCubismFramework.JsonError = JsonError;\n  class JsonNullvalue extends Value {\n    /**\r\n     * Valueの種類がNULL値ならtrue\r\n     */\n    isNull() {\n      return true;\n    }\n\n    /**\r\n     * 要素を文字列で返す(csmString型)\r\n     */\n    getString(defaultValue, indent) {\n      return this._stringBuffer;\n    }\n\n    /**\r\n     * Valueの値が静的ならtrue, 静的なら解放しない\r\n     */\n    isStatic() {\n      return true;\n    }\n\n    /**\r\n     * コンストラクタ\r\n     */\n    constructor() {\n      super();\n      this._stringBuffer = 'NullValue';\n    }\n  }\n  _Live2DCubismFramework.JsonNullvalue = JsonNullvalue;\n  class JsonArray extends Value {\n    /**\r\n     * コンストラクタ\r\n     */\n    constructor() {\n      super();\n      this._array = void 0;\n      this._array = new csmVector();\n    }\n\n    /**\r\n     * デストラクタ相当の処理\r\n     */\n    release() {\n      for (let ite = this._array.begin(); ite.notEqual(this._array.end()); ite.preIncrement()) {\n        let v = ite.ptr();\n        if (v && !v.isStatic()) {\n          v = void 0;\n          v = null;\n        }\n      }\n    }\n\n    /**\r\n     * Valueの種類が配列ならtrue\r\n     */\n    isArray() {\n      return true;\n    }\n\n    /**\r\n     * 添字演算子[index]\r\n     */\n    getValueByIndex(index) {\n      if (index < 0 || this._array.getSize() <= index) {\n        return Value.errorValue.setErrorNotForClientCall(CSM_JSON_ERROR_INDEX_OF_BOUNDS);\n      }\n      const v = this._array.at(index);\n      if (v == null) {\n        return Value.nullValue;\n      }\n      return v;\n    }\n\n    /**\r\n     * 添字演算子[string | csmString]\r\n     */\n    getValueByString(s) {\n      return Value.errorValue.setErrorNotForClientCall(CSM_JSON_ERROR_TYPE_MISMATCH);\n    }\n\n    /**\r\n     * 要素を文字列で返す(csmString型)\r\n     */\n    getString(defaultValue, indent) {\n      const stringBuffer = indent + '[\\n';\n      for (let ite = this._array.begin(); ite.notEqual(this._array.end()); ite.increment()) {\n        const v = ite.ptr();\n        this._stringBuffer += indent + '' + v.getString(indent + ' ') + '\\n';\n      }\n      this._stringBuffer = stringBuffer + indent + ']\\n';\n      return this._stringBuffer;\n    }\n\n    /**\r\n     * 配列要素を追加する\r\n     * @param v 追加する要素\r\n     */\n    add(v) {\n      this._array.pushBack(v);\n    }\n\n    /**\r\n     * 要素をコンテナで返す(csmVector<Value>)\r\n     */\n    getVector() {\n      let defaultValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      return this._array;\n    }\n\n    /**\r\n     * 要素の数を返す\r\n     */\n    getSize() {\n      return this._array.getSize();\n    }\n\n    // JSON要素の値\n  }\n  _Live2DCubismFramework.JsonArray = JsonArray;\n  class JsonMap extends Value {\n    /**\r\n     * コンストラクタ\r\n     */\n    constructor() {\n      super();\n      this._map = void 0;\n      // JSON要素の値\n      this._keys = void 0;\n      this._map = new csmMap();\n    }\n\n    /**\r\n     * デストラクタ相当の処理\r\n     */\n    release() {\n      const ite = this._map.begin();\n      while (ite.notEqual(this._map.end())) {\n        let v = ite.ptr().second;\n        if (v && !v.isStatic()) {\n          v = void 0;\n          v = null;\n        }\n        ite.preIncrement();\n      }\n    }\n\n    /**\r\n     * Valueの値がMap型ならtrue\r\n     */\n    isMap() {\n      return true;\n    }\n\n    /**\r\n     * 添字演算子[string | csmString]\r\n     */\n    getValueByString(s) {\n      if (s instanceof csmString) {\n        const ret = this._map.getValue(s.s);\n        if (ret == null) {\n          return Value.nullValue;\n        }\n        return ret;\n      }\n      for (let iter = this._map.begin(); iter.notEqual(this._map.end()); iter.preIncrement()) {\n        if (iter.ptr().first == s) {\n          if (iter.ptr().second == null) {\n            return Value.nullValue;\n          }\n          return iter.ptr().second;\n        }\n      }\n      return Value.nullValue;\n    }\n\n    /**\r\n     * 添字演算子[index]\r\n     */\n    getValueByIndex(index) {\n      return Value.errorValue.setErrorNotForClientCall(CSM_JSON_ERROR_TYPE_MISMATCH);\n    }\n\n    /**\r\n     * 要素を文字列で返す(csmString型)\r\n     */\n    getString(defaultValue, indent) {\n      this._stringBuffer = indent + '{\\n';\n      const ite = this._map.begin();\n      while (ite.notEqual(this._map.end())) {\n        const key = ite.ptr().first;\n        const v = ite.ptr().second;\n        this._stringBuffer += indent + ' ' + key + ' : ' + v.getString(indent + '   ') + ' \\n';\n        ite.preIncrement();\n      }\n      this._stringBuffer += indent + '}\\n';\n      return this._stringBuffer;\n    }\n\n    /**\r\n     * 要素をMap型で返す\r\n     */\n    getMap(defaultValue) {\n      return this._map;\n    }\n\n    /**\r\n     * Mapに要素を追加する\r\n     */\n    put(key, v) {\n      this._map.setValue(key, v);\n    }\n\n    /**\r\n     * Mapからキーのリストを取得する\r\n     */\n    getKeys() {\n      if (!this._keys) {\n        this._keys = new csmVector();\n        const ite = this._map.begin();\n        while (ite.notEqual(this._map.end())) {\n          const key = ite.ptr().first;\n          this._keys.pushBack(key);\n          ite.preIncrement();\n        }\n      }\n      return this._keys;\n    }\n\n    /**\r\n     * Mapの要素数を取得する\r\n     */\n    getSize() {\n      return this._keys.getSize();\n    }\n\n    // JSON要素の値\n  }\n  _Live2DCubismFramework.JsonMap = JsonMap;\n})(Live2DCubismFramework || (Live2DCubismFramework = {}));","map":{"version":3,"names":["Live2DCubismFramework","csmstring","csmmap","csmvector","CubismLogInfo","strtod","csmVector","csmVector_iterator","iterator","csmMap","csmMap_iterator","csmString","_Live2DCubismFramework","CSM_JSON_ERROR_TYPE_MISMATCH","CSM_JSON_ERROR_INDEX_OF_BOUNDS","Value","constructor","_stringBuffer","getRawString","defaultValue","indent","getString","toInt","arguments","length","undefined","toFloat","toBoolean","getSize","getArray","getVector","getMap","getValueByIndex","index","errorValue","setErrorNotForClientCall","getValueByString","s","nullValue","getKeys","s_dummyKeys","isError","isNull","isBool","isFloat","isString","isArray","isMap","equals","value","isStatic","errorStr","JsonError","staticInitializeNotForClientCall","JsonBoolean","trueValue","falseValue","JsonNullvalue","staticReleaseNotForClientCall","CubismJson","buffer","_error","_lineCount","_root","parseBytes","create","size","json","succeeded","delete","instance","getRoot","arrayBufferToString","uint8Array","Uint8Array","str","i","len","pad","toString","decodeURIComponent","n","endPos","Array","decodeBuffer","parseValue","strbuf","JsonString","getParseError","checkEndOfFile","begin","outEndPos","o","f","c","afterString","slice","indexOf","JsonFloat","parseString","parseArray","parseObject","string","c2","ret","bufStart","append","expansion","JsonMap","key","localRetEndPos2","ok","FOR_LOOP","FOR_LOOP2","put","FOR_LOOP3","JsonArray","localRetEndpos2","add","v","_value","parseFloat","parseInt","Math","round","_boolValue","_isStatic","_array","release","ite","notEqual","end","preIncrement","ptr","at","stringBuffer","increment","pushBack","_map","_keys","second","getValue","iter","first","setValue"],"sources":["C:/Users/cleyc/OneDrive/Documents/RR/RRWebsiteRenewed/my-app/src/mylive2d/react-live2d/Samples/TypeScript/Demo/Framework/src/utils/cubismjson.ts"],"sourcesContent":["/**\r\n * Copyright(c) Live2D Inc. All rights reserved.\r\n *\r\n * Use of this source code is governed by the Live2D Open Software license\r\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\r\n */\r\n\r\nimport { Live2DCubismFramework as csmstring } from '../type/csmstring';\r\nimport { Live2DCubismFramework as csmmap } from '../type/csmmap';\r\nimport { Live2DCubismFramework as csmvector } from '../type/csmvector';\r\nimport { CubismLogInfo } from './cubismdebug';\r\nimport { strtod } from '../live2dcubismframework';\r\nimport csmVector = csmvector.csmVector;\r\nimport csmVector_iterator = csmvector.iterator;\r\nimport csmMap = csmmap.csmMap;\r\nimport csmMap_iterator = csmmap.iterator;\r\nimport csmString = csmstring.csmString;\r\n\r\nexport namespace Live2DCubismFramework {\r\n  // StaticInitializeNotForClientCall()で初期化する\r\n  const CSM_JSON_ERROR_TYPE_MISMATCH = 'Error: type mismatch';\r\n  const CSM_JSON_ERROR_INDEX_OF_BOUNDS = 'Error: index out of bounds';\r\n\r\n  /**\r\n   * パースしたJSONエレメントの要素の基底クラス。\r\n   */\r\n  export abstract class Value {\r\n    /**\r\n     * コンストラクタ\r\n     */\r\n    public constructor() {}\r\n\r\n    /**\r\n     * 要素を文字列型で返す(csmString型)\r\n     */\r\n    public abstract getString(defaultValue?: string, indent?: string): string;\r\n\r\n    /**\r\n     * 要素を文字列型で返す(string)\r\n     */\r\n    public getRawString(defaultValue?: string, indent?: string): string {\r\n      return this.getString(defaultValue, indent);\r\n    }\r\n\r\n    /**\r\n     * 要素を数値型で返す(number)\r\n     */\r\n    public toInt(defaultValue = 0): number {\r\n      return defaultValue;\r\n    }\r\n\r\n    /**\r\n     * 要素を数値型で返す(number)\r\n     */\r\n    public toFloat(defaultValue = 0): number {\r\n      return defaultValue;\r\n    }\r\n\r\n    /**\r\n     * 要素を真偽値で返す(boolean)\r\n     */\r\n    public toBoolean(defaultValue = false): boolean {\r\n      return defaultValue;\r\n    }\r\n\r\n    /**\r\n     * サイズを返す\r\n     */\r\n    public getSize(): number {\r\n      return 0;\r\n    }\r\n\r\n    /**\r\n     * 要素を配列で返す(Value[])\r\n     */\r\n    public getArray(defaultValue: Value[] = null): Value[] {\r\n      return defaultValue;\r\n    }\r\n\r\n    /**\r\n     * 要素をコンテナで返す(array)\r\n     */\r\n    public getVector(defaultValue?: csmVector<Value>): csmVector<Value> {\r\n      return defaultValue;\r\n    }\r\n\r\n    /**\r\n     * 要素をマップで返す(csmMap<csmString, Value>)\r\n     */\r\n    public getMap(defaultValue?: csmMap<string, Value>): csmMap<string, Value> {\r\n      return defaultValue;\r\n    }\r\n\r\n    /**\r\n     * 添字演算子[index]\r\n     */\r\n    public getValueByIndex(index: number): Value {\r\n      return Value.errorValue.setErrorNotForClientCall(\r\n        CSM_JSON_ERROR_TYPE_MISMATCH\r\n      );\r\n    }\r\n\r\n    /**\r\n     * 添字演算子[string | csmString]\r\n     */\r\n    public getValueByString(s: string | csmString): Value {\r\n      return Value.nullValue.setErrorNotForClientCall(\r\n        CSM_JSON_ERROR_TYPE_MISMATCH\r\n      );\r\n    }\r\n\r\n    /**\r\n     * マップのキー一覧をコンテナで返す\r\n     *\r\n     * @return マップのキーの一覧\r\n     */\r\n    public getKeys(): csmVector<string> {\r\n      return Value.s_dummyKeys;\r\n    }\r\n\r\n    /**\r\n     * Valueの種類がエラー値ならtrue\r\n     */\r\n    public isError(): boolean {\r\n      return false;\r\n    }\r\n\r\n    /**\r\n     * Valueの種類がnullならtrue\r\n     */\r\n    public isNull(): boolean {\r\n      return false;\r\n    }\r\n\r\n    /**\r\n     * Valueの種類が真偽値ならtrue\r\n     */\r\n    public isBool(): boolean {\r\n      return false;\r\n    }\r\n\r\n    /**\r\n     * Valueの種類が数値型ならtrue\r\n     */\r\n    public isFloat(): boolean {\r\n      return false;\r\n    }\r\n\r\n    /**\r\n     * Valueの種類が文字列ならtrue\r\n     */\r\n    public isString(): boolean {\r\n      return false;\r\n    }\r\n\r\n    /**\r\n     * Valueの種類が配列ならtrue\r\n     */\r\n    public isArray(): boolean {\r\n      return false;\r\n    }\r\n\r\n    /**\r\n     * Valueの種類がマップ型ならtrue\r\n     */\r\n    public isMap(): boolean {\r\n      return false;\r\n    }\r\n\r\n    /**\r\n     * 引数の値と等しければtrue\r\n     */\r\n    public equals(value: csmString): boolean;\r\n    public equals(value: string): boolean;\r\n    public equals(value: number): boolean;\r\n    public equals(value: boolean): boolean;\r\n    public equals(value: any): boolean {\r\n      return false;\r\n    }\r\n\r\n    /**\r\n     * Valueの値が静的ならtrue、静的なら解放しない\r\n     */\r\n    public isStatic(): boolean {\r\n      return false;\r\n    }\r\n\r\n    /**\r\n     * Valueにエラー値をセットする\r\n     */\r\n    public setErrorNotForClientCall(errorStr: string): Value {\r\n      return JsonError.errorValue;\r\n    }\r\n\r\n    /**\r\n     * 初期化用メソッド\r\n     */\r\n    public static staticInitializeNotForClientCall(): void {\r\n      JsonBoolean.trueValue = new JsonBoolean(true);\r\n      JsonBoolean.falseValue = new JsonBoolean(false);\r\n\r\n      JsonError.errorValue = new JsonError('ERROR', true);\r\n      this.nullValue = new JsonNullvalue();\r\n\r\n      Value.s_dummyKeys = new csmVector<string>();\r\n    }\r\n\r\n    /**\r\n     * リリース用メソッド\r\n     */\r\n    public static staticReleaseNotForClientCall(): void {\r\n      JsonBoolean.trueValue = null;\r\n      JsonBoolean.falseValue = null;\r\n      JsonError.errorValue = null;\r\n      Value.nullValue = null;\r\n      Value.s_dummyKeys = null;\r\n\r\n      JsonBoolean.trueValue = null;\r\n      JsonBoolean.falseValue = null;\r\n      JsonError.errorValue = null;\r\n      Value.nullValue = null;\r\n      Value.s_dummyKeys = null;\r\n    }\r\n\r\n    protected _stringBuffer: string; // 文字列バッファ\r\n\r\n    private static s_dummyKeys: csmVector<string>; // ダミーキー\r\n\r\n    public static errorValue: Value; // 一時的な返り値として返すエラー。 CubismFramework::Disposeするまではdeleteしない\r\n    public static nullValue: Value; // 一時的な返り値として返すNULL。   CubismFramework::Disposeするまではdeleteしない\r\n  }\r\n\r\n  /**\r\n   * Ascii文字のみ対応した最小限の軽量JSONパーサ。\r\n   * 仕様はJSONのサブセットとなる。\r\n   * 設定ファイル(model3.json)などのロード用\r\n   *\r\n   * [未対応項目]\r\n   * ・日本語などの非ASCII文字\r\n   * ・eによる指数表現\r\n   */\r\n  export class CubismJson {\r\n    /**\r\n     * コンストラクタ\r\n     */\r\n    public constructor(buffer?: ArrayBuffer, length?: number) {\r\n      this._error = null;\r\n      this._lineCount = 0;\r\n      this._root = null;\r\n\r\n      if (buffer != undefined) {\r\n        this.parseBytes(buffer, length);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * バイトデータから直接ロードしてパースする\r\n     *\r\n     * @param buffer バッファ\r\n     * @param size バッファサイズ\r\n     * @return CubismJsonクラスのインスタンス。失敗したらNULL\r\n     */\r\n    public static create(buffer: ArrayBuffer, size: number) {\r\n      const json = new CubismJson();\r\n      const succeeded: boolean = json.parseBytes(buffer, size);\r\n\r\n      if (!succeeded) {\r\n        CubismJson.delete(json);\r\n        return null;\r\n      } else {\r\n        return json;\r\n      }\r\n    }\r\n\r\n    /**\r\n     * パースしたJSONオブジェクトの解放処理\r\n     *\r\n     * @param instance CubismJsonクラスのインスタンス\r\n     */\r\n    public static delete(instance: CubismJson) {\r\n      instance = null;\r\n    }\r\n\r\n    /**\r\n     * パースしたJSONのルート要素を返す\r\n     */\r\n    public getRoot(): Value {\r\n      return this._root;\r\n    }\r\n\r\n    /**\r\n     *  UnicodeのバイナリをStringに変換\r\n     *\r\n     * @param buffer 変換するバイナリデータ\r\n     * @return 変換後の文字列\r\n     */\r\n    public arrayBufferToString(buffer: ArrayBuffer): string {\r\n      const uint8Array: Uint8Array = new Uint8Array(buffer);\r\n      let str = '';\r\n\r\n      for (let i = 0, len: number = uint8Array.length; i < len; ++i) {\r\n        str += '%' + this.pad(uint8Array[i].toString(16));\r\n      }\r\n\r\n      str = decodeURIComponent(str);\r\n      return str;\r\n    }\r\n\r\n    /**\r\n     * エンコード、パディング\r\n     */\r\n    private pad(n: string): string {\r\n      return n.length < 2 ? '0' + n : n;\r\n    }\r\n\r\n    /**\r\n     * JSONのパースを実行する\r\n     * @param buffer    パース対象のデータバイト\r\n     * @param size      データバイトのサイズ\r\n     * return true : 成功\r\n     * return false: 失敗\r\n     */\r\n    public parseBytes(buffer: ArrayBuffer, size: number): boolean {\r\n      const endPos: number[] = new Array(1); // 参照渡しにするため配列\r\n      const decodeBuffer: string = this.arrayBufferToString(buffer);\r\n      this._root = this.parseValue(decodeBuffer, size, 0, endPos);\r\n\r\n      if (this._error) {\r\n        let strbuf = '\\0';\r\n        strbuf = 'Json parse error : @line ' + (this._lineCount + 1) + '\\n';\r\n        this._root = new JsonString(strbuf);\r\n\r\n        CubismLogInfo('{0}', this._root.getRawString());\r\n        return false;\r\n      } else if (this._root == null) {\r\n        this._root = new JsonError(new csmString(this._error), false); // rootは解放されるのでエラーオブジェクトを別途作成する\r\n        return false;\r\n      }\r\n      return true;\r\n    }\r\n\r\n    /**\r\n     * パース時のエラー値を返す\r\n     */\r\n    public getParseError(): string {\r\n      return this._error;\r\n    }\r\n\r\n    /**\r\n     * ルート要素の次の要素がファイルの終端だったらtrueを返す\r\n     */\r\n    public checkEndOfFile(): boolean {\r\n      return this._root.getArray()[1].equals('EOF');\r\n    }\r\n\r\n    /**\r\n     * JSONエレメントからValue(float,String,Value*,Array,null,true,false)をパースする\r\n     * エレメントの書式に応じて内部でParseString(), ParseObject(), ParseArray()を呼ぶ\r\n     *\r\n     * @param   buffer      JSONエレメントのバッファ\r\n     * @param   length      パースする長さ\r\n     * @param   begin       パースを開始する位置\r\n     * @param   outEndPos   パース終了時の位置\r\n     * @return      パースから取得したValueオブジェクト\r\n     */\r\n    protected parseValue(\r\n      buffer: string,\r\n      length: number,\r\n      begin: number,\r\n      outEndPos: number[]\r\n    ) {\r\n      if (this._error) return null;\r\n\r\n      let o: Value = null;\r\n      let i: number = begin;\r\n      let f: number;\r\n\r\n      for (; i < length; i++) {\r\n        const c: string = buffer[i];\r\n        switch (c) {\r\n          case '-':\r\n          case '.':\r\n          case '0':\r\n          case '1':\r\n          case '2':\r\n          case '3':\r\n          case '4':\r\n          case '5':\r\n          case '6':\r\n          case '7':\r\n          case '8':\r\n          case '9': {\r\n            const afterString: string[] = new Array(1); // 参照渡しにするため\r\n            f = strtod(buffer.slice(i), afterString);\r\n            outEndPos[0] = buffer.indexOf(afterString[0]);\r\n            return new JsonFloat(f);\r\n          }\r\n          case '\"':\r\n            return new JsonString(\r\n              this.parseString(buffer, length, i + 1, outEndPos)\r\n            ); // \\\"の次の文字から\r\n          case '[':\r\n            o = this.parseArray(buffer, length, i + 1, outEndPos);\r\n            return o;\r\n          case '{':\r\n            o = this.parseObject(buffer, length, i + 1, outEndPos);\r\n            return o;\r\n          case 'n': // null以外にない\r\n            if (i + 3 < length) {\r\n              o = new JsonNullvalue(); // 解放できるようにする\r\n              outEndPos[0] = i + 4;\r\n            } else {\r\n              this._error = 'parse null';\r\n            }\r\n            return o;\r\n          case 't': // true以外にない\r\n            if (i + 3 < length) {\r\n              o = JsonBoolean.trueValue;\r\n              outEndPos[0] = i + 4;\r\n            } else {\r\n              this._error = 'parse true';\r\n            }\r\n            return o;\r\n          case 'f': // false以外にない\r\n            if (i + 4 < length) {\r\n              o = JsonBoolean.falseValue;\r\n              outEndPos[0] = i + 5;\r\n            } else {\r\n              this._error = \"illegal ',' position\";\r\n            }\r\n            return o;\r\n          case ',': // Array separator\r\n            this._error = \"illegal ',' position\";\r\n            return null;\r\n          case ']': // 不正な｝だがスキップする。配列の最後に不要な , があると思われる\r\n            outEndPos[0] = i; // 同じ文字を再処理\r\n            return null;\r\n          case '\\n':\r\n            this._lineCount++;\r\n          case ' ':\r\n          case '\\t':\r\n          case '\\r':\r\n          default:\r\n            // スキップ\r\n            break;\r\n        }\r\n      }\r\n\r\n      this._error = 'illegal end of value';\r\n      return null;\r\n    }\r\n\r\n    /**\r\n     * 次の「\"」までの文字列をパースする。\r\n     *\r\n     * @param   string  ->  パース対象の文字列\r\n     * @param   length  ->  パースする長さ\r\n     * @param   begin   ->  パースを開始する位置\r\n     * @param  outEndPos   ->  パース終了時の位置\r\n     * @return      パースした文F字列要素\r\n     */\r\n    protected parseString(\r\n      string: string,\r\n      length: number,\r\n      begin: number,\r\n      outEndPos: number[]\r\n    ): string {\r\n      if (this._error) return null;\r\n\r\n      let i = begin;\r\n      let c: string, c2: string;\r\n      const ret: csmString = new csmString('');\r\n      let bufStart: number = begin; // sbufに登録されていない文字の開始位置\r\n\r\n      for (; i < length; i++) {\r\n        c = string[i];\r\n\r\n        switch (c) {\r\n          case '\"': {\r\n            // 終端の”、エスケープ文字は別に処理されるのでここに来ない\r\n            outEndPos[0] = i + 1; // ”の次の文字\r\n            ret.append(string.slice(bufStart), i - bufStart); // 前の文字までを登録する\r\n            return ret.s;\r\n          }\r\n          case '//': {\r\n            // エスケープの場合\r\n            i++; // ２文字をセットで扱う\r\n\r\n            if (i - 1 > bufStart) {\r\n              ret.append(string.slice(bufStart), i - bufStart); // 前の文字までを登録する\r\n            }\r\n            bufStart = i + 1; // エスケープ（２文字)の次の文字から\r\n\r\n            if (i < length) {\r\n              c2 = string[i];\r\n\r\n              switch (c2) {\r\n                case '\\\\':\r\n                  ret.expansion(1, '\\\\');\r\n                  break;\r\n                case '\"':\r\n                  ret.expansion(1, '\"');\r\n                  break;\r\n                case '/':\r\n                  ret.expansion(1, '/');\r\n                  break;\r\n                case 'b':\r\n                  ret.expansion(1, '\\b');\r\n                  break;\r\n                case 'f':\r\n                  ret.expansion(1, '\\f');\r\n                  break;\r\n                case 'n':\r\n                  ret.expansion(1, '\\n');\r\n                  break;\r\n                case 'r':\r\n                  ret.expansion(1, '\\r');\r\n                  break;\r\n                case 't':\r\n                  ret.expansion(1, '\\t');\r\n                  break;\r\n                case 'u':\r\n                  this._error = 'parse string/unicord escape not supported';\r\n                  break;\r\n                default:\r\n                  break;\r\n              }\r\n            } else {\r\n              this._error = 'parse string/escape error';\r\n            }\r\n          }\r\n          default: {\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      this._error = 'parse string/illegal end';\r\n      return null;\r\n    }\r\n\r\n    /**\r\n     * JSONのオブジェクトエレメントをパースしてValueオブジェクトを返す\r\n     *\r\n     * @param buffer    JSONエレメントのバッファ\r\n     * @param length    パースする長さ\r\n     * @param begin     パースを開始する位置\r\n     * @param outEndPos パース終了時の位置\r\n     * @return パースから取得したValueオブジェクト\r\n     */\r\n    protected parseObject(\r\n      buffer: string,\r\n      length: number,\r\n      begin: number,\r\n      outEndPos: number[]\r\n    ): Value {\r\n      if (this._error) return null;\r\n      const ret: JsonMap = new JsonMap();\r\n\r\n      // Key: Value\r\n      let key = '';\r\n      let i: number = begin;\r\n      let c = '';\r\n      const localRetEndPos2: number[] = Array(1);\r\n      let ok = false;\r\n\r\n      // , が続く限りループ\r\n      for (; i < length; i++) {\r\n        FOR_LOOP: for (; i < length; i++) {\r\n          c = buffer[i];\r\n\r\n          switch (c) {\r\n            case '\"':\r\n              key = this.parseString(buffer, length, i + 1, localRetEndPos2);\r\n              if (this._error) {\r\n                return null;\r\n              }\r\n\r\n              i = localRetEndPos2[0];\r\n              ok = true;\r\n              break FOR_LOOP; //-- loopから出る\r\n            case '}': // 閉じカッコ\r\n              outEndPos[0] = i + 1;\r\n              return ret; // 空\r\n            case ':':\r\n              this._error = \"illegal ':' position\";\r\n              break;\r\n            case '\\n':\r\n              this._lineCount++;\r\n            default:\r\n              break; // スキップする文字\r\n          }\r\n        }\r\n        if (!ok) {\r\n          this._error = 'key not found';\r\n          return null;\r\n        }\r\n\r\n        ok = false;\r\n\r\n        // : をチェック\r\n        FOR_LOOP2: for (; i < length; i++) {\r\n          c = buffer[i];\r\n\r\n          switch (c) {\r\n            case ':':\r\n              ok = true;\r\n              i++;\r\n              break FOR_LOOP2;\r\n            case '}':\r\n              this._error = \"illegal '}' position\";\r\n              break;\r\n            case '\\n':\r\n              this._lineCount++;\r\n            // case ' ': case '\\t' : case '\\r':\r\n            default:\r\n              break; // スキップする文字\r\n          }\r\n        }\r\n\r\n        if (!ok) {\r\n          this._error = \"':' not found\";\r\n          return null;\r\n        }\r\n\r\n        // 値をチェック\r\n        const value: Value = this.parseValue(\r\n          buffer,\r\n          length,\r\n          i,\r\n          localRetEndPos2\r\n        );\r\n        if (this._error) {\r\n          return null;\r\n        }\r\n\r\n        i = localRetEndPos2[0];\r\n\r\n        // ret.put(key, value);\r\n        ret.put(key, value);\r\n\r\n        FOR_LOOP3: for (; i < length; i++) {\r\n          c = buffer[i];\r\n\r\n          switch (c) {\r\n            case ',':\r\n              break FOR_LOOP3;\r\n            case '}':\r\n              outEndPos[0] = i + 1;\r\n              return ret; // 正常終了\r\n            case '\\n':\r\n              this._lineCount++;\r\n            default:\r\n              break; // スキップ\r\n          }\r\n        }\r\n      }\r\n\r\n      this._error = 'illegal end of perseObject';\r\n      return null;\r\n    }\r\n\r\n    /**\r\n     * 次の「\"」までの文字列をパースする。\r\n     * @param buffer    JSONエレメントのバッファ\r\n     * @param length    パースする長さ\r\n     * @param begin     パースを開始する位置\r\n     * @param outEndPos パース終了時の位置\r\n     * @return パースから取得したValueオブジェクト\r\n     */\r\n    protected parseArray(\r\n      buffer: string,\r\n      length: number,\r\n      begin: number,\r\n      outEndPos: number[]\r\n    ): Value {\r\n      if (this._error) return null;\r\n      let ret: JsonArray = new JsonArray();\r\n\r\n      // key : value\r\n      let i: number = begin;\r\n      let c: string;\r\n      const localRetEndpos2: number[] = new Array(1);\r\n\r\n      // , が続く限りループ\r\n      for (; i < length; i++) {\r\n        // : をチェック\r\n        const value: Value = this.parseValue(\r\n          buffer,\r\n          length,\r\n          i,\r\n          localRetEndpos2\r\n        );\r\n\r\n        if (this._error) {\r\n          return null;\r\n        }\r\n        i = localRetEndpos2[0];\r\n\r\n        if (value) {\r\n          ret.add(value);\r\n        }\r\n\r\n        // FOR_LOOP3:\r\n        // boolean breakflag = false;\r\n        FOR_LOOP: for (; i < length; i++) {\r\n          c = buffer[i];\r\n\r\n          switch (c) {\r\n            case ',':\r\n              // breakflag = true;\r\n              // break; // 次のKEY, VAlUEへ\r\n              break FOR_LOOP;\r\n            case ']':\r\n              outEndPos[0] = i + 1;\r\n              return ret; // 終了\r\n            case '\\n':\r\n              ++this._lineCount;\r\n            //case ' ': case '\\t': case '\\r':\r\n            default:\r\n              break; // スキップ\r\n          }\r\n        }\r\n      }\r\n\r\n      ret = void 0;\r\n      this._error = 'illegal end of parseObject';\r\n      return null;\r\n    }\r\n\r\n    _error: string; // パース時のエラー\r\n    _lineCount: number; // エラー報告に用いる行数カウント\r\n    _root: Value; // パースされたルート要素\r\n  }\r\n\r\n  /**\r\n   * パースしたJSONの要素をfloat値として扱う\r\n   */\r\n  export class JsonFloat extends Value {\r\n    /**\r\n     * コンストラクタ\r\n     */\r\n    constructor(v: number) {\r\n      super();\r\n\r\n      this._value = v;\r\n    }\r\n\r\n    /**\r\n     * Valueの種類が数値型ならtrue\r\n     */\r\n    public isFloat(): boolean {\r\n      return true;\r\n    }\r\n\r\n    /**\r\n     * 要素を文字列で返す(csmString型)\r\n     */\r\n    public getString(defaultValue: string, indent: string): string {\r\n      const strbuf = '\\0';\r\n      this._value = parseFloat(strbuf);\r\n      this._stringBuffer = strbuf;\r\n\r\n      return this._stringBuffer;\r\n    }\r\n\r\n    /**\r\n     * 要素を数値型で返す(number)\r\n     */\r\n    public toInt(defaultValue = 0): number {\r\n      return parseInt(this._value.toString());\r\n    }\r\n\r\n    /**\r\n     * 要素を数値型で返す(number)\r\n     */\r\n    public toFloat(defaultValue = 0.0): number {\r\n      return this._value;\r\n    }\r\n\r\n    /**\r\n     * 引数の値と等しければtrue\r\n     */\r\n    public equals(value: csmString): boolean;\r\n    public equals(value: string): boolean;\r\n    public equals(value: number): boolean;\r\n    public equals(value: boolean): boolean;\r\n    public equals(value: any): boolean {\r\n      if ('number' === typeof value) {\r\n        // int\r\n        if (Math.round(value)) {\r\n          return false;\r\n        }\r\n        // float\r\n        else {\r\n          return value == this._value;\r\n        }\r\n      }\r\n      return false;\r\n    }\r\n\r\n    private _value: number; // JSON要素の値\r\n  }\r\n\r\n  /**\r\n   * パースしたJSONの要素を真偽値として扱う\r\n   */\r\n  export class JsonBoolean extends Value {\r\n    /**\r\n     * Valueの種類が真偽値ならtrue\r\n     */\r\n    public isBool(): boolean {\r\n      return true;\r\n    }\r\n\r\n    /**\r\n     * 要素を真偽値で返す(boolean)\r\n     */\r\n    public toBoolean(defaultValue = false): boolean {\r\n      return this._boolValue;\r\n    }\r\n\r\n    /**\r\n     * 要素を文字列で返す(csmString型)\r\n     */\r\n    public getString(defaultValue: string, indent: string): string {\r\n      this._stringBuffer = this._boolValue ? 'true' : 'false';\r\n\r\n      return this._stringBuffer;\r\n    }\r\n\r\n    /**\r\n     * 引数の値と等しければtrue\r\n     */\r\n    public equals(value: csmString): boolean;\r\n    public equals(value: string): boolean;\r\n    public equals(value: number): boolean;\r\n    public equals(value: boolean): boolean;\r\n    public equals(value: any): boolean {\r\n      if ('boolean' === typeof value) {\r\n        return value == this._boolValue;\r\n      }\r\n      return false;\r\n    }\r\n\r\n    /**\r\n     * Valueの値が静的ならtrue, 静的なら解放しない\r\n     */\r\n    public isStatic(): boolean {\r\n      return true;\r\n    }\r\n\r\n    /**\r\n     * 引数付きコンストラクタ\r\n     */\r\n    public constructor(v: boolean) {\r\n      super();\r\n\r\n      this._boolValue = v;\r\n    }\r\n\r\n    static trueValue: JsonBoolean; // true\r\n    static falseValue: JsonBoolean; // false\r\n\r\n    private _boolValue: boolean; // JSON要素の値\r\n  }\r\n\r\n  /**\r\n   * パースしたJSONの要素を文字列として扱う\r\n   */\r\n  export class JsonString extends Value {\r\n    /**\r\n     * 引数付きコンストラクタ\r\n     */\r\n    public constructor(s: string);\r\n    public constructor(s: csmString);\r\n    public constructor(s: any) {\r\n      super();\r\n\r\n      if ('string' === typeof s) {\r\n        this._stringBuffer = s;\r\n      }\r\n\r\n      if (s instanceof csmString) {\r\n        this._stringBuffer = s.s;\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Valueの種類が文字列ならtrue\r\n     */\r\n    public isString(): boolean {\r\n      return true;\r\n    }\r\n\r\n    /**\r\n     * 要素を文字列で返す(csmString型)\r\n     */\r\n    public getString(defaultValue: string, indent: string): string {\r\n      return this._stringBuffer;\r\n    }\r\n\r\n    /**\r\n     * 引数の値と等しければtrue\r\n     */\r\n    public equals(value: csmString): boolean;\r\n    public equals(value: string): boolean;\r\n    public equals(value: number): boolean;\r\n    public equals(value: boolean): boolean;\r\n    public equals(value: any): boolean {\r\n      if ('string' === typeof value) {\r\n        return this._stringBuffer == value;\r\n      }\r\n\r\n      if (value instanceof csmString) {\r\n        return this._stringBuffer == value.s;\r\n      }\r\n\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * JSONパース時のエラー結果。文字列型のようにふるまう\r\n   */\r\n  export class JsonError extends JsonString {\r\n    /**\r\n     * Valueの値が静的ならtrue、静的なら解放しない\r\n     */\r\n    public isStatic(): boolean {\r\n      return this._isStatic;\r\n    }\r\n\r\n    /**\r\n     * エラー情報をセットする\r\n     */\r\n    public setErrorNotForClientCall(s: string): Value {\r\n      this._stringBuffer = s;\r\n      return this;\r\n    }\r\n\r\n    /**\r\n     * 引数付きコンストラクタ\r\n     */\r\n    public constructor(s: csmString | string, isStatic: boolean) {\r\n      if ('string' === typeof s) {\r\n        super(s);\r\n      } else {\r\n        super(s);\r\n      }\r\n      this._isStatic = isStatic;\r\n    }\r\n\r\n    /**\r\n     * Valueの種類がエラー値ならtrue\r\n     */\r\n    public isError(): boolean {\r\n      return true;\r\n    }\r\n\r\n    protected _isStatic: boolean; // 静的なValueかどうか\r\n  }\r\n\r\n  /**\r\n   * パースしたJSONの要素をNULL値として持つ\r\n   */\r\n  export class JsonNullvalue extends Value {\r\n    /**\r\n     * Valueの種類がNULL値ならtrue\r\n     */\r\n    public isNull(): boolean {\r\n      return true;\r\n    }\r\n\r\n    /**\r\n     * 要素を文字列で返す(csmString型)\r\n     */\r\n    public getString(defaultValue: string, indent: string): string {\r\n      return this._stringBuffer;\r\n    }\r\n\r\n    /**\r\n     * Valueの値が静的ならtrue, 静的なら解放しない\r\n     */\r\n    public isStatic(): boolean {\r\n      return true;\r\n    }\r\n\r\n    /**\r\n     * コンストラクタ\r\n     */\r\n    public constructor() {\r\n      super();\r\n\r\n      this._stringBuffer = 'NullValue';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * パースしたJSONの要素を配列として持つ\r\n   */\r\n  export class JsonArray extends Value {\r\n    /**\r\n     * コンストラクタ\r\n     */\r\n    public constructor() {\r\n      super();\r\n      this._array = new csmVector<Value>();\r\n    }\r\n\r\n    /**\r\n     * デストラクタ相当の処理\r\n     */\r\n    public release(): void {\r\n      for (\r\n        let ite: csmVector_iterator<Value> = this._array.begin();\r\n        ite.notEqual(this._array.end());\r\n        ite.preIncrement()\r\n      ) {\r\n        let v: Value = ite.ptr();\r\n\r\n        if (v && !v.isStatic()) {\r\n          v = void 0;\r\n          v = null;\r\n        }\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Valueの種類が配列ならtrue\r\n     */\r\n    public isArray(): boolean {\r\n      return true;\r\n    }\r\n\r\n    /**\r\n     * 添字演算子[index]\r\n     */\r\n    public getValueByIndex(index: number): Value {\r\n      if (index < 0 || this._array.getSize() <= index) {\r\n        return Value.errorValue.setErrorNotForClientCall(\r\n          CSM_JSON_ERROR_INDEX_OF_BOUNDS\r\n        );\r\n      }\r\n\r\n      const v: Value = this._array.at(index);\r\n\r\n      if (v == null) {\r\n        return Value.nullValue;\r\n      }\r\n\r\n      return v;\r\n    }\r\n\r\n    /**\r\n     * 添字演算子[string | csmString]\r\n     */\r\n    public getValueByString(s: string | csmString): Value {\r\n      return Value.errorValue.setErrorNotForClientCall(\r\n        CSM_JSON_ERROR_TYPE_MISMATCH\r\n      );\r\n    }\r\n\r\n    /**\r\n     * 要素を文字列で返す(csmString型)\r\n     */\r\n    public getString(defaultValue: string, indent: string): string {\r\n      const stringBuffer: string = indent + '[\\n';\r\n\r\n      for (\r\n        let ite: csmVector_iterator<Value> = this._array.begin();\r\n        ite.notEqual(this._array.end());\r\n        ite.increment()\r\n      ) {\r\n        const v: Value = ite.ptr();\r\n        this._stringBuffer += indent + '' + v.getString(indent + ' ') + '\\n';\r\n      }\r\n\r\n      this._stringBuffer = stringBuffer + indent + ']\\n';\r\n\r\n      return this._stringBuffer;\r\n    }\r\n\r\n    /**\r\n     * 配列要素を追加する\r\n     * @param v 追加する要素\r\n     */\r\n    public add(v: Value): void {\r\n      this._array.pushBack(v);\r\n    }\r\n\r\n    /**\r\n     * 要素をコンテナで返す(csmVector<Value>)\r\n     */\r\n    public getVector(defaultValue: csmVector<Value> = null): csmVector<Value> {\r\n      return this._array;\r\n    }\r\n\r\n    /**\r\n     * 要素の数を返す\r\n     */\r\n    public getSize(): number {\r\n      return this._array.getSize();\r\n    }\r\n\r\n    private _array: csmVector<Value>; // JSON要素の値\r\n  }\r\n\r\n  /**\r\n   * パースしたJSONの要素をマップとして持つ\r\n   */\r\n  export class JsonMap extends Value {\r\n    /**\r\n     * コンストラクタ\r\n     */\r\n    public constructor() {\r\n      super();\r\n      this._map = new csmMap<string, Value>();\r\n    }\r\n\r\n    /**\r\n     * デストラクタ相当の処理\r\n     */\r\n    public release(): void {\r\n      const ite: csmMap_iterator<string, Value> = this._map.begin();\r\n\r\n      while (ite.notEqual(this._map.end())) {\r\n        let v: Value = ite.ptr().second;\r\n\r\n        if (v && !v.isStatic()) {\r\n          v = void 0;\r\n          v = null;\r\n        }\r\n\r\n        ite.preIncrement();\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Valueの値がMap型ならtrue\r\n     */\r\n    public isMap(): boolean {\r\n      return true;\r\n    }\r\n\r\n    /**\r\n     * 添字演算子[string | csmString]\r\n     */\r\n    public getValueByString(s: string | csmString): Value {\r\n      if (s instanceof csmString) {\r\n        const ret: Value = this._map.getValue(s.s);\r\n        if (ret == null) {\r\n          return Value.nullValue;\r\n        }\r\n        return ret;\r\n      }\r\n\r\n      for (\r\n        let iter: csmMap_iterator<string, Value> = this._map.begin();\r\n        iter.notEqual(this._map.end());\r\n        iter.preIncrement()\r\n      ) {\r\n        if (iter.ptr().first == s) {\r\n          if (iter.ptr().second == null) {\r\n            return Value.nullValue;\r\n          }\r\n          return iter.ptr().second;\r\n        }\r\n      }\r\n\r\n      return Value.nullValue;\r\n    }\r\n\r\n    /**\r\n     * 添字演算子[index]\r\n     */\r\n    public getValueByIndex(index: number): Value {\r\n      return Value.errorValue.setErrorNotForClientCall(\r\n        CSM_JSON_ERROR_TYPE_MISMATCH\r\n      );\r\n    }\r\n\r\n    /**\r\n     * 要素を文字列で返す(csmString型)\r\n     */\r\n    public getString(defaultValue: string, indent: string) {\r\n      this._stringBuffer = indent + '{\\n';\r\n\r\n      const ite: csmMap_iterator<string, Value> = this._map.begin();\r\n      while (ite.notEqual(this._map.end())) {\r\n        const key = ite.ptr().first;\r\n        const v: Value = ite.ptr().second;\r\n\r\n        this._stringBuffer +=\r\n          indent + ' ' + key + ' : ' + v.getString(indent + '   ') + ' \\n';\r\n        ite.preIncrement();\r\n      }\r\n\r\n      this._stringBuffer += indent + '}\\n';\r\n\r\n      return this._stringBuffer;\r\n    }\r\n\r\n    /**\r\n     * 要素をMap型で返す\r\n     */\r\n    public getMap(defaultValue?: csmMap<string, Value>): csmMap<string, Value> {\r\n      return this._map;\r\n    }\r\n\r\n    /**\r\n     * Mapに要素を追加する\r\n     */\r\n    public put(key: string, v: Value): void {\r\n      this._map.setValue(key, v);\r\n    }\r\n\r\n    /**\r\n     * Mapからキーのリストを取得する\r\n     */\r\n    public getKeys(): csmVector<string> {\r\n      if (!this._keys) {\r\n        this._keys = new csmVector<string>();\r\n\r\n        const ite: csmMap_iterator<string, Value> = this._map.begin();\r\n\r\n        while (ite.notEqual(this._map.end())) {\r\n          const key: string = ite.ptr().first;\r\n          this._keys.pushBack(key);\r\n          ite.preIncrement();\r\n        }\r\n      }\r\n      return this._keys;\r\n    }\r\n\r\n    /**\r\n     * Mapの要素数を取得する\r\n     */\r\n    public getSize(): number {\r\n      return this._keys.getSize();\r\n    }\r\n\r\n    private _map: csmMap<string, Value>; // JSON要素の値\r\n    private _keys: csmVector<string>; // JSON要素の値\r\n  }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}