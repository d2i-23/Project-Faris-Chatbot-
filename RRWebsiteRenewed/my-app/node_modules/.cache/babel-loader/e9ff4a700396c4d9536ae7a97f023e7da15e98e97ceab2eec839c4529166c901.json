{"ast":null,"code":"/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\n\nexport let s_instance = null;\nexport class LAppWavFileHandler {\n  /**\n   * クラスのインスタンス（シングルトン）を返す。\n   * インスタンスが生成されていない場合は内部でインスタンスを生成する。\n   *\n   * @return クラスのインスタンス\n   */\n  static getInstance() {\n    if (s_instance == null) {\n      s_instance = new LAppWavFileHandler();\n    }\n    return s_instance;\n  }\n\n  /**\n   * クラスのインスタンス（シングルトン）を解放する。\n   */\n  static releaseInstance() {\n    if (s_instance != null) {\n      s_instance = void 0;\n    }\n    s_instance = null;\n  }\n  update(deltaTimeSeconds) {\n    let goalOffset;\n    let rms;\n\n    // データロード前/ファイル末尾に達した場合は更新しない\n    if (this._pcmData == null || this._sampleOffset >= this._wavFileInfo._samplesPerChannel) {\n      this._lastRms = 0.0;\n      return false;\n    }\n\n    // 経過時間後の状態を保持\n    this._userTimeSeconds += deltaTimeSeconds;\n    goalOffset = Math.floor(this._userTimeSeconds * this._wavFileInfo._samplingRate);\n    if (goalOffset > this._wavFileInfo._samplesPerChannel) {\n      goalOffset = this._wavFileInfo._samplesPerChannel;\n    }\n\n    // RMS計測\n    rms = 0.0;\n    for (let channelCount = 0; channelCount < this._wavFileInfo._numberOfChannels; channelCount++) {\n      for (let sampleCount = this._sampleOffset; sampleCount < goalOffset; sampleCount++) {\n        const pcm = this._pcmData[channelCount][sampleCount];\n        rms += pcm * pcm;\n      }\n    }\n    rms = Math.sqrt(rms / (this._wavFileInfo._numberOfChannels * (goalOffset - this._sampleOffset)));\n    this._lastRms = rms;\n    this._sampleOffset = goalOffset;\n    return true;\n  }\n  start(filePath) {\n    // サンプル位参照位置を初期化\n    this._sampleOffset = 0;\n    this._userTimeSeconds = 0.0;\n\n    // RMS値をリセット\n    this._lastRms = 0.0;\n    if (!this.loadWavFile(filePath)) {\n      return;\n    }\n  }\n  getRms() {\n    return this._lastRms;\n  }\n  loadWavFile(filePath) {\n    let ret = false;\n    if (this._pcmData != null) {\n      this.releasePcmData();\n    }\n\n    // ファイルロード\n    const asyncFileLoad = async () => {\n      //! They have to fetch the filepath regardless\n\n      console.log('reached Here!');\n      var request = {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          'delete': true,\n          'token': previousSave\n        })\n      };\n      return fetch(filePath).then(responce => {\n        return responce.arrayBuffer();\n      });\n    };\n    const asyncWavFileManager = (async () => {\n      this._byteReader._fileByte = await asyncFileLoad();\n      this._byteReader._fileDataView = new DataView(this._byteReader._fileByte);\n      this._byteReader._fileSize = this._byteReader._fileByte.byteLength;\n      this._byteReader._readOffset = 0;\n\n      // ファイルロードに失敗しているか、先頭のシグネチャ\"RIFF\"を入れるサイズもない場合は失敗\n      if (this._byteReader._fileByte == null || this._byteReader._fileSize < 4) {\n        return false;\n      }\n\n      // ファイル名\n      this._wavFileInfo._fileName = filePath;\n      try {\n        // シグネチャ \"RIFF\"\n        if (!this._byteReader.getCheckSignature('RIFF')) {\n          ret = false;\n          throw new Error('Cannot find Signeture \"RIFF\".');\n        }\n        // ファイルサイズ-8（読み飛ばし）\n        this._byteReader.get32LittleEndian();\n        // シグネチャ \"WAVE\"\n        if (!this._byteReader.getCheckSignature('WAVE')) {\n          ret = false;\n          throw new Error('Cannot find Signeture \"WAVE\".');\n        }\n        // シグネチャ \"fmt \"\n        if (!this._byteReader.getCheckSignature('fmt ')) {\n          ret = false;\n          throw new Error('Cannot find Signeture \"fmt\".');\n        }\n        // fmtチャンクサイズ\n        const fmtChunkSize = this._byteReader.get32LittleEndian();\n        // フォーマットIDは1（リニアPCM）以外受け付けない\n        if (this._byteReader.get16LittleEndian() != 1) {\n          ret = false;\n          throw new Error('File is not linear PCM.');\n        }\n        // チャンネル数\n        this._wavFileInfo._numberOfChannels = this._byteReader.get16LittleEndian();\n        // サンプリングレート\n        this._wavFileInfo._samplingRate = this._byteReader.get32LittleEndian();\n        // データ速度[byte/sec]（読み飛ばし）\n        this._byteReader.get32LittleEndian();\n        // ブロックサイズ（読み飛ばし）\n        this._byteReader.get16LittleEndian();\n        // 量子化ビット数\n        this._wavFileInfo._bitsPerSample = this._byteReader.get16LittleEndian();\n        // fmtチャンクの拡張部分の読み飛ばし\n        if (fmtChunkSize > 16) {\n          this._byteReader._readOffset += fmtChunkSize - 16;\n        }\n        // \"data\"チャンクが出現するまで読み飛ばし\n        while (!this._byteReader.getCheckSignature('data') && this._byteReader._readOffset < this._byteReader._fileSize) {\n          this._byteReader._readOffset += this._byteReader.get32LittleEndian() + 4;\n        }\n        // ファイル内に\"data\"チャンクが出現しなかった\n        if (this._byteReader._readOffset >= this._byteReader._fileSize) {\n          ret = false;\n          throw new Error('Cannot find \"data\" Chunk.');\n        }\n        // サンプル数\n        {\n          const dataChunkSize = this._byteReader.get32LittleEndian();\n          this._wavFileInfo._samplesPerChannel = dataChunkSize * 8 / (this._wavFileInfo._bitsPerSample * this._wavFileInfo._numberOfChannels);\n        }\n        // 領域確保\n        this._pcmData = new Array(this._wavFileInfo._numberOfChannels);\n        for (let channelCount = 0; channelCount < this._wavFileInfo._numberOfChannels; channelCount++) {\n          this._pcmData[channelCount] = new Float32Array(this._wavFileInfo._samplesPerChannel);\n        }\n        // 波形データ取得\n        for (let sampleCount = 0; sampleCount < this._wavFileInfo._samplesPerChannel; sampleCount++) {\n          for (let channelCount = 0; channelCount < this._wavFileInfo._numberOfChannels; channelCount++) {\n            this._pcmData[channelCount][sampleCount] = this.getPcmSample();\n          }\n        }\n        ret = true;\n      } catch (e) {\n        console.log(e);\n      }\n    })();\n    return ret;\n  }\n  getPcmSample() {\n    let pcm32;\n\n    // 32ビット幅に拡張してから-1～1の範囲に丸める\n    switch (this._wavFileInfo._bitsPerSample) {\n      case 8:\n        pcm32 = this._byteReader.get8() - 128;\n        pcm32 <<= 24;\n        break;\n      case 16:\n        pcm32 = this._byteReader.get16LittleEndian() << 16;\n        break;\n      case 24:\n        pcm32 = this._byteReader.get24LittleEndian() << 8;\n        break;\n      default:\n        // 対応していないビット幅\n        pcm32 = 0;\n        break;\n    }\n    return pcm32 / 2147483647; //Number.MAX_VALUE;\n  }\n\n  releasePcmData() {\n    for (let channelCount = 0; channelCount < this._wavFileInfo._numberOfChannels; channelCount++) {\n      delete this._pcmData[channelCount];\n    }\n    delete this._pcmData;\n    this._pcmData = null;\n  }\n  constructor() {\n    this._pcmData = void 0;\n    this._userTimeSeconds = void 0;\n    this._lastRms = void 0;\n    this._sampleOffset = void 0;\n    this._wavFileInfo = void 0;\n    this._byteReader = void 0;\n    this._loadFiletoBytes = (arrayBuffer, length) => {\n      this._byteReader._fileByte = arrayBuffer;\n      this._byteReader._fileDataView = new DataView(this._byteReader._fileByte);\n      this._byteReader._fileSize = length;\n    };\n    this._pcmData = null;\n    this._userTimeSeconds = 0.0;\n    this._lastRms = 0.0;\n    this._sampleOffset = 0.0;\n    this._wavFileInfo = new WavFileInfo();\n    this._byteReader = new ByteReader();\n  }\n}\nexport class WavFileInfo {\n  constructor() {\n    this._fileName = void 0;\n    ///< ファイル名\n    this._numberOfChannels = void 0;\n    ///< チャンネル数\n    this._bitsPerSample = void 0;\n    ///< サンプルあたりビット数\n    this._samplingRate = void 0;\n    ///< サンプリングレート\n    this._samplesPerChannel = void 0;\n    this._fileName = '';\n    this._numberOfChannels = 0;\n    this._bitsPerSample = 0;\n    this._samplingRate = 0;\n    this._samplesPerChannel = 0;\n  }\n\n  ///< 1チャンネルあたり総サンプル数\n}\n\nexport class ByteReader {\n  constructor() {\n    this._fileByte = void 0;\n    ///< ロードしたファイルのバイト列\n    this._fileDataView = void 0;\n    this._fileSize = void 0;\n    ///< ファイルサイズ\n    this._readOffset = void 0;\n    this._fileByte = null;\n    this._fileDataView = null;\n    this._fileSize = 0;\n    this._readOffset = 0;\n  }\n\n  /**\n   * @brief 8ビット読み込み\n   * @return Csm::csmUint8 読み取った8ビット値\n   */\n  get8() {\n    const ret = this._fileDataView.getUint8(this._readOffset);\n    this._readOffset++;\n    return ret;\n  }\n\n  /**\n   * @brief 16ビット読み込み（リトルエンディアン）\n   * @return Csm::csmUint16 読み取った16ビット値\n   */\n  get16LittleEndian() {\n    const ret = this._fileDataView.getUint8(this._readOffset + 1) << 8 | this._fileDataView.getUint8(this._readOffset);\n    this._readOffset += 2;\n    return ret;\n  }\n\n  /**\n   * @brief 24ビット読み込み（リトルエンディアン）\n   * @return Csm::csmUint32 読み取った24ビット値（下位24ビットに設定）\n   */\n  get24LittleEndian() {\n    const ret = this._fileDataView.getUint8(this._readOffset + 2) << 16 | this._fileDataView.getUint8(this._readOffset + 1) << 8 | this._fileDataView.getUint8(this._readOffset);\n    this._readOffset += 3;\n    return ret;\n  }\n\n  /**\n   * @brief 32ビット読み込み（リトルエンディアン）\n   * @return Csm::csmUint32 読み取った32ビット値\n   */\n  get32LittleEndian() {\n    const ret = this._fileDataView.getUint8(this._readOffset + 3) << 24 | this._fileDataView.getUint8(this._readOffset + 2) << 16 | this._fileDataView.getUint8(this._readOffset + 1) << 8 | this._fileDataView.getUint8(this._readOffset);\n    this._readOffset += 4;\n    return ret;\n  }\n\n  /**\n   * @brief シグネチャの取得と参照文字列との一致チェック\n   * @param[in] reference 検査対象のシグネチャ文字列\n   * @retval  true    一致している\n   * @retval  false   一致していない\n   */\n  getCheckSignature(reference) {\n    const getSignature = new Uint8Array(4);\n    const referenceString = new TextEncoder().encode(reference);\n    if (reference.length != 4) {\n      return false;\n    }\n    for (let signatureOffset = 0; signatureOffset < 4; signatureOffset++) {\n      getSignature[signatureOffset] = this.get8();\n    }\n    return getSignature[0] == referenceString[0] && getSignature[1] == referenceString[1] && getSignature[2] == referenceString[2] && getSignature[3] == referenceString[3];\n  }\n\n  ///< ファイル参照位置\n}","map":{"version":3,"names":["s_instance","LAppWavFileHandler","getInstance","releaseInstance","update","deltaTimeSeconds","goalOffset","rms","_pcmData","_sampleOffset","_wavFileInfo","_samplesPerChannel","_lastRms","_userTimeSeconds","Math","floor","_samplingRate","channelCount","_numberOfChannels","sampleCount","pcm","sqrt","start","filePath","loadWavFile","getRms","ret","releasePcmData","asyncFileLoad","console","log","request","method","headers","body","JSON","stringify","previousSave","fetch","then","responce","arrayBuffer","asyncWavFileManager","_byteReader","_fileByte","_fileDataView","DataView","_fileSize","byteLength","_readOffset","_fileName","getCheckSignature","Error","get32LittleEndian","fmtChunkSize","get16LittleEndian","_bitsPerSample","dataChunkSize","Array","Float32Array","getPcmSample","e","pcm32","get8","get24LittleEndian","constructor","_loadFiletoBytes","length","WavFileInfo","ByteReader","getUint8","reference","getSignature","Uint8Array","referenceString","TextEncoder","encode","signatureOffset"],"sources":["C:/Users/cleyc/OneDrive/Documents/RR/RRWebsiteRenewed/my-app/src/src/lappwavfilehandler.ts"],"sourcesContent":["/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\n\nimport { LAppPal } from './lapppal';\n\nexport let s_instance: LAppWavFileHandler = null;\n\nexport class LAppWavFileHandler {\n  /**\n   * クラスのインスタンス（シングルトン）を返す。\n   * インスタンスが生成されていない場合は内部でインスタンスを生成する。\n   *\n   * @return クラスのインスタンス\n   */\n  public static getInstance(): LAppWavFileHandler {\n    if (s_instance == null) {\n      s_instance = new LAppWavFileHandler();\n    }\n\n    return s_instance;\n  }\n\n  /**\n   * クラスのインスタンス（シングルトン）を解放する。\n   */\n  public static releaseInstance(): void {\n    if (s_instance != null) {\n      s_instance = void 0;\n    }\n\n    s_instance = null;\n  }\n\n  public update(deltaTimeSeconds: number) {\n    let goalOffset: number;\n    let rms: number;\n\n    // データロード前/ファイル末尾に達した場合は更新しない\n    if (\n      this._pcmData == null ||\n      this._sampleOffset >= this._wavFileInfo._samplesPerChannel\n    ) {\n      this._lastRms = 0.0;\n      return false;\n    }\n\n    // 経過時間後の状態を保持\n    this._userTimeSeconds += deltaTimeSeconds;\n    goalOffset = Math.floor(\n      this._userTimeSeconds * this._wavFileInfo._samplingRate\n    );\n    if (goalOffset > this._wavFileInfo._samplesPerChannel) {\n      goalOffset = this._wavFileInfo._samplesPerChannel;\n    }\n\n    // RMS計測\n    rms = 0.0;\n    for (\n      let channelCount = 0;\n      channelCount < this._wavFileInfo._numberOfChannels;\n      channelCount++\n    ) {\n      for (\n        let sampleCount = this._sampleOffset;\n        sampleCount < goalOffset;\n        sampleCount++\n      ) {\n        const pcm = this._pcmData[channelCount][sampleCount];\n        rms += pcm * pcm;\n      }\n    }\n    rms = Math.sqrt(\n      rms /\n        (this._wavFileInfo._numberOfChannels *\n          (goalOffset - this._sampleOffset))\n    );\n\n    this._lastRms = rms;\n    this._sampleOffset = goalOffset;\n    return true;\n  }\n\n  public start(filePath: string): void {\n    // サンプル位参照位置を初期化\n    this._sampleOffset = 0;\n    this._userTimeSeconds = 0.0;\n\n    // RMS値をリセット\n    this._lastRms = 0.0;\n\n    if (!this.loadWavFile(filePath)) {\n      return;\n    }\n  }\n\n  public getRms(): number {\n    return this._lastRms;\n  }\n\n  public loadWavFile(filePath: string): boolean {\n    let ret = false;\n\n    if (this._pcmData != null) {\n      this.releasePcmData();\n    }\n\n    // ファイルロード\n    const asyncFileLoad = async () => {\n\n      //! They have to fetch the filepath regardless\n      \n      console.log('reached Here!')\n\n      var request = {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({'delete': true, 'token': previousSave})\n    }\n\n      \n\n      return fetch(filePath).then(responce => {\n        return responce.arrayBuffer();\n      });\n    };\n\n    const asyncWavFileManager = (async () => {\n      this._byteReader._fileByte = await asyncFileLoad();\n      this._byteReader._fileDataView = new DataView(this._byteReader._fileByte);\n      this._byteReader._fileSize = this._byteReader._fileByte.byteLength;\n      this._byteReader._readOffset = 0;\n\n      // ファイルロードに失敗しているか、先頭のシグネチャ\"RIFF\"を入れるサイズもない場合は失敗\n      if (\n        this._byteReader._fileByte == null ||\n        this._byteReader._fileSize < 4\n      ) {\n        return false;\n      }\n\n      // ファイル名\n      this._wavFileInfo._fileName = filePath;\n\n      try {\n        // シグネチャ \"RIFF\"\n        if (!this._byteReader.getCheckSignature('RIFF')) {\n          ret = false;\n          throw new Error('Cannot find Signeture \"RIFF\".');\n        }\n        // ファイルサイズ-8（読み飛ばし）\n        this._byteReader.get32LittleEndian();\n        // シグネチャ \"WAVE\"\n        if (!this._byteReader.getCheckSignature('WAVE')) {\n          ret = false;\n          throw new Error('Cannot find Signeture \"WAVE\".');\n        }\n        // シグネチャ \"fmt \"\n        if (!this._byteReader.getCheckSignature('fmt ')) {\n          ret = false;\n          throw new Error('Cannot find Signeture \"fmt\".');\n        }\n        // fmtチャンクサイズ\n        const fmtChunkSize = this._byteReader.get32LittleEndian();\n        // フォーマットIDは1（リニアPCM）以外受け付けない\n        if (this._byteReader.get16LittleEndian() != 1) {\n          ret = false;\n          throw new Error('File is not linear PCM.');\n        }\n        // チャンネル数\n        this._wavFileInfo._numberOfChannels =\n          this._byteReader.get16LittleEndian();\n        // サンプリングレート\n        this._wavFileInfo._samplingRate = this._byteReader.get32LittleEndian();\n        // データ速度[byte/sec]（読み飛ばし）\n        this._byteReader.get32LittleEndian();\n        // ブロックサイズ（読み飛ばし）\n        this._byteReader.get16LittleEndian();\n        // 量子化ビット数\n        this._wavFileInfo._bitsPerSample = this._byteReader.get16LittleEndian();\n        // fmtチャンクの拡張部分の読み飛ばし\n        if (fmtChunkSize > 16) {\n          this._byteReader._readOffset += fmtChunkSize - 16;\n        }\n        // \"data\"チャンクが出現するまで読み飛ばし\n        while (\n          !this._byteReader.getCheckSignature('data') &&\n          this._byteReader._readOffset < this._byteReader._fileSize\n        ) {\n          this._byteReader._readOffset +=\n            this._byteReader.get32LittleEndian() + 4;\n        }\n        // ファイル内に\"data\"チャンクが出現しなかった\n        if (this._byteReader._readOffset >= this._byteReader._fileSize) {\n          ret = false;\n          throw new Error('Cannot find \"data\" Chunk.');\n        }\n        // サンプル数\n        {\n          const dataChunkSize = this._byteReader.get32LittleEndian();\n          this._wavFileInfo._samplesPerChannel =\n            (dataChunkSize * 8) /\n            (this._wavFileInfo._bitsPerSample *\n              this._wavFileInfo._numberOfChannels);\n        }\n        // 領域確保\n        this._pcmData = new Array(this._wavFileInfo._numberOfChannels);\n        for (\n          let channelCount = 0;\n          channelCount < this._wavFileInfo._numberOfChannels;\n          channelCount++\n        ) {\n          this._pcmData[channelCount] = new Float32Array(\n            this._wavFileInfo._samplesPerChannel\n          );\n        }\n        // 波形データ取得\n        for (\n          let sampleCount = 0;\n          sampleCount < this._wavFileInfo._samplesPerChannel;\n          sampleCount++\n        ) {\n          for (\n            let channelCount = 0;\n            channelCount < this._wavFileInfo._numberOfChannels;\n            channelCount++\n          ) {\n            this._pcmData[channelCount][sampleCount] = this.getPcmSample();\n          }\n        }\n\n        ret = true;\n      } catch (e) {\n        console.log(e);\n      }\n    })();\n\n    return ret;\n  }\n\n  public getPcmSample(): number {\n    let pcm32;\n\n    // 32ビット幅に拡張してから-1～1の範囲に丸める\n    switch (this._wavFileInfo._bitsPerSample) {\n      case 8:\n        pcm32 = this._byteReader.get8() - 128;\n        pcm32 <<= 24;\n        break;\n      case 16:\n        pcm32 = this._byteReader.get16LittleEndian() << 16;\n        break;\n      case 24:\n        pcm32 = this._byteReader.get24LittleEndian() << 8;\n        break;\n      default:\n        // 対応していないビット幅\n        pcm32 = 0;\n        break;\n    }\n\n    return pcm32 / 2147483647; //Number.MAX_VALUE;\n  }\n\n  public releasePcmData(): void {\n    for (\n      let channelCount = 0;\n      channelCount < this._wavFileInfo._numberOfChannels;\n      channelCount++\n    ) {\n      delete this._pcmData[channelCount];\n    }\n    delete this._pcmData;\n    this._pcmData = null;\n  }\n\n  constructor() {\n    this._pcmData = null;\n    this._userTimeSeconds = 0.0;\n    this._lastRms = 0.0;\n    this._sampleOffset = 0.0;\n    this._wavFileInfo = new WavFileInfo();\n    this._byteReader = new ByteReader();\n  }\n\n  _pcmData: Array<Float32Array>;\n  _userTimeSeconds: number;\n  _lastRms: number;\n  _sampleOffset: number;\n  _wavFileInfo: WavFileInfo;\n  _byteReader: ByteReader;\n  _loadFiletoBytes = (arrayBuffer: ArrayBuffer, length: number): void => {\n    this._byteReader._fileByte = arrayBuffer;\n    this._byteReader._fileDataView = new DataView(this._byteReader._fileByte);\n    this._byteReader._fileSize = length;\n  };\n}\n\nexport class WavFileInfo {\n  constructor() {\n    this._fileName = '';\n    this._numberOfChannels = 0;\n    this._bitsPerSample = 0;\n    this._samplingRate = 0;\n    this._samplesPerChannel = 0;\n  }\n\n  _fileName: string; ///< ファイル名\n  _numberOfChannels: number; ///< チャンネル数\n  _bitsPerSample: number; ///< サンプルあたりビット数\n  _samplingRate: number; ///< サンプリングレート\n  _samplesPerChannel: number; ///< 1チャンネルあたり総サンプル数\n}\n\nexport class ByteReader {\n  constructor() {\n    this._fileByte = null;\n    this._fileDataView = null;\n    this._fileSize = 0;\n    this._readOffset = 0;\n  }\n\n  /**\n   * @brief 8ビット読み込み\n   * @return Csm::csmUint8 読み取った8ビット値\n   */\n  public get8(): number {\n    const ret = this._fileDataView.getUint8(this._readOffset);\n    this._readOffset++;\n    return ret;\n  }\n\n  /**\n   * @brief 16ビット読み込み（リトルエンディアン）\n   * @return Csm::csmUint16 読み取った16ビット値\n   */\n  public get16LittleEndian(): number {\n    const ret =\n      (this._fileDataView.getUint8(this._readOffset + 1) << 8) |\n      this._fileDataView.getUint8(this._readOffset);\n    this._readOffset += 2;\n    return ret;\n  }\n\n  /**\n   * @brief 24ビット読み込み（リトルエンディアン）\n   * @return Csm::csmUint32 読み取った24ビット値（下位24ビットに設定）\n   */\n  public get24LittleEndian(): number {\n    const ret =\n      (this._fileDataView.getUint8(this._readOffset + 2) << 16) |\n      (this._fileDataView.getUint8(this._readOffset + 1) << 8) |\n      this._fileDataView.getUint8(this._readOffset);\n    this._readOffset += 3;\n    return ret;\n  }\n\n  /**\n   * @brief 32ビット読み込み（リトルエンディアン）\n   * @return Csm::csmUint32 読み取った32ビット値\n   */\n  public get32LittleEndian(): number {\n    const ret =\n      (this._fileDataView.getUint8(this._readOffset + 3) << 24) |\n      (this._fileDataView.getUint8(this._readOffset + 2) << 16) |\n      (this._fileDataView.getUint8(this._readOffset + 1) << 8) |\n      this._fileDataView.getUint8(this._readOffset);\n    this._readOffset += 4;\n    return ret;\n  }\n\n  /**\n   * @brief シグネチャの取得と参照文字列との一致チェック\n   * @param[in] reference 検査対象のシグネチャ文字列\n   * @retval  true    一致している\n   * @retval  false   一致していない\n   */\n  public getCheckSignature(reference: string): boolean {\n    const getSignature: Uint8Array = new Uint8Array(4);\n    const referenceString: Uint8Array = new TextEncoder().encode(reference);\n    if (reference.length != 4) {\n      return false;\n    }\n    for (let signatureOffset = 0; signatureOffset < 4; signatureOffset++) {\n      getSignature[signatureOffset] = this.get8();\n    }\n    return (\n      getSignature[0] == referenceString[0] &&\n      getSignature[1] == referenceString[1] &&\n      getSignature[2] == referenceString[2] &&\n      getSignature[3] == referenceString[3]\n    );\n  }\n\n  _fileByte: ArrayBuffer; ///< ロードしたファイルのバイト列\n  _fileDataView: DataView;\n  _fileSize: number; ///< ファイルサイズ\n  _readOffset: number; ///< ファイル参照位置\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}