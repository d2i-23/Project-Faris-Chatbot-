{"ast":null,"code":"/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\n\nimport { CubismFramework } from '../live2dcubismframework';\nimport { CubismMath } from '../math/cubismmath';\nimport { csmString } from '../type/csmstring';\nimport { CSM_ASSERT, CubismLogDebug, CubismLogWarning } from '../utils/cubismdebug';\nimport { ACubismMotion } from './acubismmotion';\nimport { CubismMotionCurve, CubismMotionCurveTarget, CubismMotionData, CubismMotionEvent, CubismMotionPoint, CubismMotionSegment, CubismMotionSegmentType } from './cubismmotioninternal';\nimport { CubismMotionJson, EvaluationOptionFlag } from './cubismmotionjson';\nconst EffectNameEyeBlink = 'EyeBlink';\nconst EffectNameLipSync = 'LipSync';\nconst TargetNameModel = 'Model';\nconst TargetNameParameter = 'Parameter';\nconst TargetNamePartOpacity = 'PartOpacity';\n\n// Id\nconst IdNameOpacity = 'Opacity';\n\n/**\n * Cubism SDK R2 以前のモーションを再現させるなら true 、アニメータのモーションを正しく再現するなら false 。\n */\nconst UseOldBeziersCurveMotion = false;\nfunction lerpPoints(a, b, t) {\n  const result = new CubismMotionPoint();\n  result.time = a.time + (b.time - a.time) * t;\n  result.value = a.value + (b.value - a.value) * t;\n  return result;\n}\nfunction linearEvaluate(points, time) {\n  let t = (time - points[0].time) / (points[1].time - points[0].time);\n  if (t < 0.0) {\n    t = 0.0;\n  }\n  return points[0].value + (points[1].value - points[0].value) * t;\n}\nfunction bezierEvaluate(points, time) {\n  let t = (time - points[0].time) / (points[3].time - points[0].time);\n  if (t < 0.0) {\n    t = 0.0;\n  }\n  const p01 = lerpPoints(points[0], points[1], t);\n  const p12 = lerpPoints(points[1], points[2], t);\n  const p23 = lerpPoints(points[2], points[3], t);\n  const p012 = lerpPoints(p01, p12, t);\n  const p123 = lerpPoints(p12, p23, t);\n  return lerpPoints(p012, p123, t).value;\n}\nfunction bezierEvaluateBinarySearch(points, time) {\n  const x_error = 0.01;\n  const x = time;\n  let x1 = points[0].time;\n  let x2 = points[3].time;\n  let cx1 = points[1].time;\n  let cx2 = points[2].time;\n  let ta = 0.0;\n  let tb = 1.0;\n  let t = 0.0;\n  let i = 0;\n  for (let var33 = true; i < 20; ++i) {\n    if (x < x1 + x_error) {\n      t = ta;\n      break;\n    }\n    if (x2 - x_error < x) {\n      t = tb;\n      break;\n    }\n    let centerx = (cx1 + cx2) * 0.5;\n    cx1 = (x1 + cx1) * 0.5;\n    cx2 = (x2 + cx2) * 0.5;\n    const ctrlx12 = (cx1 + centerx) * 0.5;\n    const ctrlx21 = (cx2 + centerx) * 0.5;\n    centerx = (ctrlx12 + ctrlx21) * 0.5;\n    if (x < centerx) {\n      tb = (ta + tb) * 0.5;\n      if (centerx - x_error < x) {\n        t = tb;\n        break;\n      }\n      x2 = centerx;\n      cx2 = ctrlx12;\n    } else {\n      ta = (ta + tb) * 0.5;\n      if (x < centerx + x_error) {\n        t = ta;\n        break;\n      }\n      x1 = centerx;\n      cx1 = ctrlx21;\n    }\n  }\n  if (i == 20) {\n    t = (ta + tb) * 0.5;\n  }\n  if (t < 0.0) {\n    t = 0.0;\n  }\n  if (t > 1.0) {\n    t = 1.0;\n  }\n  const p01 = lerpPoints(points[0], points[1], t);\n  const p12 = lerpPoints(points[1], points[2], t);\n  const p23 = lerpPoints(points[2], points[3], t);\n  const p012 = lerpPoints(p01, p12, t);\n  const p123 = lerpPoints(p12, p23, t);\n  return lerpPoints(p012, p123, t).value;\n}\nfunction bezierEvaluateCardanoInterpretation(points, time) {\n  const x = time;\n  const x1 = points[0].time;\n  const x2 = points[3].time;\n  const cx1 = points[1].time;\n  const cx2 = points[2].time;\n  const a = x2 - 3.0 * cx2 + 3.0 * cx1 - x1;\n  const b = 3.0 * cx2 - 6.0 * cx1 + 3.0 * x1;\n  const c = 3.0 * cx1 - 3.0 * x1;\n  const d = x1 - x;\n  const t = CubismMath.cardanoAlgorithmForBezier(a, b, c, d);\n  const p01 = lerpPoints(points[0], points[1], t);\n  const p12 = lerpPoints(points[1], points[2], t);\n  const p23 = lerpPoints(points[2], points[3], t);\n  const p012 = lerpPoints(p01, p12, t);\n  const p123 = lerpPoints(p12, p23, t);\n  return lerpPoints(p012, p123, t).value;\n}\nfunction steppedEvaluate(points, time) {\n  return points[0].value;\n}\nfunction inverseSteppedEvaluate(points, time) {\n  return points[1].value;\n}\nfunction evaluateCurve(motionData, index, time) {\n  // Find segment to evaluate.\n  const curve = motionData.curves.at(index);\n  let target = -1;\n  const totalSegmentCount = curve.baseSegmentIndex + curve.segmentCount;\n  let pointPosition = 0;\n  for (let i = curve.baseSegmentIndex; i < totalSegmentCount; ++i) {\n    // Get first point of next segment.\n    pointPosition = motionData.segments.at(i).basePointIndex + (motionData.segments.at(i).segmentType == CubismMotionSegmentType.CubismMotionSegmentType_Bezier ? 3 : 1);\n\n    // Break if time lies within current segment.\n    if (motionData.points.at(pointPosition).time > time) {\n      target = i;\n      break;\n    }\n  }\n  if (target == -1) {\n    return motionData.points.at(pointPosition).value;\n  }\n  const segment = motionData.segments.at(target);\n  return segment.evaluate(motionData.points.get(segment.basePointIndex), time);\n}\n\n/**\n * モーションクラス\n *\n * モーションのクラス。\n */\nexport class CubismMotion extends ACubismMotion {\n  /**\n   * インスタンスを作成する\n   *\n   * @param buffer motion3.jsonが読み込まれているバッファ\n   * @param size バッファのサイズ\n   * @param onFinishedMotionHandler モーション再生終了時に呼び出されるコールバック関数\n   * @return 作成されたインスタンス\n   */\n  static create(buffer, size, onFinishedMotionHandler) {\n    const ret = new CubismMotion();\n    ret.parse(buffer, size);\n    ret._sourceFrameRate = ret._motionData.fps;\n    ret._loopDurationSeconds = ret._motionData.duration;\n    ret._onFinishedMotion = onFinishedMotionHandler;\n\n    // NOTE: Editorではループありのモーション書き出しは非対応\n    // ret->_loop = (ret->_motionData->Loop > 0);\n    return ret;\n  }\n\n  /**\n   * モデルのパラメータの更新の実行\n   * @param model             対象のモデル\n   * @param userTimeSeconds   現在の時刻[秒]\n   * @param fadeWeight        モーションの重み\n   * @param motionQueueEntry  CubismMotionQueueManagerで管理されているモーション\n   */\n  doUpdateParameters(model, userTimeSeconds, fadeWeight, motionQueueEntry) {\n    if (this._modelCurveIdEyeBlink == null) {\n      this._modelCurveIdEyeBlink = CubismFramework.getIdManager().getId(EffectNameEyeBlink);\n    }\n    if (this._modelCurveIdLipSync == null) {\n      this._modelCurveIdLipSync = CubismFramework.getIdManager().getId(EffectNameLipSync);\n    }\n    if (this._modelCurveIdOpacity == null) {\n      this._modelCurveIdOpacity = CubismFramework.getIdManager().getId(IdNameOpacity);\n    }\n    let timeOffsetSeconds = userTimeSeconds - motionQueueEntry.getStartTime();\n    if (timeOffsetSeconds < 0.0) {\n      timeOffsetSeconds = 0.0; // エラー回避\n    }\n\n    let lipSyncValue = Number.MAX_VALUE;\n    let eyeBlinkValue = Number.MAX_VALUE;\n\n    //まばたき、リップシンクのうちモーションの適用を検出するためのビット（maxFlagCount個まで\n    const MaxTargetSize = 64;\n    let lipSyncFlags = 0;\n    let eyeBlinkFlags = 0;\n\n    //瞬き、リップシンクのターゲット数が上限を超えている場合\n    if (this._eyeBlinkParameterIds.getSize() > MaxTargetSize) {\n      CubismLogDebug('too many eye blink targets : {0}', this._eyeBlinkParameterIds.getSize());\n    }\n    if (this._lipSyncParameterIds.getSize() > MaxTargetSize) {\n      CubismLogDebug('too many lip sync targets : {0}', this._lipSyncParameterIds.getSize());\n    }\n    const tmpFadeIn = this._fadeInSeconds <= 0.0 ? 1.0 : CubismMath.getEasingSine((userTimeSeconds - motionQueueEntry.getFadeInStartTime()) / this._fadeInSeconds);\n    const tmpFadeOut = this._fadeOutSeconds <= 0.0 || motionQueueEntry.getEndTime() < 0.0 ? 1.0 : CubismMath.getEasingSine((motionQueueEntry.getEndTime() - userTimeSeconds) / this._fadeOutSeconds);\n    let value;\n    let c, parameterIndex;\n\n    // 'Repeat' time as necessary.\n    let time = timeOffsetSeconds;\n    if (this._isLoop) {\n      while (time > this._motionData.duration) {\n        time -= this._motionData.duration;\n      }\n    }\n    const curves = this._motionData.curves;\n\n    // Evaluate model curves.\n    for (c = 0; c < this._motionData.curveCount && curves.at(c).type == CubismMotionCurveTarget.CubismMotionCurveTarget_Model; ++c) {\n      // Evaluate curve and call handler.\n      value = evaluateCurve(this._motionData, c, time);\n      if (curves.at(c).id == this._modelCurveIdEyeBlink) {\n        eyeBlinkValue = value;\n      } else if (curves.at(c).id == this._modelCurveIdLipSync) {\n        lipSyncValue = value;\n      } else if (curves.at(c).id == this._modelCurveIdOpacity) {\n        this._modelOpacity = value;\n        model.setModelOapcity(this.getModelOpacityValue());\n      }\n    }\n    let parameterMotionCurveCount = 0;\n    for (; c < this._motionData.curveCount && curves.at(c).type == CubismMotionCurveTarget.CubismMotionCurveTarget_Parameter; ++c) {\n      parameterMotionCurveCount++;\n\n      // Find parameter index.\n      parameterIndex = model.getParameterIndex(curves.at(c).id);\n\n      // Skip curve evaluation if no value in sink.\n      if (parameterIndex == -1) {\n        continue;\n      }\n      const sourceValue = model.getParameterValueByIndex(parameterIndex);\n\n      // Evaluate curve and apply value.\n      value = evaluateCurve(this._motionData, c, time);\n      if (eyeBlinkValue != Number.MAX_VALUE) {\n        for (let i = 0; i < this._eyeBlinkParameterIds.getSize() && i < MaxTargetSize; ++i) {\n          if (this._eyeBlinkParameterIds.at(i) == curves.at(c).id) {\n            value *= eyeBlinkValue;\n            eyeBlinkFlags |= 1 << i;\n            break;\n          }\n        }\n      }\n      if (lipSyncValue != Number.MAX_VALUE) {\n        for (let i = 0; i < this._lipSyncParameterIds.getSize() && i < MaxTargetSize; ++i) {\n          if (this._lipSyncParameterIds.at(i) == curves.at(c).id) {\n            value += lipSyncValue;\n            lipSyncFlags |= 1 << i;\n            break;\n          }\n        }\n      }\n      let v;\n\n      // パラメータごとのフェード\n      if (curves.at(c).fadeInTime < 0.0 && curves.at(c).fadeOutTime < 0.0) {\n        // モーションのフェードを適用\n        v = sourceValue + (value - sourceValue) * fadeWeight;\n      } else {\n        // パラメータに対してフェードインかフェードアウトが設定してある場合はそちらを適用\n        let fin;\n        let fout;\n        if (curves.at(c).fadeInTime < 0.0) {\n          fin = tmpFadeIn;\n        } else {\n          fin = curves.at(c).fadeInTime == 0.0 ? 1.0 : CubismMath.getEasingSine((userTimeSeconds - motionQueueEntry.getFadeInStartTime()) / curves.at(c).fadeInTime);\n        }\n        if (curves.at(c).fadeOutTime < 0.0) {\n          fout = tmpFadeOut;\n        } else {\n          fout = curves.at(c).fadeOutTime == 0.0 || motionQueueEntry.getEndTime() < 0.0 ? 1.0 : CubismMath.getEasingSine((motionQueueEntry.getEndTime() - userTimeSeconds) / curves.at(c).fadeOutTime);\n        }\n        const paramWeight = this._weight * fin * fout;\n\n        // パラメータごとのフェードを適用\n        v = sourceValue + (value - sourceValue) * paramWeight;\n      }\n      model.setParameterValueByIndex(parameterIndex, v, 1.0);\n    }\n    {\n      if (eyeBlinkValue != Number.MAX_VALUE) {\n        for (let i = 0; i < this._eyeBlinkParameterIds.getSize() && i < MaxTargetSize; ++i) {\n          const sourceValue = model.getParameterValueById(this._eyeBlinkParameterIds.at(i));\n\n          // モーションでの上書きがあった時にはまばたきは適用しない\n          if (eyeBlinkFlags >> i & 0x01) {\n            continue;\n          }\n          const v = sourceValue + (eyeBlinkValue - sourceValue) * fadeWeight;\n          model.setParameterValueById(this._eyeBlinkParameterIds.at(i), v);\n        }\n      }\n      if (lipSyncValue != Number.MAX_VALUE) {\n        for (let i = 0; i < this._lipSyncParameterIds.getSize() && i < MaxTargetSize; ++i) {\n          const sourceValue = model.getParameterValueById(this._lipSyncParameterIds.at(i));\n\n          // モーションでの上書きがあった時にはリップシンクは適用しない\n          if (lipSyncFlags >> i & 0x01) {\n            continue;\n          }\n          const v = sourceValue + (lipSyncValue - sourceValue) * fadeWeight;\n          model.setParameterValueById(this._lipSyncParameterIds.at(i), v);\n        }\n      }\n    }\n    for (; c < this._motionData.curveCount && curves.at(c).type == CubismMotionCurveTarget.CubismMotionCurveTarget_PartOpacity; ++c) {\n      // Find parameter index.\n      parameterIndex = model.getParameterIndex(curves.at(c).id);\n\n      // Skip curve evaluation if no value in sink.\n      if (parameterIndex == -1) {\n        continue;\n      }\n\n      // Evaluate curve and apply value.\n      value = evaluateCurve(this._motionData, c, time);\n      model.setParameterValueByIndex(parameterIndex, value);\n    }\n    if (timeOffsetSeconds >= this._motionData.duration) {\n      if (this._isLoop) {\n        motionQueueEntry.setStartTime(userTimeSeconds); // 最初の状態へ\n        if (this._isLoopFadeIn) {\n          // ループ内でループ用フェードインが有効の時は、フェードイン設定し直し\n          motionQueueEntry.setFadeInStartTime(userTimeSeconds);\n        }\n      } else {\n        if (this._onFinishedMotion) {\n          this._onFinishedMotion(this);\n        }\n        motionQueueEntry.setIsFinished(true);\n      }\n    }\n    this._lastWeight = fadeWeight;\n  }\n\n  /**\n   * ループ情報の設定\n   * @param loop ループ情報\n   */\n  setIsLoop(loop) {\n    this._isLoop = loop;\n  }\n\n  /**\n   * ループ情報の取得\n   * @return true ループする\n   * @return false ループしない\n   */\n  isLoop() {\n    return this._isLoop;\n  }\n\n  /**\n   * ループ時のフェードイン情報の設定\n   * @param loopFadeIn  ループ時のフェードイン情報\n   */\n  setIsLoopFadeIn(loopFadeIn) {\n    this._isLoopFadeIn = loopFadeIn;\n  }\n\n  /**\n   * ループ時のフェードイン情報の取得\n   *\n   * @return  true    する\n   * @return  false   しない\n   */\n  isLoopFadeIn() {\n    return this._isLoopFadeIn;\n  }\n\n  /**\n   * モーションの長さを取得する。\n   *\n   * @return  モーションの長さ[秒]\n   */\n  getDuration() {\n    return this._isLoop ? -1.0 : this._loopDurationSeconds;\n  }\n\n  /**\n   * モーションのループ時の長さを取得する。\n   *\n   * @return  モーションのループ時の長さ[秒]\n   */\n  getLoopDuration() {\n    return this._loopDurationSeconds;\n  }\n\n  /**\n   * パラメータに対するフェードインの時間を設定する。\n   *\n   * @param parameterId     パラメータID\n   * @param value           フェードインにかかる時間[秒]\n   */\n  setParameterFadeInTime(parameterId, value) {\n    const curves = this._motionData.curves;\n    for (let i = 0; i < this._motionData.curveCount; ++i) {\n      if (parameterId == curves.at(i).id) {\n        curves.at(i).fadeInTime = value;\n        return;\n      }\n    }\n  }\n\n  /**\n   * パラメータに対するフェードアウトの時間の設定\n   * @param parameterId     パラメータID\n   * @param value           フェードアウトにかかる時間[秒]\n   */\n  setParameterFadeOutTime(parameterId, value) {\n    const curves = this._motionData.curves;\n    for (let i = 0; i < this._motionData.curveCount; ++i) {\n      if (parameterId == curves.at(i).id) {\n        curves.at(i).fadeOutTime = value;\n        return;\n      }\n    }\n  }\n\n  /**\n   * パラメータに対するフェードインの時間の取得\n   * @param    parameterId     パラメータID\n   * @return   フェードインにかかる時間[秒]\n   */\n  getParameterFadeInTime(parameterId) {\n    const curves = this._motionData.curves;\n    for (let i = 0; i < this._motionData.curveCount; ++i) {\n      if (parameterId == curves.at(i).id) {\n        return curves.at(i).fadeInTime;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * パラメータに対するフェードアウトの時間を取得\n   *\n   * @param   parameterId     パラメータID\n   * @return   フェードアウトにかかる時間[秒]\n   */\n  getParameterFadeOutTime(parameterId) {\n    const curves = this._motionData.curves;\n    for (let i = 0; i < this._motionData.curveCount; ++i) {\n      if (parameterId == curves.at(i).id) {\n        return curves.at(i).fadeOutTime;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * 自動エフェクトがかかっているパラメータIDリストの設定\n   * @param eyeBlinkParameterIds    自動まばたきがかかっているパラメータIDのリスト\n   * @param lipSyncParameterIds     リップシンクがかかっているパラメータIDのリスト\n   */\n  setEffectIds(eyeBlinkParameterIds, lipSyncParameterIds) {\n    this._eyeBlinkParameterIds = eyeBlinkParameterIds;\n    this._lipSyncParameterIds = lipSyncParameterIds;\n  }\n\n  /**\n   * コンストラクタ\n   */\n  constructor() {\n    super();\n    this._sourceFrameRate = void 0;\n    // ロードしたファイルのFPS。記述が無ければデフォルト値15fpsとなる\n    this._loopDurationSeconds = void 0;\n    // mtnファイルで定義される一連のモーションの長さ\n    this._isLoop = void 0;\n    // ループするか?\n    this._isLoopFadeIn = void 0;\n    // ループ時にフェードインが有効かどうかのフラグ。初期値では有効。\n    this._lastWeight = void 0;\n    // 最後に設定された重み\n    this._motionData = void 0;\n    // 実際のモーションデータ本体\n    this._eyeBlinkParameterIds = void 0;\n    // 自動まばたきを適用するパラメータIDハンドルのリスト。  モデル（モデルセッティング）とパラメータを対応付ける。\n    this._lipSyncParameterIds = void 0;\n    // リップシンクを適用するパラメータIDハンドルのリスト。  モデル（モデルセッティング）とパラメータを対応付ける。\n    this._modelCurveIdEyeBlink = void 0;\n    // モデルが持つ自動まばたき用パラメータIDのハンドル。  モデルとモーションを対応付ける。\n    this._modelCurveIdLipSync = void 0;\n    // モデルが持つリップシンク用パラメータIDのハンドル。  モデルとモーションを対応付ける。\n    this._modelCurveIdOpacity = void 0;\n    // モデルが持つ不透明度用パラメータIDのハンドル。  モデルとモーションを対応付ける。\n    this._modelOpacity = void 0;\n    this._sourceFrameRate = 30.0;\n    this._loopDurationSeconds = -1.0;\n    this._isLoop = false; // trueから false へデフォルトを変更\n    this._isLoopFadeIn = true; // ループ時にフェードインが有効かどうかのフラグ\n    this._lastWeight = 0.0;\n    this._motionData = null;\n    this._modelCurveIdEyeBlink = null;\n    this._modelCurveIdLipSync = null;\n    this._modelCurveIdOpacity = null;\n    this._eyeBlinkParameterIds = null;\n    this._lipSyncParameterIds = null;\n    this._modelOpacity = 1.0;\n  }\n\n  /**\n   * デストラクタ相当の処理\n   */\n  release() {\n    this._motionData = void 0;\n    this._motionData = null;\n  }\n\n  /**\n   * motion3.jsonをパースする。\n   *\n   * @param motionJson  motion3.jsonが読み込まれているバッファ\n   * @param size        バッファのサイズ\n   */\n  parse(motionJson, size) {\n    this._motionData = new CubismMotionData();\n    let json = new CubismMotionJson(motionJson, size);\n    this._motionData.duration = json.getMotionDuration();\n    this._motionData.loop = json.isMotionLoop();\n    this._motionData.curveCount = json.getMotionCurveCount();\n    this._motionData.fps = json.getMotionFps();\n    this._motionData.eventCount = json.getEventCount();\n    const areBeziersRestructed = json.getEvaluationOptionFlag(EvaluationOptionFlag.EvaluationOptionFlag_AreBeziersRistricted);\n    if (json.isExistMotionFadeInTime()) {\n      this._fadeInSeconds = json.getMotionFadeInTime() < 0.0 ? 1.0 : json.getMotionFadeInTime();\n    } else {\n      this._fadeInSeconds = 1.0;\n    }\n    if (json.isExistMotionFadeOutTime()) {\n      this._fadeOutSeconds = json.getMotionFadeOutTime() < 0.0 ? 1.0 : json.getMotionFadeOutTime();\n    } else {\n      this._fadeOutSeconds = 1.0;\n    }\n    this._motionData.curves.updateSize(this._motionData.curveCount, CubismMotionCurve, true);\n    this._motionData.segments.updateSize(json.getMotionTotalSegmentCount(), CubismMotionSegment, true);\n    this._motionData.points.updateSize(json.getMotionTotalPointCount(), CubismMotionPoint, true);\n    this._motionData.events.updateSize(this._motionData.eventCount, CubismMotionEvent, true);\n    let totalPointCount = 0;\n    let totalSegmentCount = 0;\n\n    // Curves\n    for (let curveCount = 0; curveCount < this._motionData.curveCount; ++curveCount) {\n      if (json.getMotionCurveTarget(curveCount) == TargetNameModel) {\n        this._motionData.curves.at(curveCount).type = CubismMotionCurveTarget.CubismMotionCurveTarget_Model;\n      } else if (json.getMotionCurveTarget(curveCount) == TargetNameParameter) {\n        this._motionData.curves.at(curveCount).type = CubismMotionCurveTarget.CubismMotionCurveTarget_Parameter;\n      } else if (json.getMotionCurveTarget(curveCount) == TargetNamePartOpacity) {\n        this._motionData.curves.at(curveCount).type = CubismMotionCurveTarget.CubismMotionCurveTarget_PartOpacity;\n      } else {\n        CubismLogWarning('Warning : Unable to get segment type from Curve! The number of \"CurveCount\" may be incorrect!');\n      }\n      this._motionData.curves.at(curveCount).id = json.getMotionCurveId(curveCount);\n      this._motionData.curves.at(curveCount).baseSegmentIndex = totalSegmentCount;\n      this._motionData.curves.at(curveCount).fadeInTime = json.isExistMotionCurveFadeInTime(curveCount) ? json.getMotionCurveFadeInTime(curveCount) : -1.0;\n      this._motionData.curves.at(curveCount).fadeOutTime = json.isExistMotionCurveFadeOutTime(curveCount) ? json.getMotionCurveFadeOutTime(curveCount) : -1.0;\n\n      // Segments\n      for (let segmentPosition = 0; segmentPosition < json.getMotionCurveSegmentCount(curveCount);) {\n        if (segmentPosition == 0) {\n          this._motionData.segments.at(totalSegmentCount).basePointIndex = totalPointCount;\n          this._motionData.points.at(totalPointCount).time = json.getMotionCurveSegment(curveCount, segmentPosition);\n          this._motionData.points.at(totalPointCount).value = json.getMotionCurveSegment(curveCount, segmentPosition + 1);\n          totalPointCount += 1;\n          segmentPosition += 2;\n        } else {\n          this._motionData.segments.at(totalSegmentCount).basePointIndex = totalPointCount - 1;\n        }\n        const segment = json.getMotionCurveSegment(curveCount, segmentPosition);\n        switch (segment) {\n          case CubismMotionSegmentType.CubismMotionSegmentType_Linear:\n            {\n              this._motionData.segments.at(totalSegmentCount).segmentType = CubismMotionSegmentType.CubismMotionSegmentType_Linear;\n              this._motionData.segments.at(totalSegmentCount).evaluate = linearEvaluate;\n              this._motionData.points.at(totalPointCount).time = json.getMotionCurveSegment(curveCount, segmentPosition + 1);\n              this._motionData.points.at(totalPointCount).value = json.getMotionCurveSegment(curveCount, segmentPosition + 2);\n              totalPointCount += 1;\n              segmentPosition += 3;\n              break;\n            }\n          case CubismMotionSegmentType.CubismMotionSegmentType_Bezier:\n            {\n              this._motionData.segments.at(totalSegmentCount).segmentType = CubismMotionSegmentType.CubismMotionSegmentType_Bezier;\n              if (areBeziersRestructed || UseOldBeziersCurveMotion) {\n                this._motionData.segments.at(totalSegmentCount).evaluate = bezierEvaluate;\n              } else {\n                this._motionData.segments.at(totalSegmentCount).evaluate = bezierEvaluateCardanoInterpretation;\n              }\n              this._motionData.points.at(totalPointCount).time = json.getMotionCurveSegment(curveCount, segmentPosition + 1);\n              this._motionData.points.at(totalPointCount).value = json.getMotionCurveSegment(curveCount, segmentPosition + 2);\n              this._motionData.points.at(totalPointCount + 1).time = json.getMotionCurveSegment(curveCount, segmentPosition + 3);\n              this._motionData.points.at(totalPointCount + 1).value = json.getMotionCurveSegment(curveCount, segmentPosition + 4);\n              this._motionData.points.at(totalPointCount + 2).time = json.getMotionCurveSegment(curveCount, segmentPosition + 5);\n              this._motionData.points.at(totalPointCount + 2).value = json.getMotionCurveSegment(curveCount, segmentPosition + 6);\n              totalPointCount += 3;\n              segmentPosition += 7;\n              break;\n            }\n          case CubismMotionSegmentType.CubismMotionSegmentType_Stepped:\n            {\n              this._motionData.segments.at(totalSegmentCount).segmentType = CubismMotionSegmentType.CubismMotionSegmentType_Stepped;\n              this._motionData.segments.at(totalSegmentCount).evaluate = steppedEvaluate;\n              this._motionData.points.at(totalPointCount).time = json.getMotionCurveSegment(curveCount, segmentPosition + 1);\n              this._motionData.points.at(totalPointCount).value = json.getMotionCurveSegment(curveCount, segmentPosition + 2);\n              totalPointCount += 1;\n              segmentPosition += 3;\n              break;\n            }\n          case CubismMotionSegmentType.CubismMotionSegmentType_InverseStepped:\n            {\n              this._motionData.segments.at(totalSegmentCount).segmentType = CubismMotionSegmentType.CubismMotionSegmentType_InverseStepped;\n              this._motionData.segments.at(totalSegmentCount).evaluate = inverseSteppedEvaluate;\n              this._motionData.points.at(totalPointCount).time = json.getMotionCurveSegment(curveCount, segmentPosition + 1);\n              this._motionData.points.at(totalPointCount).value = json.getMotionCurveSegment(curveCount, segmentPosition + 2);\n              totalPointCount += 1;\n              segmentPosition += 3;\n              break;\n            }\n          default:\n            {\n              CSM_ASSERT(0);\n              break;\n            }\n        }\n        ++this._motionData.curves.at(curveCount).segmentCount;\n        ++totalSegmentCount;\n      }\n    }\n    for (let userdatacount = 0; userdatacount < json.getEventCount(); ++userdatacount) {\n      this._motionData.events.at(userdatacount).fireTime = json.getEventTime(userdatacount);\n      this._motionData.events.at(userdatacount).value = json.getEventValue(userdatacount);\n    }\n    json.release();\n    json = void 0;\n    json = null;\n  }\n\n  /**\n   * モデルのパラメータ更新\n   *\n   * イベント発火のチェック。\n   * 入力する時間は呼ばれるモーションタイミングを０とした秒数で行う。\n   *\n   * @param beforeCheckTimeSeconds   前回のイベントチェック時間[秒]\n   * @param motionTimeSeconds        今回の再生時間[秒]\n   */\n  getFiredEvent(beforeCheckTimeSeconds, motionTimeSeconds) {\n    this._firedEventValues.updateSize(0);\n\n    // イベントの発火チェック\n    for (let u = 0; u < this._motionData.eventCount; ++u) {\n      if (this._motionData.events.at(u).fireTime > beforeCheckTimeSeconds && this._motionData.events.at(u).fireTime <= motionTimeSeconds) {\n        this._firedEventValues.pushBack(new csmString(this._motionData.events.at(u).value.s));\n      }\n    }\n    return this._firedEventValues;\n  }\n\n  /**\n   * 透明度のカーブが存在するかどうかを確認する\n   *\n   * @returns true  -> キーが存在する\n   *          false -> キーが存在しない\n   */\n  isExistModelOpacity() {\n    for (let i = 0; i < this._motionData.curveCount; i++) {\n      const curve = this._motionData.curves.at(i);\n      if (curve.type != CubismMotionCurveTarget.CubismMotionCurveTarget_Model) {\n        continue;\n      }\n      if (curve.id.getString().s.localeCompare(IdNameOpacity) == 0) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * 透明度のカーブのインデックスを返す\n   *\n   * @returns success:透明度のカーブのインデックス\n   */\n  getModelOpacityIndex() {\n    if (this.isExistModelOpacity()) {\n      for (let i = 0; i < this._motionData.curveCount; i++) {\n        const curve = this._motionData.curves.at(i);\n        if (curve.type != CubismMotionCurveTarget.CubismMotionCurveTarget_Model) {\n          continue;\n        }\n        if (curve.id.getString().s.localeCompare(IdNameOpacity) == 0) {\n          return i;\n        }\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * 透明度のIdを返す\n   *\n   * @param index モーションカーブのインデックス\n   * @returns success:透明度のカーブのインデックス\n   */\n  getModelOpacityId(index) {\n    if (index != -1) {\n      const curve = this._motionData.curves.at(index);\n      if (curve.type == CubismMotionCurveTarget.CubismMotionCurveTarget_Model) {\n        if (curve.id.getString().s.localeCompare(IdNameOpacity) == 0) {\n          return CubismFramework.getIdManager().getId(curve.id.getString().s);\n        }\n      }\n    }\n    return null;\n  }\n\n  /**\n   * 現在時間の透明度の値を返す\n   *\n   * @returns success:モーションの当該時間におけるOpacityの値\n   */\n  getModelOpacityValue() {\n    return this._modelOpacity;\n  }\n\n  // モーションから取得した不透明度\n}\n\n// Namespace definition for compatibility.\nimport * as $ from './cubismmotion';\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport let Live2DCubismFramework;\n(function (_Live2DCubismFramework) {\n  const CubismMotion = _Live2DCubismFramework.CubismMotion = $.CubismMotion;\n})(Live2DCubismFramework || (Live2DCubismFramework = {}));","map":{"version":3,"names":["CubismFramework","CubismMath","csmString","CSM_ASSERT","CubismLogDebug","CubismLogWarning","ACubismMotion","CubismMotionCurve","CubismMotionCurveTarget","CubismMotionData","CubismMotionEvent","CubismMotionPoint","CubismMotionSegment","CubismMotionSegmentType","CubismMotionJson","EvaluationOptionFlag","EffectNameEyeBlink","EffectNameLipSync","TargetNameModel","TargetNameParameter","TargetNamePartOpacity","IdNameOpacity","UseOldBeziersCurveMotion","lerpPoints","a","b","t","result","time","value","linearEvaluate","points","bezierEvaluate","p01","p12","p23","p012","p123","bezierEvaluateBinarySearch","x_error","x","x1","x2","cx1","cx2","ta","tb","i","var33","centerx","ctrlx12","ctrlx21","bezierEvaluateCardanoInterpretation","c","d","cardanoAlgorithmForBezier","steppedEvaluate","inverseSteppedEvaluate","evaluateCurve","motionData","index","curve","curves","at","target","totalSegmentCount","baseSegmentIndex","segmentCount","pointPosition","segments","basePointIndex","segmentType","CubismMotionSegmentType_Bezier","segment","evaluate","get","CubismMotion","create","buffer","size","onFinishedMotionHandler","ret","parse","_sourceFrameRate","_motionData","fps","_loopDurationSeconds","duration","_onFinishedMotion","doUpdateParameters","model","userTimeSeconds","fadeWeight","motionQueueEntry","_modelCurveIdEyeBlink","getIdManager","getId","_modelCurveIdLipSync","_modelCurveIdOpacity","timeOffsetSeconds","getStartTime","lipSyncValue","Number","MAX_VALUE","eyeBlinkValue","MaxTargetSize","lipSyncFlags","eyeBlinkFlags","_eyeBlinkParameterIds","getSize","_lipSyncParameterIds","tmpFadeIn","_fadeInSeconds","getEasingSine","getFadeInStartTime","tmpFadeOut","_fadeOutSeconds","getEndTime","parameterIndex","_isLoop","curveCount","type","CubismMotionCurveTarget_Model","id","_modelOpacity","setModelOapcity","getModelOpacityValue","parameterMotionCurveCount","CubismMotionCurveTarget_Parameter","getParameterIndex","sourceValue","getParameterValueByIndex","v","fadeInTime","fadeOutTime","fin","fout","paramWeight","_weight","setParameterValueByIndex","getParameterValueById","setParameterValueById","CubismMotionCurveTarget_PartOpacity","setStartTime","_isLoopFadeIn","setFadeInStartTime","setIsFinished","_lastWeight","setIsLoop","loop","isLoop","setIsLoopFadeIn","loopFadeIn","isLoopFadeIn","getDuration","getLoopDuration","setParameterFadeInTime","parameterId","setParameterFadeOutTime","getParameterFadeInTime","getParameterFadeOutTime","setEffectIds","eyeBlinkParameterIds","lipSyncParameterIds","constructor","release","motionJson","json","getMotionDuration","isMotionLoop","getMotionCurveCount","getMotionFps","eventCount","getEventCount","areBeziersRestructed","getEvaluationOptionFlag","EvaluationOptionFlag_AreBeziersRistricted","isExistMotionFadeInTime","getMotionFadeInTime","isExistMotionFadeOutTime","getMotionFadeOutTime","updateSize","getMotionTotalSegmentCount","getMotionTotalPointCount","events","totalPointCount","getMotionCurveTarget","getMotionCurveId","isExistMotionCurveFadeInTime","getMotionCurveFadeInTime","isExistMotionCurveFadeOutTime","getMotionCurveFadeOutTime","segmentPosition","getMotionCurveSegmentCount","getMotionCurveSegment","CubismMotionSegmentType_Linear","CubismMotionSegmentType_Stepped","CubismMotionSegmentType_InverseStepped","userdatacount","fireTime","getEventTime","getEventValue","getFiredEvent","beforeCheckTimeSeconds","motionTimeSeconds","_firedEventValues","u","pushBack","s","isExistModelOpacity","getString","localeCompare","getModelOpacityIndex","getModelOpacityId","$","Live2DCubismFramework","_Live2DCubismFramework"],"sources":["C:/Users/cleyc/OneDrive/Documents/RR/RRWebsiteRenewed/my-app/src/Framework/src/motion/cubismmotion.ts"],"sourcesContent":["/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\n\nimport { CubismIdHandle } from '../id/cubismid';\nimport { CubismFramework } from '../live2dcubismframework';\nimport { CubismMath } from '../math/cubismmath';\nimport { CubismModel } from '../model/cubismmodel';\nimport { csmString } from '../type/csmstring';\nimport { csmVector } from '../type/csmvector';\nimport {\n  CSM_ASSERT,\n  CubismLogDebug,\n  CubismLogWarning,\n} from '../utils/cubismdebug';\nimport { ACubismMotion, FinishedMotionCallback } from './acubismmotion';\nimport {\n  CubismMotionCurve,\n  CubismMotionCurveTarget,\n  CubismMotionData,\n  CubismMotionEvent,\n  CubismMotionPoint,\n  CubismMotionSegment,\n  CubismMotionSegmentType,\n} from './cubismmotioninternal';\nimport { CubismMotionJson, EvaluationOptionFlag } from './cubismmotionjson';\nimport { CubismMotionQueueEntry } from './cubismmotionqueueentry';\n\nconst EffectNameEyeBlink = 'EyeBlink';\nconst EffectNameLipSync = 'LipSync';\nconst TargetNameModel = 'Model';\nconst TargetNameParameter = 'Parameter';\nconst TargetNamePartOpacity = 'PartOpacity';\n\n// Id\nconst IdNameOpacity = 'Opacity';\n\n/**\n * Cubism SDK R2 以前のモーションを再現させるなら true 、アニメータのモーションを正しく再現するなら false 。\n */\nconst UseOldBeziersCurveMotion = false;\n\nfunction lerpPoints(\n  a: CubismMotionPoint,\n  b: CubismMotionPoint,\n  t: number\n): CubismMotionPoint {\n  const result: CubismMotionPoint = new CubismMotionPoint();\n\n  result.time = a.time + (b.time - a.time) * t;\n  result.value = a.value + (b.value - a.value) * t;\n\n  return result;\n}\n\nfunction linearEvaluate(points: CubismMotionPoint[], time: number): number {\n  let t: number = (time - points[0].time) / (points[1].time - points[0].time);\n\n  if (t < 0.0) {\n    t = 0.0;\n  }\n\n  return points[0].value + (points[1].value - points[0].value) * t;\n}\n\nfunction bezierEvaluate(points: CubismMotionPoint[], time: number): number {\n  let t: number = (time - points[0].time) / (points[3].time - points[0].time);\n\n  if (t < 0.0) {\n    t = 0.0;\n  }\n\n  const p01: CubismMotionPoint = lerpPoints(points[0], points[1], t);\n  const p12: CubismMotionPoint = lerpPoints(points[1], points[2], t);\n  const p23: CubismMotionPoint = lerpPoints(points[2], points[3], t);\n\n  const p012: CubismMotionPoint = lerpPoints(p01, p12, t);\n  const p123: CubismMotionPoint = lerpPoints(p12, p23, t);\n\n  return lerpPoints(p012, p123, t).value;\n}\n\nfunction bezierEvaluateBinarySearch(\n  points: CubismMotionPoint[],\n  time: number\n): number {\n  const x_error = 0.01;\n\n  const x: number = time;\n  let x1: number = points[0].time;\n  let x2: number = points[3].time;\n  let cx1: number = points[1].time;\n  let cx2: number = points[2].time;\n\n  let ta = 0.0;\n  let tb = 1.0;\n  let t = 0.0;\n  let i = 0;\n\n  for (let var33 = true; i < 20; ++i) {\n    if (x < x1 + x_error) {\n      t = ta;\n      break;\n    }\n\n    if (x2 - x_error < x) {\n      t = tb;\n      break;\n    }\n\n    let centerx: number = (cx1 + cx2) * 0.5;\n    cx1 = (x1 + cx1) * 0.5;\n    cx2 = (x2 + cx2) * 0.5;\n    const ctrlx12: number = (cx1 + centerx) * 0.5;\n    const ctrlx21: number = (cx2 + centerx) * 0.5;\n    centerx = (ctrlx12 + ctrlx21) * 0.5;\n    if (x < centerx) {\n      tb = (ta + tb) * 0.5;\n      if (centerx - x_error < x) {\n        t = tb;\n        break;\n      }\n\n      x2 = centerx;\n      cx2 = ctrlx12;\n    } else {\n      ta = (ta + tb) * 0.5;\n      if (x < centerx + x_error) {\n        t = ta;\n        break;\n      }\n\n      x1 = centerx;\n      cx1 = ctrlx21;\n    }\n  }\n\n  if (i == 20) {\n    t = (ta + tb) * 0.5;\n  }\n\n  if (t < 0.0) {\n    t = 0.0;\n  }\n  if (t > 1.0) {\n    t = 1.0;\n  }\n\n  const p01: CubismMotionPoint = lerpPoints(points[0], points[1], t);\n  const p12: CubismMotionPoint = lerpPoints(points[1], points[2], t);\n  const p23: CubismMotionPoint = lerpPoints(points[2], points[3], t);\n\n  const p012: CubismMotionPoint = lerpPoints(p01, p12, t);\n  const p123: CubismMotionPoint = lerpPoints(p12, p23, t);\n\n  return lerpPoints(p012, p123, t).value;\n}\n\nfunction bezierEvaluateCardanoInterpretation(\n  points: CubismMotionPoint[],\n  time: number\n): number {\n  const x: number = time;\n  const x1: number = points[0].time;\n  const x2: number = points[3].time;\n  const cx1: number = points[1].time;\n  const cx2: number = points[2].time;\n\n  const a: number = x2 - 3.0 * cx2 + 3.0 * cx1 - x1;\n  const b: number = 3.0 * cx2 - 6.0 * cx1 + 3.0 * x1;\n  const c: number = 3.0 * cx1 - 3.0 * x1;\n  const d: number = x1 - x;\n\n  const t: number = CubismMath.cardanoAlgorithmForBezier(a, b, c, d);\n\n  const p01: CubismMotionPoint = lerpPoints(points[0], points[1], t);\n  const p12: CubismMotionPoint = lerpPoints(points[1], points[2], t);\n  const p23: CubismMotionPoint = lerpPoints(points[2], points[3], t);\n\n  const p012: CubismMotionPoint = lerpPoints(p01, p12, t);\n  const p123: CubismMotionPoint = lerpPoints(p12, p23, t);\n\n  return lerpPoints(p012, p123, t).value;\n}\n\nfunction steppedEvaluate(points: CubismMotionPoint[], time: number): number {\n  return points[0].value;\n}\n\nfunction inverseSteppedEvaluate(\n  points: CubismMotionPoint[],\n  time: number\n): number {\n  return points[1].value;\n}\n\nfunction evaluateCurve(\n  motionData: CubismMotionData,\n  index: number,\n  time: number\n): number {\n  // Find segment to evaluate.\n  const curve: CubismMotionCurve = motionData.curves.at(index);\n\n  let target = -1;\n  const totalSegmentCount: number = curve.baseSegmentIndex + curve.segmentCount;\n  let pointPosition = 0;\n  for (let i: number = curve.baseSegmentIndex; i < totalSegmentCount; ++i) {\n    // Get first point of next segment.\n    pointPosition =\n      motionData.segments.at(i).basePointIndex +\n      (motionData.segments.at(i).segmentType ==\n      CubismMotionSegmentType.CubismMotionSegmentType_Bezier\n        ? 3\n        : 1);\n\n    // Break if time lies within current segment.\n    if (motionData.points.at(pointPosition).time > time) {\n      target = i;\n      break;\n    }\n  }\n\n  if (target == -1) {\n    return motionData.points.at(pointPosition).value;\n  }\n\n  const segment: CubismMotionSegment = motionData.segments.at(target);\n\n  return segment.evaluate(motionData.points.get(segment.basePointIndex), time);\n}\n\n/**\n * モーションクラス\n *\n * モーションのクラス。\n */\nexport class CubismMotion extends ACubismMotion {\n  /**\n   * インスタンスを作成する\n   *\n   * @param buffer motion3.jsonが読み込まれているバッファ\n   * @param size バッファのサイズ\n   * @param onFinishedMotionHandler モーション再生終了時に呼び出されるコールバック関数\n   * @return 作成されたインスタンス\n   */\n  public static create(\n    buffer: ArrayBuffer,\n    size: number,\n    onFinishedMotionHandler?: FinishedMotionCallback\n  ): CubismMotion {\n    const ret = new CubismMotion();\n\n    ret.parse(buffer, size);\n    ret._sourceFrameRate = ret._motionData.fps;\n    ret._loopDurationSeconds = ret._motionData.duration;\n    ret._onFinishedMotion = onFinishedMotionHandler;\n\n    // NOTE: Editorではループありのモーション書き出しは非対応\n    // ret->_loop = (ret->_motionData->Loop > 0);\n    return ret;\n  }\n\n  /**\n   * モデルのパラメータの更新の実行\n   * @param model             対象のモデル\n   * @param userTimeSeconds   現在の時刻[秒]\n   * @param fadeWeight        モーションの重み\n   * @param motionQueueEntry  CubismMotionQueueManagerで管理されているモーション\n   */\n  public doUpdateParameters(\n    model: CubismModel,\n    userTimeSeconds: number,\n    fadeWeight: number,\n    motionQueueEntry: CubismMotionQueueEntry\n  ): void {\n    if (this._modelCurveIdEyeBlink == null) {\n      this._modelCurveIdEyeBlink =\n        CubismFramework.getIdManager().getId(EffectNameEyeBlink);\n    }\n\n    if (this._modelCurveIdLipSync == null) {\n      this._modelCurveIdLipSync =\n        CubismFramework.getIdManager().getId(EffectNameLipSync);\n    }\n\n    if (this._modelCurveIdOpacity == null) {\n      this._modelCurveIdOpacity =\n        CubismFramework.getIdManager().getId(IdNameOpacity);\n    }\n\n    let timeOffsetSeconds: number =\n      userTimeSeconds - motionQueueEntry.getStartTime();\n\n    if (timeOffsetSeconds < 0.0) {\n      timeOffsetSeconds = 0.0; // エラー回避\n    }\n\n    let lipSyncValue: number = Number.MAX_VALUE;\n    let eyeBlinkValue: number = Number.MAX_VALUE;\n\n    //まばたき、リップシンクのうちモーションの適用を検出するためのビット（maxFlagCount個まで\n    const MaxTargetSize = 64;\n    let lipSyncFlags = 0;\n    let eyeBlinkFlags = 0;\n\n    //瞬き、リップシンクのターゲット数が上限を超えている場合\n    if (this._eyeBlinkParameterIds.getSize() > MaxTargetSize) {\n      CubismLogDebug(\n        'too many eye blink targets : {0}',\n        this._eyeBlinkParameterIds.getSize()\n      );\n    }\n    if (this._lipSyncParameterIds.getSize() > MaxTargetSize) {\n      CubismLogDebug(\n        'too many lip sync targets : {0}',\n        this._lipSyncParameterIds.getSize()\n      );\n    }\n\n    const tmpFadeIn: number =\n      this._fadeInSeconds <= 0.0\n        ? 1.0\n        : CubismMath.getEasingSine(\n            (userTimeSeconds - motionQueueEntry.getFadeInStartTime()) /\n              this._fadeInSeconds\n          );\n\n    const tmpFadeOut: number =\n      this._fadeOutSeconds <= 0.0 || motionQueueEntry.getEndTime() < 0.0\n        ? 1.0\n        : CubismMath.getEasingSine(\n            (motionQueueEntry.getEndTime() - userTimeSeconds) /\n              this._fadeOutSeconds\n          );\n    let value: number;\n    let c: number, parameterIndex: number;\n\n    // 'Repeat' time as necessary.\n    let time: number = timeOffsetSeconds;\n\n    if (this._isLoop) {\n      while (time > this._motionData.duration) {\n        time -= this._motionData.duration;\n      }\n    }\n\n    const curves: csmVector<CubismMotionCurve> = this._motionData.curves;\n\n    // Evaluate model curves.\n    for (\n      c = 0;\n      c < this._motionData.curveCount &&\n      curves.at(c).type ==\n        CubismMotionCurveTarget.CubismMotionCurveTarget_Model;\n      ++c\n    ) {\n      // Evaluate curve and call handler.\n      value = evaluateCurve(this._motionData, c, time);\n\n      if (curves.at(c).id == this._modelCurveIdEyeBlink) {\n        eyeBlinkValue = value;\n      } else if (curves.at(c).id == this._modelCurveIdLipSync) {\n        lipSyncValue = value;\n      } else if (curves.at(c).id == this._modelCurveIdOpacity) {\n        this._modelOpacity = value;\n        model.setModelOapcity(this.getModelOpacityValue());\n      }\n    }\n\n    let parameterMotionCurveCount = 0;\n\n    for (\n      ;\n      c < this._motionData.curveCount &&\n      curves.at(c).type ==\n        CubismMotionCurveTarget.CubismMotionCurveTarget_Parameter;\n      ++c\n    ) {\n      parameterMotionCurveCount++;\n\n      // Find parameter index.\n      parameterIndex = model.getParameterIndex(curves.at(c).id);\n\n      // Skip curve evaluation if no value in sink.\n      if (parameterIndex == -1) {\n        continue;\n      }\n\n      const sourceValue: number =\n        model.getParameterValueByIndex(parameterIndex);\n\n      // Evaluate curve and apply value.\n      value = evaluateCurve(this._motionData, c, time);\n\n      if (eyeBlinkValue != Number.MAX_VALUE) {\n        for (\n          let i = 0;\n          i < this._eyeBlinkParameterIds.getSize() && i < MaxTargetSize;\n          ++i\n        ) {\n          if (this._eyeBlinkParameterIds.at(i) == curves.at(c).id) {\n            value *= eyeBlinkValue;\n            eyeBlinkFlags |= 1 << i;\n            break;\n          }\n        }\n      }\n\n      if (lipSyncValue != Number.MAX_VALUE) {\n        for (\n          let i = 0;\n          i < this._lipSyncParameterIds.getSize() && i < MaxTargetSize;\n          ++i\n        ) {\n          if (this._lipSyncParameterIds.at(i) == curves.at(c).id) {\n            value += lipSyncValue;\n            lipSyncFlags |= 1 << i;\n            break;\n          }\n        }\n      }\n\n      let v: number;\n\n      // パラメータごとのフェード\n      if (curves.at(c).fadeInTime < 0.0 && curves.at(c).fadeOutTime < 0.0) {\n        // モーションのフェードを適用\n        v = sourceValue + (value - sourceValue) * fadeWeight;\n      } else {\n        // パラメータに対してフェードインかフェードアウトが設定してある場合はそちらを適用\n        let fin: number;\n        let fout: number;\n\n        if (curves.at(c).fadeInTime < 0.0) {\n          fin = tmpFadeIn;\n        } else {\n          fin =\n            curves.at(c).fadeInTime == 0.0\n              ? 1.0\n              : CubismMath.getEasingSine(\n                  (userTimeSeconds - motionQueueEntry.getFadeInStartTime()) /\n                    curves.at(c).fadeInTime\n                );\n        }\n\n        if (curves.at(c).fadeOutTime < 0.0) {\n          fout = tmpFadeOut;\n        } else {\n          fout =\n            curves.at(c).fadeOutTime == 0.0 ||\n            motionQueueEntry.getEndTime() < 0.0\n              ? 1.0\n              : CubismMath.getEasingSine(\n                  (motionQueueEntry.getEndTime() - userTimeSeconds) /\n                    curves.at(c).fadeOutTime\n                );\n        }\n\n        const paramWeight: number = this._weight * fin * fout;\n\n        // パラメータごとのフェードを適用\n        v = sourceValue + (value - sourceValue) * paramWeight;\n      }\n\n      model.setParameterValueByIndex(parameterIndex, v, 1.0);\n    }\n\n    {\n      if (eyeBlinkValue != Number.MAX_VALUE) {\n        for (\n          let i = 0;\n          i < this._eyeBlinkParameterIds.getSize() && i < MaxTargetSize;\n          ++i\n        ) {\n          const sourceValue: number = model.getParameterValueById(\n            this._eyeBlinkParameterIds.at(i)\n          );\n\n          // モーションでの上書きがあった時にはまばたきは適用しない\n          if ((eyeBlinkFlags >> i) & 0x01) {\n            continue;\n          }\n\n          const v: number =\n            sourceValue + (eyeBlinkValue - sourceValue) * fadeWeight;\n\n          model.setParameterValueById(this._eyeBlinkParameterIds.at(i), v);\n        }\n      }\n\n      if (lipSyncValue != Number.MAX_VALUE) {\n        for (\n          let i = 0;\n          i < this._lipSyncParameterIds.getSize() && i < MaxTargetSize;\n          ++i\n        ) {\n          const sourceValue: number = model.getParameterValueById(\n            this._lipSyncParameterIds.at(i)\n          );\n\n          // モーションでの上書きがあった時にはリップシンクは適用しない\n          if ((lipSyncFlags >> i) & 0x01) {\n            continue;\n          }\n\n          const v: number =\n            sourceValue + (lipSyncValue - sourceValue) * fadeWeight;\n\n          model.setParameterValueById(this._lipSyncParameterIds.at(i), v);\n        }\n      }\n    }\n\n    for (\n      ;\n      c < this._motionData.curveCount &&\n      curves.at(c).type ==\n        CubismMotionCurveTarget.CubismMotionCurveTarget_PartOpacity;\n      ++c\n    ) {\n      // Find parameter index.\n      parameterIndex = model.getParameterIndex(curves.at(c).id);\n\n      // Skip curve evaluation if no value in sink.\n      if (parameterIndex == -1) {\n        continue;\n      }\n\n      // Evaluate curve and apply value.\n      value = evaluateCurve(this._motionData, c, time);\n\n      model.setParameterValueByIndex(parameterIndex, value);\n    }\n\n    if (timeOffsetSeconds >= this._motionData.duration) {\n      if (this._isLoop) {\n        motionQueueEntry.setStartTime(userTimeSeconds); // 最初の状態へ\n        if (this._isLoopFadeIn) {\n          // ループ内でループ用フェードインが有効の時は、フェードイン設定し直し\n          motionQueueEntry.setFadeInStartTime(userTimeSeconds);\n        }\n      } else {\n        if (this._onFinishedMotion) {\n          this._onFinishedMotion(this);\n        }\n\n        motionQueueEntry.setIsFinished(true);\n      }\n    }\n    this._lastWeight = fadeWeight;\n  }\n\n  /**\n   * ループ情報の設定\n   * @param loop ループ情報\n   */\n  public setIsLoop(loop: boolean): void {\n    this._isLoop = loop;\n  }\n\n  /**\n   * ループ情報の取得\n   * @return true ループする\n   * @return false ループしない\n   */\n  public isLoop(): boolean {\n    return this._isLoop;\n  }\n\n  /**\n   * ループ時のフェードイン情報の設定\n   * @param loopFadeIn  ループ時のフェードイン情報\n   */\n  public setIsLoopFadeIn(loopFadeIn: boolean): void {\n    this._isLoopFadeIn = loopFadeIn;\n  }\n\n  /**\n   * ループ時のフェードイン情報の取得\n   *\n   * @return  true    する\n   * @return  false   しない\n   */\n  public isLoopFadeIn(): boolean {\n    return this._isLoopFadeIn;\n  }\n\n  /**\n   * モーションの長さを取得する。\n   *\n   * @return  モーションの長さ[秒]\n   */\n  public getDuration(): number {\n    return this._isLoop ? -1.0 : this._loopDurationSeconds;\n  }\n\n  /**\n   * モーションのループ時の長さを取得する。\n   *\n   * @return  モーションのループ時の長さ[秒]\n   */\n  public getLoopDuration(): number {\n    return this._loopDurationSeconds;\n  }\n\n  /**\n   * パラメータに対するフェードインの時間を設定する。\n   *\n   * @param parameterId     パラメータID\n   * @param value           フェードインにかかる時間[秒]\n   */\n  public setParameterFadeInTime(\n    parameterId: CubismIdHandle,\n    value: number\n  ): void {\n    const curves: csmVector<CubismMotionCurve> = this._motionData.curves;\n\n    for (let i = 0; i < this._motionData.curveCount; ++i) {\n      if (parameterId == curves.at(i).id) {\n        curves.at(i).fadeInTime = value;\n        return;\n      }\n    }\n  }\n\n  /**\n   * パラメータに対するフェードアウトの時間の設定\n   * @param parameterId     パラメータID\n   * @param value           フェードアウトにかかる時間[秒]\n   */\n  public setParameterFadeOutTime(\n    parameterId: CubismIdHandle,\n    value: number\n  ): void {\n    const curves: csmVector<CubismMotionCurve> = this._motionData.curves;\n\n    for (let i = 0; i < this._motionData.curveCount; ++i) {\n      if (parameterId == curves.at(i).id) {\n        curves.at(i).fadeOutTime = value;\n        return;\n      }\n    }\n  }\n\n  /**\n   * パラメータに対するフェードインの時間の取得\n   * @param    parameterId     パラメータID\n   * @return   フェードインにかかる時間[秒]\n   */\n  public getParameterFadeInTime(parameterId: CubismIdHandle): number {\n    const curves: csmVector<CubismMotionCurve> = this._motionData.curves;\n\n    for (let i = 0; i < this._motionData.curveCount; ++i) {\n      if (parameterId == curves.at(i).id) {\n        return curves.at(i).fadeInTime;\n      }\n    }\n\n    return -1;\n  }\n\n  /**\n   * パラメータに対するフェードアウトの時間を取得\n   *\n   * @param   parameterId     パラメータID\n   * @return   フェードアウトにかかる時間[秒]\n   */\n  public getParameterFadeOutTime(parameterId: CubismIdHandle): number {\n    const curves: csmVector<CubismMotionCurve> = this._motionData.curves;\n\n    for (let i = 0; i < this._motionData.curveCount; ++i) {\n      if (parameterId == curves.at(i).id) {\n        return curves.at(i).fadeOutTime;\n      }\n    }\n\n    return -1;\n  }\n\n  /**\n   * 自動エフェクトがかかっているパラメータIDリストの設定\n   * @param eyeBlinkParameterIds    自動まばたきがかかっているパラメータIDのリスト\n   * @param lipSyncParameterIds     リップシンクがかかっているパラメータIDのリスト\n   */\n  public setEffectIds(\n    eyeBlinkParameterIds: csmVector<CubismIdHandle>,\n    lipSyncParameterIds: csmVector<CubismIdHandle>\n  ): void {\n    this._eyeBlinkParameterIds = eyeBlinkParameterIds;\n    this._lipSyncParameterIds = lipSyncParameterIds;\n  }\n\n  /**\n   * コンストラクタ\n   */\n  public constructor() {\n    super();\n    this._sourceFrameRate = 30.0;\n    this._loopDurationSeconds = -1.0;\n    this._isLoop = false; // trueから false へデフォルトを変更\n    this._isLoopFadeIn = true; // ループ時にフェードインが有効かどうかのフラグ\n    this._lastWeight = 0.0;\n    this._motionData = null;\n    this._modelCurveIdEyeBlink = null;\n    this._modelCurveIdLipSync = null;\n    this._modelCurveIdOpacity = null;\n    this._eyeBlinkParameterIds = null;\n    this._lipSyncParameterIds = null;\n    this._modelOpacity = 1.0;\n  }\n\n  /**\n   * デストラクタ相当の処理\n   */\n  public release(): void {\n    this._motionData = void 0;\n    this._motionData = null;\n  }\n\n  /**\n   * motion3.jsonをパースする。\n   *\n   * @param motionJson  motion3.jsonが読み込まれているバッファ\n   * @param size        バッファのサイズ\n   */\n  public parse(motionJson: ArrayBuffer, size: number): void {\n    this._motionData = new CubismMotionData();\n\n    let json: CubismMotionJson = new CubismMotionJson(motionJson, size);\n\n    this._motionData.duration = json.getMotionDuration();\n    this._motionData.loop = json.isMotionLoop();\n    this._motionData.curveCount = json.getMotionCurveCount();\n    this._motionData.fps = json.getMotionFps();\n    this._motionData.eventCount = json.getEventCount();\n\n    const areBeziersRestructed: boolean = json.getEvaluationOptionFlag(\n      EvaluationOptionFlag.EvaluationOptionFlag_AreBeziersRistricted\n    );\n\n    if (json.isExistMotionFadeInTime()) {\n      this._fadeInSeconds =\n        json.getMotionFadeInTime() < 0.0 ? 1.0 : json.getMotionFadeInTime();\n    } else {\n      this._fadeInSeconds = 1.0;\n    }\n\n    if (json.isExistMotionFadeOutTime()) {\n      this._fadeOutSeconds =\n        json.getMotionFadeOutTime() < 0.0 ? 1.0 : json.getMotionFadeOutTime();\n    } else {\n      this._fadeOutSeconds = 1.0;\n    }\n\n    this._motionData.curves.updateSize(\n      this._motionData.curveCount,\n      CubismMotionCurve,\n      true\n    );\n    this._motionData.segments.updateSize(\n      json.getMotionTotalSegmentCount(),\n      CubismMotionSegment,\n      true\n    );\n    this._motionData.points.updateSize(\n      json.getMotionTotalPointCount(),\n      CubismMotionPoint,\n      true\n    );\n    this._motionData.events.updateSize(\n      this._motionData.eventCount,\n      CubismMotionEvent,\n      true\n    );\n\n    let totalPointCount = 0;\n    let totalSegmentCount = 0;\n\n    // Curves\n    for (\n      let curveCount = 0;\n      curveCount < this._motionData.curveCount;\n      ++curveCount\n    ) {\n      if (json.getMotionCurveTarget(curveCount) == TargetNameModel) {\n        this._motionData.curves.at(curveCount).type =\n          CubismMotionCurveTarget.CubismMotionCurveTarget_Model;\n      } else if (json.getMotionCurveTarget(curveCount) == TargetNameParameter) {\n        this._motionData.curves.at(curveCount).type =\n          CubismMotionCurveTarget.CubismMotionCurveTarget_Parameter;\n      } else if (\n        json.getMotionCurveTarget(curveCount) == TargetNamePartOpacity\n      ) {\n        this._motionData.curves.at(curveCount).type =\n          CubismMotionCurveTarget.CubismMotionCurveTarget_PartOpacity;\n      } else {\n        CubismLogWarning(\n          'Warning : Unable to get segment type from Curve! The number of \"CurveCount\" may be incorrect!'\n        );\n      }\n\n      this._motionData.curves.at(curveCount).id =\n        json.getMotionCurveId(curveCount);\n\n      this._motionData.curves.at(curveCount).baseSegmentIndex =\n        totalSegmentCount;\n\n      this._motionData.curves.at(curveCount).fadeInTime =\n        json.isExistMotionCurveFadeInTime(curveCount)\n          ? json.getMotionCurveFadeInTime(curveCount)\n          : -1.0;\n      this._motionData.curves.at(curveCount).fadeOutTime =\n        json.isExistMotionCurveFadeOutTime(curveCount)\n          ? json.getMotionCurveFadeOutTime(curveCount)\n          : -1.0;\n\n      // Segments\n      for (\n        let segmentPosition = 0;\n        segmentPosition < json.getMotionCurveSegmentCount(curveCount);\n\n      ) {\n        if (segmentPosition == 0) {\n          this._motionData.segments.at(totalSegmentCount).basePointIndex =\n            totalPointCount;\n\n          this._motionData.points.at(totalPointCount).time =\n            json.getMotionCurveSegment(curveCount, segmentPosition);\n          this._motionData.points.at(totalPointCount).value =\n            json.getMotionCurveSegment(curveCount, segmentPosition + 1);\n\n          totalPointCount += 1;\n          segmentPosition += 2;\n        } else {\n          this._motionData.segments.at(totalSegmentCount).basePointIndex =\n            totalPointCount - 1;\n        }\n\n        const segment: number = json.getMotionCurveSegment(\n          curveCount,\n          segmentPosition\n        );\n        switch (segment) {\n          case CubismMotionSegmentType.CubismMotionSegmentType_Linear: {\n            this._motionData.segments.at(totalSegmentCount).segmentType =\n              CubismMotionSegmentType.CubismMotionSegmentType_Linear;\n            this._motionData.segments.at(totalSegmentCount).evaluate =\n              linearEvaluate;\n\n            this._motionData.points.at(totalPointCount).time =\n              json.getMotionCurveSegment(curveCount, segmentPosition + 1);\n            this._motionData.points.at(totalPointCount).value =\n              json.getMotionCurveSegment(curveCount, segmentPosition + 2);\n\n            totalPointCount += 1;\n            segmentPosition += 3;\n\n            break;\n          }\n          case CubismMotionSegmentType.CubismMotionSegmentType_Bezier: {\n            this._motionData.segments.at(totalSegmentCount).segmentType =\n              CubismMotionSegmentType.CubismMotionSegmentType_Bezier;\n\n            if (areBeziersRestructed || UseOldBeziersCurveMotion) {\n              this._motionData.segments.at(totalSegmentCount).evaluate =\n                bezierEvaluate;\n            } else {\n              this._motionData.segments.at(totalSegmentCount).evaluate =\n                bezierEvaluateCardanoInterpretation;\n            }\n\n            this._motionData.points.at(totalPointCount).time =\n              json.getMotionCurveSegment(curveCount, segmentPosition + 1);\n            this._motionData.points.at(totalPointCount).value =\n              json.getMotionCurveSegment(curveCount, segmentPosition + 2);\n\n            this._motionData.points.at(totalPointCount + 1).time =\n              json.getMotionCurveSegment(curveCount, segmentPosition + 3);\n            this._motionData.points.at(totalPointCount + 1).value =\n              json.getMotionCurveSegment(curveCount, segmentPosition + 4);\n\n            this._motionData.points.at(totalPointCount + 2).time =\n              json.getMotionCurveSegment(curveCount, segmentPosition + 5);\n            this._motionData.points.at(totalPointCount + 2).value =\n              json.getMotionCurveSegment(curveCount, segmentPosition + 6);\n\n            totalPointCount += 3;\n            segmentPosition += 7;\n\n            break;\n          }\n\n          case CubismMotionSegmentType.CubismMotionSegmentType_Stepped: {\n            this._motionData.segments.at(totalSegmentCount).segmentType =\n              CubismMotionSegmentType.CubismMotionSegmentType_Stepped;\n            this._motionData.segments.at(totalSegmentCount).evaluate =\n              steppedEvaluate;\n\n            this._motionData.points.at(totalPointCount).time =\n              json.getMotionCurveSegment(curveCount, segmentPosition + 1);\n            this._motionData.points.at(totalPointCount).value =\n              json.getMotionCurveSegment(curveCount, segmentPosition + 2);\n\n            totalPointCount += 1;\n            segmentPosition += 3;\n\n            break;\n          }\n\n          case CubismMotionSegmentType.CubismMotionSegmentType_InverseStepped: {\n            this._motionData.segments.at(totalSegmentCount).segmentType =\n              CubismMotionSegmentType.CubismMotionSegmentType_InverseStepped;\n            this._motionData.segments.at(totalSegmentCount).evaluate =\n              inverseSteppedEvaluate;\n\n            this._motionData.points.at(totalPointCount).time =\n              json.getMotionCurveSegment(curveCount, segmentPosition + 1);\n            this._motionData.points.at(totalPointCount).value =\n              json.getMotionCurveSegment(curveCount, segmentPosition + 2);\n\n            totalPointCount += 1;\n            segmentPosition += 3;\n\n            break;\n          }\n          default: {\n            CSM_ASSERT(0);\n            break;\n          }\n        }\n\n        ++this._motionData.curves.at(curveCount).segmentCount;\n        ++totalSegmentCount;\n      }\n    }\n\n    for (\n      let userdatacount = 0;\n      userdatacount < json.getEventCount();\n      ++userdatacount\n    ) {\n      this._motionData.events.at(userdatacount).fireTime =\n        json.getEventTime(userdatacount);\n      this._motionData.events.at(userdatacount).value =\n        json.getEventValue(userdatacount);\n    }\n\n    json.release();\n    json = void 0;\n    json = null;\n  }\n\n  /**\n   * モデルのパラメータ更新\n   *\n   * イベント発火のチェック。\n   * 入力する時間は呼ばれるモーションタイミングを０とした秒数で行う。\n   *\n   * @param beforeCheckTimeSeconds   前回のイベントチェック時間[秒]\n   * @param motionTimeSeconds        今回の再生時間[秒]\n   */\n  public getFiredEvent(\n    beforeCheckTimeSeconds: number,\n    motionTimeSeconds: number\n  ): csmVector<csmString> {\n    this._firedEventValues.updateSize(0);\n\n    // イベントの発火チェック\n    for (let u = 0; u < this._motionData.eventCount; ++u) {\n      if (\n        this._motionData.events.at(u).fireTime > beforeCheckTimeSeconds &&\n        this._motionData.events.at(u).fireTime <= motionTimeSeconds\n      ) {\n        this._firedEventValues.pushBack(\n          new csmString(this._motionData.events.at(u).value.s)\n        );\n      }\n    }\n\n    return this._firedEventValues;\n  }\n\n  /**\n   * 透明度のカーブが存在するかどうかを確認する\n   *\n   * @returns true  -> キーが存在する\n   *          false -> キーが存在しない\n   */\n  public isExistModelOpacity(): boolean {\n    for (let i = 0; i < this._motionData.curveCount; i++) {\n      const curve: CubismMotionCurve = this._motionData.curves.at(i);\n\n      if (curve.type != CubismMotionCurveTarget.CubismMotionCurveTarget_Model) {\n        continue;\n      }\n\n      if (curve.id.getString().s.localeCompare(IdNameOpacity) == 0) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * 透明度のカーブのインデックスを返す\n   *\n   * @returns success:透明度のカーブのインデックス\n   */\n  public getModelOpacityIndex(): number {\n    if (this.isExistModelOpacity()) {\n      for (let i = 0; i < this._motionData.curveCount; i++) {\n        const curve: CubismMotionCurve = this._motionData.curves.at(i);\n\n        if (\n          curve.type != CubismMotionCurveTarget.CubismMotionCurveTarget_Model\n        ) {\n          continue;\n        }\n\n        if (curve.id.getString().s.localeCompare(IdNameOpacity) == 0) {\n          return i;\n        }\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * 透明度のIdを返す\n   *\n   * @param index モーションカーブのインデックス\n   * @returns success:透明度のカーブのインデックス\n   */\n  public getModelOpacityId(index: number): CubismIdHandle {\n    if (index != -1) {\n      const curve: CubismMotionCurve = this._motionData.curves.at(index);\n\n      if (curve.type == CubismMotionCurveTarget.CubismMotionCurveTarget_Model) {\n        if (curve.id.getString().s.localeCompare(IdNameOpacity) == 0) {\n          return CubismFramework.getIdManager().getId(curve.id.getString().s);\n        }\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * 現在時間の透明度の値を返す\n   *\n   * @returns success:モーションの当該時間におけるOpacityの値\n   */\n  public getModelOpacityValue(): number {\n    return this._modelOpacity;\n  }\n\n  public _sourceFrameRate: number; // ロードしたファイルのFPS。記述が無ければデフォルト値15fpsとなる\n  public _loopDurationSeconds: number; // mtnファイルで定義される一連のモーションの長さ\n  public _isLoop: boolean; // ループするか?\n  public _isLoopFadeIn: boolean; // ループ時にフェードインが有効かどうかのフラグ。初期値では有効。\n  public _lastWeight: number; // 最後に設定された重み\n\n  public _motionData: CubismMotionData; // 実際のモーションデータ本体\n\n  public _eyeBlinkParameterIds: csmVector<CubismIdHandle>; // 自動まばたきを適用するパラメータIDハンドルのリスト。  モデル（モデルセッティング）とパラメータを対応付ける。\n  public _lipSyncParameterIds: csmVector<CubismIdHandle>; // リップシンクを適用するパラメータIDハンドルのリスト。  モデル（モデルセッティング）とパラメータを対応付ける。\n\n  public _modelCurveIdEyeBlink: CubismIdHandle; // モデルが持つ自動まばたき用パラメータIDのハンドル。  モデルとモーションを対応付ける。\n  public _modelCurveIdLipSync: CubismIdHandle; // モデルが持つリップシンク用パラメータIDのハンドル。  モデルとモーションを対応付ける。\n  public _modelCurveIdOpacity: CubismIdHandle; // モデルが持つ不透明度用パラメータIDのハンドル。  モデルとモーションを対応付ける。\n\n  public _modelOpacity: number; // モーションから取得した不透明度\n}\n\n// Namespace definition for compatibility.\nimport * as $ from './cubismmotion';\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport namespace Live2DCubismFramework {\n  export const CubismMotion = $.CubismMotion;\n  export type CubismMotion = $.CubismMotion;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}