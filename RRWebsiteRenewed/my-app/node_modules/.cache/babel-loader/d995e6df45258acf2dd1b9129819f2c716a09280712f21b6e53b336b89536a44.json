{"ast":null,"code":"/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\n\nimport { Constant } from '../live2dcubismframework';\nimport { CubismMatrix44 } from '../math/cubismmatrix44';\nimport { csmMap } from '../type/csmmap';\nimport { csmRect } from '../type/csmrectf';\nimport { csmVector } from '../type/csmvector';\nimport { CubismLogError, CubismLogWarning } from '../utils/cubismdebug';\nimport { CubismBlendMode, CubismRenderer, CubismTextureColor } from './cubismrenderer';\nconst ColorChannelCount = 4; // 実験時に1チャンネルの場合は1、RGBだけの場合は3、アルファも含める場合は4\nconst ClippingMaskMaxCountOnDefault = 36; // 通常のフレームバッファ一枚あたりのマスク最大数\nconst ClippingMaskMaxCountOnMultiRenderTexture = 32; // フレームバッファが2枚以上ある場合のフレームバッファ一枚あたりのマスク最大数\n\nconst ShaderCount = 10; // シェーダーの数 = マスク生成用 + (通常用 + 加算 + 乗算) * (マスク無の乗算済アルファ対応版 + マスク有の乗算済アルファ対応版 + マスク有反転の乗算済アルファ対応版)\nlet s_instance;\nlet s_viewport;\nlet s_fbo;\n\n/**\n * クリッピングマスクの処理を実行するクラス\n */\nexport class CubismClippingManager_WebGL {\n  /**\n   * カラーチャンネル（RGBA）のフラグを取得する\n   * @param channelNo カラーチャンネル（RGBA）の番号（0:R, 1:G, 2:B, 3:A）\n   */\n  getChannelFlagAsColor(channelNo) {\n    return this._channelColors.at(channelNo);\n  }\n\n  /**\n   * テンポラリのレンダーテクスチャのアドレスを取得する\n   * FrameBufferObjectが存在しない場合、新しく生成する\n   *\n   * @return レンダーテクスチャの配列\n   */\n  getMaskRenderTexture() {\n    // テンポラリのRenderTextureを取得する\n    if (this._maskTexture && this._maskTexture.textures != null) {\n      // 前回使ったものを返す\n      this._maskTexture.frameNo = this._currentFrameNo;\n    } else {\n      // FrameBufferObjectが存在しない場合、新しく生成する\n      if (this._maskRenderTextures != null) {\n        this._maskRenderTextures.clear();\n      }\n      this._maskRenderTextures = new csmVector();\n\n      // ColorBufferObjectが存在しない場合、新しく生成する\n      if (this._maskColorBuffers != null) {\n        this._maskColorBuffers.clear();\n      }\n      this._maskColorBuffers = new csmVector();\n\n      // クリッピングバッファサイズを取得\n      const size = this._clippingMaskBufferSize;\n      for (let index = 0; index < this._renderTextureCount; index++) {\n        this._maskColorBuffers.pushBack(this.gl.createTexture()); // 直接代入\n        this.gl.bindTexture(this.gl.TEXTURE_2D, this._maskColorBuffers.at(index));\n        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, size, size, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, null);\n        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);\n        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);\n        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);\n        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);\n        this.gl.bindTexture(this.gl.TEXTURE_2D, null);\n        this._maskRenderTextures.pushBack(this.gl.createFramebuffer());\n        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this._maskRenderTextures.at(index));\n        this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, this.gl.TEXTURE_2D, this._maskColorBuffers.at(index), 0);\n      }\n      this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, s_fbo);\n      this._maskTexture = new CubismRenderTextureResource(this._currentFrameNo, this._maskRenderTextures);\n    }\n    return this._maskTexture.textures;\n  }\n\n  /**\n   * WebGLレンダリングコンテキストを設定する\n   * @param gl WebGLレンダリングコンテキスト\n   */\n  setGL(gl) {\n    this.gl = gl;\n  }\n\n  /**\n   * マスクされる描画オブジェクト群全体を囲む矩形（モデル座標系）を計算する\n   * @param model モデルのインスタンス\n   * @param clippingContext クリッピングマスクのコンテキスト\n   */\n  calcClippedDrawTotalBounds(model, clippingContext) {\n    // 被クリッピングマスク（マスクされる描画オブジェクト）の全体の矩形\n    let clippedDrawTotalMinX = Number.MAX_VALUE;\n    let clippedDrawTotalMinY = Number.MAX_VALUE;\n    let clippedDrawTotalMaxX = Number.MIN_VALUE;\n    let clippedDrawTotalMaxY = Number.MIN_VALUE;\n\n    // このマスクが実際に必要か判定する\n    // このクリッピングを利用する「描画オブジェクト」がひとつでも使用可能であればマスクを生成する必要がある\n    const clippedDrawCount = clippingContext._clippedDrawableIndexList.length;\n    for (let clippedDrawableIndex = 0; clippedDrawableIndex < clippedDrawCount; clippedDrawableIndex++) {\n      // マスクを使用する描画オブジェクトの描画される矩形を求める\n      const drawableIndex = clippingContext._clippedDrawableIndexList[clippedDrawableIndex];\n      const drawableVertexCount = model.getDrawableVertexCount(drawableIndex);\n      const drawableVertexes = model.getDrawableVertices(drawableIndex);\n      let minX = Number.MAX_VALUE;\n      let minY = Number.MAX_VALUE;\n      let maxX = -Number.MAX_VALUE;\n      let maxY = -Number.MAX_VALUE;\n      const loop = drawableVertexCount * Constant.vertexStep;\n      for (let pi = Constant.vertexOffset; pi < loop; pi += Constant.vertexStep) {\n        const x = drawableVertexes[pi];\n        const y = drawableVertexes[pi + 1];\n        if (x < minX) {\n          minX = x;\n        }\n        if (x > maxX) {\n          maxX = x;\n        }\n        if (y < minY) {\n          minY = y;\n        }\n        if (y > maxY) {\n          maxY = y;\n        }\n      }\n\n      // 有効な点が一つも取れなかったのでスキップ\n      if (minX == Number.MAX_VALUE) {\n        continue;\n      }\n\n      // 全体の矩形に反映\n      if (minX < clippedDrawTotalMinX) {\n        clippedDrawTotalMinX = minX;\n      }\n      if (minY < clippedDrawTotalMinY) {\n        clippedDrawTotalMinY = minY;\n      }\n      if (maxX > clippedDrawTotalMaxX) {\n        clippedDrawTotalMaxX = maxX;\n      }\n      if (maxY > clippedDrawTotalMaxY) {\n        clippedDrawTotalMaxY = maxY;\n      }\n      if (clippedDrawTotalMinX == Number.MAX_VALUE) {\n        clippingContext._allClippedDrawRect.x = 0.0;\n        clippingContext._allClippedDrawRect.y = 0.0;\n        clippingContext._allClippedDrawRect.width = 0.0;\n        clippingContext._allClippedDrawRect.height = 0.0;\n        clippingContext._isUsing = false;\n      } else {\n        clippingContext._isUsing = true;\n        const w = clippedDrawTotalMaxX - clippedDrawTotalMinX;\n        const h = clippedDrawTotalMaxY - clippedDrawTotalMinY;\n        clippingContext._allClippedDrawRect.x = clippedDrawTotalMinX;\n        clippingContext._allClippedDrawRect.y = clippedDrawTotalMinY;\n        clippingContext._allClippedDrawRect.width = w;\n        clippingContext._allClippedDrawRect.height = h;\n      }\n    }\n  }\n\n  /**\n   * コンストラクタ\n   */\n  constructor() {\n    this._currentMaskRenderTexture = void 0;\n    // マスク用レンダーテクスチャのアドレス\n    this._maskRenderTextures = void 0;\n    // レンダーテクスチャのリスト\n    this._maskColorBuffers = void 0;\n    // マスク用カラーバッファーのアドレスのリスト\n    this._currentFrameNo = void 0;\n    // マスクテクスチャに与えるフレーム番号\n    this._channelColors = void 0;\n    this._maskTexture = void 0;\n    // マスク用のテクスチャリソースのリスト\n    this._clippingContextListForMask = void 0;\n    // マスク用クリッピングコンテキストのリスト\n    this._clippingContextListForDraw = void 0;\n    // 描画用クリッピングコンテキストのリスト\n    this._clippingMaskBufferSize = void 0;\n    // クリッピングマスクのバッファサイズ（初期値:256）\n    this._renderTextureCount = void 0;\n    // 生成するレンダーテクスチャの枚数\n    this._tmpMatrix = void 0;\n    // マスク計算用の行列\n    this._tmpMatrixForMask = void 0;\n    // マスク計算用の行列\n    this._tmpMatrixForDraw = void 0;\n    // マスク計算用の行列\n    this._tmpBoundsOnModel = void 0;\n    // マスク配置計算用の矩形\n    this._clearedFrameBufferflags = void 0;\n    //マスクのクリアフラグの配列\n    this.gl = void 0;\n    this._currentMaskRenderTexture = null;\n    this._maskColorBuffers = null;\n    this._currentFrameNo = 0;\n    this._renderTextureCount = 0;\n    this._clippingMaskBufferSize = 256;\n    this._clippingContextListForMask = new csmVector();\n    this._clippingContextListForDraw = new csmVector();\n    this._channelColors = new csmVector();\n    this._tmpBoundsOnModel = new csmRect();\n    this._tmpMatrix = new CubismMatrix44();\n    this._tmpMatrixForMask = new CubismMatrix44();\n    this._tmpMatrixForDraw = new CubismMatrix44();\n    this._maskTexture = null;\n    let tmp = new CubismTextureColor();\n    tmp.R = 1.0;\n    tmp.G = 0.0;\n    tmp.B = 0.0;\n    tmp.A = 0.0;\n    this._channelColors.pushBack(tmp);\n    tmp = new CubismTextureColor();\n    tmp.R = 0.0;\n    tmp.G = 1.0;\n    tmp.B = 0.0;\n    tmp.A = 0.0;\n    this._channelColors.pushBack(tmp);\n    tmp = new CubismTextureColor();\n    tmp.R = 0.0;\n    tmp.G = 0.0;\n    tmp.B = 1.0;\n    tmp.A = 0.0;\n    this._channelColors.pushBack(tmp);\n    tmp = new CubismTextureColor();\n    tmp.R = 0.0;\n    tmp.G = 0.0;\n    tmp.B = 0.0;\n    tmp.A = 1.0;\n    this._channelColors.pushBack(tmp);\n  }\n\n  /**\n   * デストラクタ相当の処理\n   */\n  release() {\n    for (let i = 0; i < this._clippingContextListForMask.getSize(); i++) {\n      if (this._clippingContextListForMask.at(i)) {\n        this._clippingContextListForMask.at(i).release();\n        this._clippingContextListForMask.set(i, void 0);\n      }\n      this._clippingContextListForMask.set(i, null);\n    }\n    this._clippingContextListForMask = null;\n\n    // _clippingContextListForDrawは_clippingContextListForMaskにあるインスタンスを指している。上記の処理により要素ごとのDELETEは不要。\n    for (let i = 0; i < this._clippingContextListForDraw.getSize(); i++) {\n      this._clippingContextListForDraw.set(i, null);\n    }\n    this._clippingContextListForDraw = null;\n    if (this._maskTexture) {\n      for (let i = 0; i < this._maskTexture.textures.getSize(); i++) {\n        this.gl.deleteFramebuffer(this._maskTexture.textures.at(i));\n      }\n      this._maskTexture.textures.clear();\n      this._maskTexture.textures = null;\n      this._maskTexture = null;\n    }\n    for (let i = 0; i < this._channelColors.getSize(); i++) {\n      this._channelColors.set(i, null);\n    }\n    this._channelColors = null;\n\n    // テクスチャ解放\n    if (this._maskColorBuffers != null) {\n      for (let index = 0; index < this._maskColorBuffers.getSize(); index++) {\n        this.gl.deleteTexture(this._maskColorBuffers.at(index));\n      }\n      this._maskColorBuffers.clear();\n    }\n    this._maskColorBuffers = null;\n    if (this._maskRenderTextures != null) {\n      this._maskRenderTextures.clear();\n    }\n    this._maskRenderTextures = null;\n    if (this._clearedFrameBufferflags != null) {\n      this._clearedFrameBufferflags.clear();\n    }\n    this._clearedFrameBufferflags = null;\n  }\n\n  /**\n   * マネージャの初期化処理\n   * クリッピングマスクを使う描画オブジェクトの登録を行う\n   * @param model モデルのインスタンス\n   * @param drawableCount 描画オブジェクトの数\n   * @param drawableMasks 描画オブジェクトをマスクする描画オブジェクトのインデックスのリスト\n   * @param drawableMaskCounts 描画オブジェクトをマスクする描画オブジェクトの数\n   * @param renderTextureCount バッファの生成数\n   */\n  initialize(model, drawableCount, drawableMasks, drawableMaskCounts, renderTextureCount) {\n    // レンダーテクスチャの合計枚数の設定\n    // 1以上の整数でない場合はそれぞれ警告を出す\n    if (renderTextureCount % 1 != 0) {\n      CubismLogWarning('The number of render textures must be specified as an integer. The decimal point is rounded down and corrected to an integer.');\n      // 小数点以下を除去\n      renderTextureCount = ~~renderTextureCount;\n    }\n    if (renderTextureCount < 1) {\n      CubismLogWarning('The number of render textures must be an integer greater than or equal to 1. Set the number of render textures to 1.');\n    }\n    // 負の値が使われている場合は強制的に1枚と設定する\n    this._renderTextureCount = renderTextureCount < 1 ? 1 : renderTextureCount;\n    this._clearedFrameBufferflags = new csmVector(this._renderTextureCount);\n\n    // クリッピングマスクを使う描画オブジェクトをすべて登録する\n    // クリッピングマスクは、通常数個程度に限定して使うものとする\n    for (let i = 0; i < drawableCount; i++) {\n      if (drawableMaskCounts[i] <= 0) {\n        // クリッピングマスクが使用されていないアートメッシュ（多くの場合使用しない）\n        this._clippingContextListForDraw.pushBack(null);\n        continue;\n      }\n\n      // 既にあるClipContextと同じかチェックする\n      let clippingContext = this.findSameClip(drawableMasks[i], drawableMaskCounts[i]);\n      if (clippingContext == null) {\n        // 同一のマスクが存在していない場合は生成する\n        clippingContext = new CubismClippingContext(this, drawableMasks[i], drawableMaskCounts[i]);\n        this._clippingContextListForMask.pushBack(clippingContext);\n      }\n      clippingContext.addClippedDrawable(i);\n      this._clippingContextListForDraw.pushBack(clippingContext);\n    }\n  }\n\n  /**\n   * クリッピングコンテキストを作成する。モデル描画時に実行する。\n   * @param model モデルのインスタンス\n   * @param renderer レンダラのインスタンス\n   */\n  setupClippingContext(model, renderer) {\n    this._currentFrameNo++;\n\n    // 全てのクリッピングを用意する\n    // 同じクリップ（複数の場合はまとめて一つのクリップ）を使う場合は1度だけ設定する\n    let usingClipCount = 0;\n    for (let clipIndex = 0; clipIndex < this._clippingContextListForMask.getSize(); clipIndex++) {\n      // 1つのクリッピングマスクに関して\n      const cc = this._clippingContextListForMask.at(clipIndex);\n\n      // このクリップを利用する描画オブジェクト群全体を囲む矩形を計算\n      this.calcClippedDrawTotalBounds(model, cc);\n      if (cc._isUsing) {\n        usingClipCount++; // 使用中としてカウント\n      }\n    }\n\n    // マスク作成処理\n    if (usingClipCount > 0) {\n      // 各マスクのレイアウトを決定していく\n      this.setupLayoutBounds(renderer.isUsingHighPrecisionMask() ? 0 : usingClipCount);\n      if (!renderer.isUsingHighPrecisionMask()) {\n        // 生成したFrameBufferと同じサイズでビューポートを設定\n        this.gl.viewport(0, 0, this._clippingMaskBufferSize, this._clippingMaskBufferSize);\n\n        // 後の計算のためにインデックスの最初をセット\n        this._currentMaskRenderTexture = this.getMaskRenderTexture().at(0);\n        renderer.preDraw(); // バッファをクリアする\n\n        // ---------- マスク描画処理 ----------\n        // マスク用RenderTextureをactiveにセット\n        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this._currentMaskRenderTexture);\n      }\n\n      // サイズがレンダーテクスチャの枚数と合わない場合は合わせる\n      if (this._clearedFrameBufferflags.getSize() != this._renderTextureCount) {\n        this._clearedFrameBufferflags.clear();\n        this._clearedFrameBufferflags = new csmVector(this._renderTextureCount);\n      }\n\n      // マスクのクリアフラグを毎フレーム開始時に初期化\n      for (let index = 0; index < this._clearedFrameBufferflags.getSize(); index++) {\n        this._clearedFrameBufferflags.set(index, false);\n      }\n\n      // 実際にマスクを生成する\n      // 全てのマスクをどのようにレイアウトして描くかを決定し、ClipContext, ClippedDrawContextに記憶する\n      for (let clipIndex = 0; clipIndex < this._clippingContextListForMask.getSize(); clipIndex++) {\n        // --- 実際に1つのマスクを描く ---\n        const clipContext = this._clippingContextListForMask.at(clipIndex);\n        const allClipedDrawRect = clipContext._allClippedDrawRect; // このマスクを使う、すべての描画オブジェクトの論理座標上の囲み矩形\n        const layoutBoundsOnTex01 = clipContext._layoutBounds; // この中にマスクを収める\n        const MARGIN = 0.05; // モデル座標上の矩形を、適宜マージンを付けて使う\n        let scaleX = 0;\n        let scaleY = 0;\n\n        // clipContextに設定したレンダーテクスチャをインデックスで取得\n        const clipContextRenderTexture = this.getMaskRenderTexture().at(clipContext._bufferIndex);\n\n        // 現在のレンダーテクスチャがclipContextのものと異なる場合\n        if (this._currentMaskRenderTexture != clipContextRenderTexture && !renderer.isUsingHighPrecisionMask()) {\n          this._currentMaskRenderTexture = clipContextRenderTexture;\n          renderer.preDraw(); // バッファをクリアする\n          // マスク用RenderTextureをactiveにセット\n          this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this._currentMaskRenderTexture);\n        }\n        if (renderer.isUsingHighPrecisionMask()) {\n          const ppu = model.getPixelsPerUnit();\n          const maskPixelSize = clipContext.getClippingManager()._clippingMaskBufferSize;\n          const physicalMaskWidth = layoutBoundsOnTex01.width * maskPixelSize;\n          const physicalMaskHeight = layoutBoundsOnTex01.height * maskPixelSize;\n          this._tmpBoundsOnModel.setRect(allClipedDrawRect);\n          if (this._tmpBoundsOnModel.width * ppu > physicalMaskWidth) {\n            this._tmpBoundsOnModel.expand(allClipedDrawRect.width * MARGIN, 0.0);\n            scaleX = layoutBoundsOnTex01.width / this._tmpBoundsOnModel.width;\n          } else {\n            scaleX = ppu / physicalMaskWidth;\n          }\n          if (this._tmpBoundsOnModel.height * ppu > physicalMaskHeight) {\n            this._tmpBoundsOnModel.expand(0.0, allClipedDrawRect.height * MARGIN);\n            scaleY = layoutBoundsOnTex01.height / this._tmpBoundsOnModel.height;\n          } else {\n            scaleY = ppu / physicalMaskHeight;\n          }\n        } else {\n          this._tmpBoundsOnModel.setRect(allClipedDrawRect);\n          this._tmpBoundsOnModel.expand(allClipedDrawRect.width * MARGIN, allClipedDrawRect.height * MARGIN);\n          //########## 本来は割り当てられた領域の全体を使わず必要最低限のサイズがよい\n\n          // シェーダ用の計算式を求める。回転を考慮しない場合は以下のとおり\n          // movePeriod' = movePeriod * scaleX + offX\t\t  [[ movePeriod' = (movePeriod - tmpBoundsOnModel.movePeriod)*scale + layoutBoundsOnTex01.movePeriod ]]\n          scaleX = layoutBoundsOnTex01.width / this._tmpBoundsOnModel.width;\n          scaleY = layoutBoundsOnTex01.height / this._tmpBoundsOnModel.height;\n        }\n\n        // マスク生成時に使う行列を求める\n        {\n          // シェーダに渡す行列を求める <<<<<<<<<<<<<<<<<<<<<<<< 要最適化（逆順に計算すればシンプルにできる）\n          this._tmpMatrix.loadIdentity();\n          {\n            // layout0..1 を -1..1に変換\n            this._tmpMatrix.translateRelative(-1.0, -1.0);\n            this._tmpMatrix.scaleRelative(2.0, 2.0);\n          }\n          {\n            // view to layout0..1\n            this._tmpMatrix.translateRelative(layoutBoundsOnTex01.x, layoutBoundsOnTex01.y);\n            this._tmpMatrix.scaleRelative(scaleX, scaleY); // new = [translate][scale]\n            this._tmpMatrix.translateRelative(-this._tmpBoundsOnModel.x, -this._tmpBoundsOnModel.y);\n            // new = [translate][scale][translate]\n          }\n          // tmpMatrixForMaskが計算結果\n          this._tmpMatrixForMask.setMatrix(this._tmpMatrix.getArray());\n        }\n\n        //--------- draw時の mask 参照用行列を計算\n        {\n          // シェーダに渡す行列を求める <<<<<<<<<<<<<<<<<<<<<<<< 要最適化（逆順に計算すればシンプルにできる）\n          this._tmpMatrix.loadIdentity();\n          {\n            this._tmpMatrix.translateRelative(layoutBoundsOnTex01.x, layoutBoundsOnTex01.y);\n            this._tmpMatrix.scaleRelative(scaleX, scaleY); // new = [translate][scale]\n            this._tmpMatrix.translateRelative(-this._tmpBoundsOnModel.x, -this._tmpBoundsOnModel.y);\n            // new = [translate][scale][translate]\n          }\n\n          this._tmpMatrixForDraw.setMatrix(this._tmpMatrix.getArray());\n        }\n        clipContext._matrixForMask.setMatrix(this._tmpMatrixForMask.getArray());\n        clipContext._matrixForDraw.setMatrix(this._tmpMatrixForDraw.getArray());\n        if (!renderer.isUsingHighPrecisionMask()) {\n          const clipDrawCount = clipContext._clippingIdCount;\n          for (let i = 0; i < clipDrawCount; i++) {\n            const clipDrawIndex = clipContext._clippingIdList[i];\n\n            // 頂点情報が更新されておらず、信頼性がない場合は描画をパスする\n            if (!model.getDrawableDynamicFlagVertexPositionsDidChange(clipDrawIndex)) {\n              continue;\n            }\n            renderer.setIsCulling(model.getDrawableCulling(clipDrawIndex) != false);\n\n            // マスクがクリアされていないなら処理する\n            if (!this._clearedFrameBufferflags.at(clipContext._bufferIndex)) {\n              // マスクをクリアする\n              // (仮仕様) 1が無効（描かれない）領域、0が有効（描かれる）領域。（シェーダーCd*Csで0に近い値をかけてマスクを作る。1をかけると何も起こらない）\n              this.gl.clearColor(1.0, 1.0, 1.0, 1.0);\n              this.gl.clear(this.gl.COLOR_BUFFER_BIT);\n              this._clearedFrameBufferflags.set(clipContext._bufferIndex, true);\n            }\n\n            // 今回専用の変換を適用して描く\n            // チャンネルも切り替える必要がある(A,R,G,B)\n            renderer.setClippingContextBufferForMask(clipContext);\n            renderer.drawMesh(model.getDrawableTextureIndex(clipDrawIndex), model.getDrawableVertexIndexCount(clipDrawIndex), model.getDrawableVertexCount(clipDrawIndex), model.getDrawableVertexIndices(clipDrawIndex), model.getDrawableVertices(clipDrawIndex), model.getDrawableVertexUvs(clipDrawIndex), model.getMultiplyColor(clipDrawIndex), model.getScreenColor(clipDrawIndex), model.getDrawableOpacity(clipDrawIndex), CubismBlendMode.CubismBlendMode_Normal,\n            // クリッピングは通常描画を強制\n            false // マスク生成時はクリッピングの反転使用は全く関係がない\n            );\n          }\n        }\n      }\n\n      if (!renderer.isUsingHighPrecisionMask()) {\n        // --- 後処理 ---\n        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, s_fbo); // 描画対象を戻す\n        renderer.setClippingContextBufferForMask(null);\n        this.gl.viewport(s_viewport[0], s_viewport[1], s_viewport[2], s_viewport[3]);\n      }\n    }\n  }\n\n  /**\n   * 既にマスクを作っているかを確認\n   * 作っている様であれば該当するクリッピングマスクのインスタンスを返す\n   * 作っていなければNULLを返す\n   * @param drawableMasks 描画オブジェクトをマスクする描画オブジェクトのリスト\n   * @param drawableMaskCounts 描画オブジェクトをマスクする描画オブジェクトの数\n   * @return 該当するクリッピングマスクが存在すればインスタンスを返し、なければNULLを返す\n   */\n  findSameClip(drawableMasks, drawableMaskCounts) {\n    // 作成済みClippingContextと一致するか確認\n    for (let i = 0; i < this._clippingContextListForMask.getSize(); i++) {\n      const clippingContext = this._clippingContextListForMask.at(i);\n      const count = clippingContext._clippingIdCount;\n\n      // 個数が違う場合は別物\n      if (count != drawableMaskCounts) {\n        continue;\n      }\n      let sameCount = 0;\n\n      // 同じIDを持つか確認。配列の数が同じなので、一致した個数が同じなら同じ物を持つとする\n      for (let j = 0; j < count; j++) {\n        const clipId = clippingContext._clippingIdList[j];\n        for (let k = 0; k < count; k++) {\n          if (drawableMasks[k] == clipId) {\n            sameCount++;\n            break;\n          }\n        }\n      }\n      if (sameCount == count) {\n        return clippingContext;\n      }\n    }\n    return null; // 見つからなかった\n  }\n\n  /**\n   * クリッピングコンテキストを配置するレイアウト\n   * 指定された数のレンダーテクスチャを極力いっぱいに使ってマスクをレイアウトする\n   * マスクグループの数が4以下ならRGBA各チャンネルに一つずつマスクを配置し、5以上6以下ならRGBAを2,2,1,1と配置する。\n   *\n   * @param usingClipCount 配置するクリッピングコンテキストの数\n   */\n  setupLayoutBounds(usingClipCount) {\n    const useClippingMaskMaxCount = this._renderTextureCount <= 1 ? ClippingMaskMaxCountOnDefault : ClippingMaskMaxCountOnMultiRenderTexture * this._renderTextureCount;\n    if (usingClipCount <= 0 || usingClipCount > useClippingMaskMaxCount) {\n      if (usingClipCount > useClippingMaskMaxCount) {\n        // マスクの制限数の警告を出す\n        CubismLogError('not supported mask count : {0}\\n[Details] render texture count : {1}, mask count : {2}', usingClipCount - useClippingMaskMaxCount, this._renderTextureCount, usingClipCount);\n      }\n      // この場合は一つのマスクターゲットを毎回クリアして使用する\n      for (let index = 0; index < this._clippingContextListForMask.getSize(); index++) {\n        const clipContext = this._clippingContextListForMask.at(index);\n        clipContext._layoutChannelNo = 0; // どうせ毎回消すので固定\n        clipContext._layoutBounds.x = 0.0;\n        clipContext._layoutBounds.y = 0.0;\n        clipContext._layoutBounds.width = 1.0;\n        clipContext._layoutBounds.height = 1.0;\n        clipContext._bufferIndex = 0;\n      }\n      return;\n    }\n\n    // レンダーテクスチャが1枚なら9分割する（最大36枚）\n    const layoutCountMaxValue = this._renderTextureCount <= 1 ? 9 : 8;\n\n    // 指定された数のレンダーテクスチャを極力いっぱいに使ってマスクをレイアウトする（デフォルトなら1）\n    // マスクグループの数が4以下ならRGBA各チャンネルに1つずつマスクを配置し、5以上6以下ならRGBAを2,2,1,1と配置する\n    let countPerSheetDiv = usingClipCount / this._renderTextureCount; // レンダーテクスチャ1枚あたり何枚割り当てるか\n    let countPerSheetMod = usingClipCount % this._renderTextureCount; // この番号のレンダーテクスチャまでに一つずつ配分する\n\n    // 小数点は切り捨てる\n    countPerSheetDiv = ~~countPerSheetDiv;\n    countPerSheetMod = ~~countPerSheetMod;\n\n    // RGBAを順番に使っていく\n    let div = countPerSheetDiv / ColorChannelCount; // 1チャンネルに配置する基本のマスク\n    let mod = countPerSheetDiv % ColorChannelCount; // 余り、この番号のチャンネルまでに一つずつ配分する\n\n    // 小数点は切り捨てる\n    div = ~~div;\n    mod = ~~mod;\n\n    // RGBAそれぞれのチャンネルを用意していく（0:R, 1:G, 2:B, 3:A）\n    let curClipIndex = 0; // 順番に設定していく\n\n    for (let renderTextureNo = 0; renderTextureNo < this._renderTextureCount; renderTextureNo++) {\n      for (let channelNo = 0; channelNo < ColorChannelCount; channelNo++) {\n        // このチャンネルにレイアウトする数\n        let layoutCount = div + (channelNo < mod ? 1 : 0);\n\n        // このレンダーテクスチャにまだ割り当てられていなければ追加する\n        const checkChannelNo = mod + 1 >= ColorChannelCount ? 0 : mod + 1;\n        if (layoutCount < layoutCountMaxValue && channelNo == checkChannelNo) {\n          layoutCount += renderTextureNo < countPerSheetMod ? 1 : 0;\n        }\n\n        // 分割方法を決定する\n        if (layoutCount == 0) {\n          // 何もしない\n        } else if (layoutCount == 1) {\n          // 全てをそのまま使う\n          const clipContext = this._clippingContextListForMask.at(curClipIndex++);\n          clipContext._layoutChannelNo = channelNo;\n          clipContext._layoutBounds.x = 0.0;\n          clipContext._layoutBounds.y = 0.0;\n          clipContext._layoutBounds.width = 1.0;\n          clipContext._layoutBounds.height = 1.0;\n          clipContext._bufferIndex = renderTextureNo;\n        } else if (layoutCount == 2) {\n          for (let i = 0; i < layoutCount; i++) {\n            let xpos = i % 2;\n\n            // 小数点は切り捨てる\n            xpos = ~~xpos;\n            const cc = this._clippingContextListForMask.at(curClipIndex++);\n            cc._layoutChannelNo = channelNo;\n\n            // UVを2つに分解して使う\n            cc._layoutBounds.x = xpos * 0.5;\n            cc._layoutBounds.y = 0.0;\n            cc._layoutBounds.width = 0.5;\n            cc._layoutBounds.height = 1.0;\n            cc._bufferIndex = renderTextureNo;\n          }\n        } else if (layoutCount <= 4) {\n          // 4分割して使う\n          for (let i = 0; i < layoutCount; i++) {\n            let xpos = i % 2;\n            let ypos = i / 2;\n\n            // 小数点は切り捨てる\n            xpos = ~~xpos;\n            ypos = ~~ypos;\n            const cc = this._clippingContextListForMask.at(curClipIndex++);\n            cc._layoutChannelNo = channelNo;\n            cc._layoutBounds.x = xpos * 0.5;\n            cc._layoutBounds.y = ypos * 0.5;\n            cc._layoutBounds.width = 0.5;\n            cc._layoutBounds.height = 0.5;\n            cc._bufferIndex = renderTextureNo;\n          }\n        } else if (layoutCount <= layoutCountMaxValue) {\n          // 9分割して使う\n          for (let i = 0; i < layoutCount; i++) {\n            let xpos = i % 3;\n            let ypos = i / 3;\n\n            // 小数点は切り捨てる\n            xpos = ~~xpos;\n            ypos = ~~ypos;\n            const cc = this._clippingContextListForMask.at(curClipIndex++);\n            cc._layoutChannelNo = channelNo;\n            cc._layoutBounds.x = xpos / 3.0;\n            cc._layoutBounds.y = ypos / 3.0;\n            cc._layoutBounds.width = 1.0 / 3.0;\n            cc._layoutBounds.height = 1.0 / 3.0;\n            cc._bufferIndex = renderTextureNo;\n          }\n        } else {\n          // マスクの制限枚数を超えた場合の処理\n          CubismLogError('not supported mask count : {0}\\n[Details] render texture count : {1}, mask count : {2}', usingClipCount - useClippingMaskMaxCount, this._renderTextureCount, usingClipCount);\n\n          // SetupShaderProgramでオーバーアクセスが発生するので仮で数値を入れる\n          // もちろん描画結果は正しいものではなくなる\n          for (let index = 0; index < layoutCount; index++) {\n            const cc = this._clippingContextListForMask.at(curClipIndex++);\n            cc._layoutChannelNo = 0;\n            cc._layoutBounds.x = 0.0;\n            cc._layoutBounds.y = 0.0;\n            cc._layoutBounds.width = 1.0;\n            cc._layoutBounds.height = 1.0;\n            cc._bufferIndex = 0;\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * カラーバッファを取得する\n   * @return カラーバッファ\n   */\n  getColorBuffer() {\n    return this._maskColorBuffers;\n  }\n\n  /**\n   * 画面描画に使用するクリッピングマスクのリストを取得する\n   * @return 画面描画に使用するクリッピングマスクのリスト\n   */\n  getClippingContextListForDraw() {\n    return this._clippingContextListForDraw;\n  }\n\n  /**\n   * マスクの合計数をカウント\n   * @returns\n   */\n  getClippingMaskCount() {\n    return this._clippingContextListForMask.getSize();\n  }\n\n  /**\n   * クリッピングマスクバッファのサイズを設定する\n   * @param size クリッピングマスクバッファのサイズ\n   */\n  setClippingMaskBufferSize(size) {\n    this._clippingMaskBufferSize = size;\n  }\n\n  /**\n   * クリッピングマスクバッファのサイズを取得する\n   * @return クリッピングマスクバッファのサイズ\n   */\n  getClippingMaskBufferSize() {\n    return this._clippingMaskBufferSize;\n  }\n\n  /**\n   * このバッファのレンダーテクスチャの枚数を取得する\n   * @return このバッファのレンダーテクスチャの枚数\n   */\n  getRenderTextureCount() {\n    return this._renderTextureCount;\n  }\n\n  // WebGLレンダリングコンテキスト\n}\n\n/**\n * レンダーテクスチャのリソースを定義する構造体\n * クリッピングマスクで使用する\n */\nexport class CubismRenderTextureResource {\n  /**\n   * 引数付きコンストラクタ\n   * @param frameNo レンダラーのフレーム番号\n   * @param texture テクスチャのアドレス\n   */\n  constructor(frameNo, texture) {\n    this.frameNo = void 0;\n    // レンダラのフレーム番号\n    this.textures = void 0;\n    this.frameNo = frameNo;\n    this.textures = texture;\n  }\n\n  // テクスチャのアドレス\n}\n\n/**\n * クリッピングマスクのコンテキスト\n */\nexport class CubismClippingContext {\n  /**\n   * 引数付きコンストラクタ\n   */\n  constructor(manager, clippingDrawableIndices, clipCount) {\n    this._isUsing = void 0;\n    // 現在の描画状態でマスクの準備が必要ならtrue\n    this._clippingIdList = void 0;\n    // クリッピングマスクのIDリスト\n    this._clippingIdCount = void 0;\n    // クリッピングマスクの数\n    this._layoutChannelNo = void 0;\n    // RGBAのいずれのチャンネルにこのクリップを配置するか（0:R, 1:G, 2:B, 3:A）\n    this._layoutBounds = void 0;\n    // マスク用チャンネルのどの領域にマスクを入れるか（View座標-1~1, UVは0~1に直す）\n    this._allClippedDrawRect = void 0;\n    // このクリッピングで、クリッピングされるすべての描画オブジェクトの囲み矩形（毎回更新）\n    this._matrixForMask = void 0;\n    // マスクの位置計算結果を保持する行列\n    this._matrixForDraw = void 0;\n    // 描画オブジェクトの位置計算結果を保持する行列\n    this._clippedDrawableIndexList = void 0;\n    // このマスクにクリップされる描画オブジェクトのリスト\n    this._bufferIndex = void 0;\n    // このマスクが割り当てられるレンダーテクスチャ（フレームバッファ）やカラーバッファのインデックス\n    this._owner = void 0;\n    this._owner = manager;\n\n    // クリップしている（＝マスク用の）Drawableのインデックスリスト\n    this._clippingIdList = clippingDrawableIndices;\n\n    // マスクの数\n    this._clippingIdCount = clipCount;\n    this._allClippedDrawRect = new csmRect();\n    this._layoutBounds = new csmRect();\n    this._clippedDrawableIndexList = [];\n    this._matrixForMask = new CubismMatrix44();\n    this._matrixForDraw = new CubismMatrix44();\n    this._bufferIndex = 0;\n  }\n\n  /**\n   * デストラクタ相当の処理\n   */\n  release() {\n    if (this._layoutBounds != null) {\n      this._layoutBounds = null;\n    }\n    if (this._allClippedDrawRect != null) {\n      this._allClippedDrawRect = null;\n    }\n    if (this._clippedDrawableIndexList != null) {\n      this._clippedDrawableIndexList = null;\n    }\n  }\n\n  /**\n   * このマスクにクリップされる描画オブジェクトを追加する\n   *\n   * @param drawableIndex クリッピング対象に追加する描画オブジェクトのインデックス\n   */\n  addClippedDrawable(drawableIndex) {\n    this._clippedDrawableIndexList.push(drawableIndex);\n  }\n\n  /**\n   * このマスクを管理するマネージャのインスタンスを取得する\n   * @return クリッピングマネージャのインスタンス\n   */\n  getClippingManager() {\n    return this._owner;\n  }\n  setGl(gl) {\n    this._owner.setGL(gl);\n  }\n\n  // このマスクを管理しているマネージャのインスタンス\n}\n\nexport class CubismRendererProfile_WebGL {\n  setGlEnable(index, enabled) {\n    if (enabled) this.gl.enable(index);else this.gl.disable(index);\n  }\n  setGlEnableVertexAttribArray(index, enabled) {\n    if (enabled) this.gl.enableVertexAttribArray(index);else this.gl.disableVertexAttribArray(index);\n  }\n  save() {\n    if (this.gl == null) {\n      CubismLogError(\"'gl' is null. WebGLRenderingContext is required.\\nPlease call 'CubimRenderer_WebGL.startUp' function.\");\n      return;\n    }\n    //-- push state --\n    this._lastArrayBufferBinding = this.gl.getParameter(this.gl.ARRAY_BUFFER_BINDING);\n    this._lastArrayBufferBinding = this.gl.getParameter(this.gl.ELEMENT_ARRAY_BUFFER_BINDING);\n    this._lastProgram = this.gl.getParameter(this.gl.CURRENT_PROGRAM);\n    this._lastActiveTexture = this.gl.getParameter(this.gl.ACTIVE_TEXTURE);\n    this.gl.activeTexture(this.gl.TEXTURE1); //テクスチャユニット1をアクティブに（以後の設定対象とする）\n    this._lastTexture1Binding2D = this.gl.getParameter(this.gl.TEXTURE_BINDING_2D);\n    this.gl.activeTexture(this.gl.TEXTURE0); //テクスチャユニット0をアクティブに（以後の設定対象とする）\n    this._lastTexture0Binding2D = this.gl.getParameter(this.gl.TEXTURE_BINDING_2D);\n    this._lastVertexAttribArrayEnabled[0] = this.gl.getVertexAttrib(0, this.gl.VERTEX_ATTRIB_ARRAY_ENABLED);\n    this._lastVertexAttribArrayEnabled[1] = this.gl.getVertexAttrib(1, this.gl.VERTEX_ATTRIB_ARRAY_ENABLED);\n    this._lastVertexAttribArrayEnabled[2] = this.gl.getVertexAttrib(2, this.gl.VERTEX_ATTRIB_ARRAY_ENABLED);\n    this._lastVertexAttribArrayEnabled[3] = this.gl.getVertexAttrib(3, this.gl.VERTEX_ATTRIB_ARRAY_ENABLED);\n    this._lastScissorTest = this.gl.isEnabled(this.gl.SCISSOR_TEST);\n    this._lastStencilTest = this.gl.isEnabled(this.gl.STENCIL_TEST);\n    this._lastDepthTest = this.gl.isEnabled(this.gl.DEPTH_TEST);\n    this._lastCullFace = this.gl.isEnabled(this.gl.CULL_FACE);\n    this._lastBlend = this.gl.isEnabled(this.gl.BLEND);\n    this._lastFrontFace = this.gl.getParameter(this.gl.FRONT_FACE);\n    this._lastColorMask = this.gl.getParameter(this.gl.COLOR_WRITEMASK);\n\n    // backup blending\n    this._lastBlending[0] = this.gl.getParameter(this.gl.BLEND_SRC_RGB);\n    this._lastBlending[1] = this.gl.getParameter(this.gl.BLEND_DST_RGB);\n    this._lastBlending[2] = this.gl.getParameter(this.gl.BLEND_SRC_ALPHA);\n    this._lastBlending[3] = this.gl.getParameter(this.gl.BLEND_DST_ALPHA);\n\n    // モデル描画直前のFBOとビューポートを保存\n    this._lastFBO = this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING);\n    this._lastViewport = this.gl.getParameter(this.gl.VIEWPORT);\n  }\n  restore() {\n    if (this.gl == null) {\n      CubismLogError(\"'gl' is null. WebGLRenderingContext is required.\\nPlease call 'CubimRenderer_WebGL.startUp' function.\");\n      return;\n    }\n    this.gl.useProgram(this._lastProgram);\n    this.setGlEnableVertexAttribArray(0, this._lastVertexAttribArrayEnabled[0]);\n    this.setGlEnableVertexAttribArray(1, this._lastVertexAttribArrayEnabled[1]);\n    this.setGlEnableVertexAttribArray(2, this._lastVertexAttribArrayEnabled[2]);\n    this.setGlEnableVertexAttribArray(3, this._lastVertexAttribArrayEnabled[3]);\n    this.setGlEnable(this.gl.SCISSOR_TEST, this._lastScissorTest);\n    this.setGlEnable(this.gl.STENCIL_TEST, this._lastStencilTest);\n    this.setGlEnable(this.gl.DEPTH_TEST, this._lastDepthTest);\n    this.setGlEnable(this.gl.CULL_FACE, this._lastCullFace);\n    this.setGlEnable(this.gl.BLEND, this._lastBlend);\n    this.gl.frontFace(this._lastFrontFace);\n    this.gl.colorMask(this._lastColorMask[0], this._lastColorMask[1], this._lastColorMask[2], this._lastColorMask[3]);\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this._lastArrayBufferBinding); //前にバッファがバインドされていたら破棄する必要がある\n    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this._lastElementArrayBufferBinding);\n    this.gl.activeTexture(this.gl.TEXTURE1); //テクスチャユニット1を復元\n    this.gl.bindTexture(this.gl.TEXTURE_2D, this._lastTexture1Binding2D);\n    this.gl.activeTexture(this.gl.TEXTURE0); //テクスチャユニット0を復元\n    this.gl.bindTexture(this.gl.TEXTURE_2D, this._lastTexture0Binding2D);\n    this.gl.activeTexture(this._lastActiveTexture);\n    this.gl.blendFuncSeparate(this._lastBlending[0], this._lastBlending[1], this._lastBlending[2], this._lastBlending[3]);\n  }\n  setGl(gl) {\n    this.gl = gl;\n  }\n  constructor() {\n    this._lastArrayBufferBinding = void 0;\n    ///< モデル描画直前の頂点バッファ\n    this._lastElementArrayBufferBinding = void 0;\n    ///< モデル描画直前のElementバッファ\n    this._lastProgram = void 0;\n    ///< モデル描画直前のシェーダプログラムバッファ\n    this._lastActiveTexture = void 0;\n    ///< モデル描画直前のアクティブなテクスチャ\n    this._lastTexture0Binding2D = void 0;\n    ///< モデル描画直前のテクスチャユニット0\n    this._lastTexture1Binding2D = void 0;\n    ///< モデル描画直前のテクスチャユニット1\n    this._lastVertexAttribArrayEnabled = void 0;\n    ///< モデル描画直前のテクスチャユニット1\n    this._lastScissorTest = void 0;\n    ///< モデル描画直前のGL_VERTEX_ATTRIB_ARRAY_ENABLEDパラメータ\n    this._lastBlend = void 0;\n    ///< モデル描画直前のGL_SCISSOR_TESTパラメータ\n    this._lastStencilTest = void 0;\n    ///< モデル描画直前のGL_STENCIL_TESTパラメータ\n    this._lastDepthTest = void 0;\n    ///< モデル描画直前のGL_DEPTH_TESTパラメータ\n    this._lastCullFace = void 0;\n    ///< モデル描画直前のGL_CULL_FACEパラメータ\n    this._lastFrontFace = void 0;\n    ///< モデル描画直前のGL_CULL_FACEパラメータ\n    this._lastColorMask = void 0;\n    ///< モデル描画直前のGL_COLOR_WRITEMASKパラメータ\n    this._lastBlending = void 0;\n    ///< モデル描画直前のカラーブレンディングパラメータ\n    this._lastFBO = void 0;\n    ///< モデル描画直前のフレームバッファ\n    this._lastViewport = void 0;\n    ///< モデル描画直前のビューポート\n    this.gl = void 0;\n    this._lastVertexAttribArrayEnabled = new Array(4);\n    this._lastColorMask = new Array(4);\n    this._lastBlending = new Array(4);\n    this._lastViewport = new Array(4);\n  }\n}\n\n/**\n * WebGL用のシェーダープログラムを生成・破棄するクラス\n * シングルトンなクラスであり、CubismShader_WebGL.getInstanceからアクセスする。\n */\nexport class CubismShader_WebGL {\n  /**\n   * インスタンスを取得する（シングルトン）\n   * @return インスタンス\n   */\n  static getInstance() {\n    if (s_instance == null) {\n      s_instance = new CubismShader_WebGL();\n      return s_instance;\n    }\n    return s_instance;\n  }\n\n  /**\n   * インスタンスを開放する（シングルトン）\n   */\n  static deleteInstance() {\n    if (s_instance) {\n      s_instance.release();\n      s_instance = null;\n    }\n  }\n\n  /**\n   * privateなコンストラクタ\n   */\n  constructor() {\n    this._shaderSets = void 0;\n    // ロードしたシェーダープログラムを保持する変数\n    this.gl = void 0;\n    this._shaderSets = new csmVector();\n  }\n\n  /**\n   * デストラクタ相当の処理\n   */\n  release() {\n    this.releaseShaderProgram();\n  }\n\n  /**\n   * シェーダープログラムの一連のセットアップを実行する\n   * @param renderer レンダラのインスタンス\n   * @param textureId GPUのテクスチャID\n   * @param vertexCount ポリゴンメッシュの頂点数\n   * @param vertexArray ポリゴンメッシュの頂点配列\n   * @param indexArray インデックスバッファの頂点配列\n   * @param uvArray uv配列\n   * @param opacity 不透明度\n   * @param colorBlendMode カラーブレンディングのタイプ\n   * @param baseColor ベースカラー\n   * @param isPremultipliedAlpha 乗算済みアルファかどうか\n   * @param matrix4x4 Model-View-Projection行列\n   * @param invertedMask マスクを反転して使用するフラグ\n   */\n  setupShaderProgram(renderer, textureId, vertexCount, vertexArray, indexArray, uvArray, bufferData, opacity, colorBlendMode, baseColor, multiplyColor, screenColor, isPremultipliedAlpha, matrix4x4, invertedMask) {\n    if (!isPremultipliedAlpha) {\n      CubismLogError('NoPremultipliedAlpha is not allowed');\n    }\n    if (this._shaderSets.getSize() == 0) {\n      this.generateShaders();\n    }\n\n    // Blending\n    let SRC_COLOR;\n    let DST_COLOR;\n    let SRC_ALPHA;\n    let DST_ALPHA;\n    if (renderer.getClippingContextBufferForMask() != null) {\n      // マスク生成時\n      const shaderSet = this._shaderSets.at(ShaderNames.ShaderNames_SetupMask);\n      this.gl.useProgram(shaderSet.shaderProgram);\n\n      // テクスチャ設定\n      this.gl.activeTexture(this.gl.TEXTURE0);\n      this.gl.bindTexture(this.gl.TEXTURE_2D, textureId);\n      this.gl.uniform1i(shaderSet.samplerTexture0Location, 0);\n\n      // 頂点配列の設定(VBO)\n      if (bufferData.vertex == null) {\n        bufferData.vertex = this.gl.createBuffer();\n      }\n      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, bufferData.vertex);\n      this.gl.bufferData(this.gl.ARRAY_BUFFER, vertexArray, this.gl.DYNAMIC_DRAW);\n      this.gl.enableVertexAttribArray(shaderSet.attributePositionLocation);\n      this.gl.vertexAttribPointer(shaderSet.attributePositionLocation, 2, this.gl.FLOAT, false, 0, 0);\n\n      // テクスチャ頂点の設定\n      if (bufferData.uv == null) {\n        bufferData.uv = this.gl.createBuffer();\n      }\n      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, bufferData.uv);\n      this.gl.bufferData(this.gl.ARRAY_BUFFER, uvArray, this.gl.DYNAMIC_DRAW);\n      this.gl.enableVertexAttribArray(shaderSet.attributeTexCoordLocation);\n      this.gl.vertexAttribPointer(shaderSet.attributeTexCoordLocation, 2, this.gl.FLOAT, false, 0, 0);\n\n      // チャンネル\n      const channelNo = renderer.getClippingContextBufferForMask()._layoutChannelNo;\n      const colorChannel = renderer.getClippingContextBufferForMask().getClippingManager().getChannelFlagAsColor(channelNo);\n      this.gl.uniform4f(shaderSet.uniformChannelFlagLocation, colorChannel.R, colorChannel.G, colorChannel.B, colorChannel.A);\n      this.gl.uniformMatrix4fv(shaderSet.uniformClipMatrixLocation, false, renderer.getClippingContextBufferForMask()._matrixForMask.getArray());\n      const rect = renderer.getClippingContextBufferForMask()._layoutBounds;\n      this.gl.uniform4f(shaderSet.uniformBaseColorLocation, rect.x * 2.0 - 1.0, rect.y * 2.0 - 1.0, rect.getRight() * 2.0 - 1.0, rect.getBottom() * 2.0 - 1.0);\n      this.gl.uniform4f(shaderSet.uniformMultiplyColorLocation, multiplyColor.R, multiplyColor.G, multiplyColor.B, multiplyColor.A);\n      this.gl.uniform4f(shaderSet.uniformScreenColorLocation, screenColor.R, screenColor.G, screenColor.B, screenColor.A);\n      SRC_COLOR = this.gl.ZERO;\n      DST_COLOR = this.gl.ONE_MINUS_SRC_COLOR;\n      SRC_ALPHA = this.gl.ZERO;\n      DST_ALPHA = this.gl.ONE_MINUS_SRC_ALPHA;\n    } // マスク生成以外の場合\n    else {\n      const masked = renderer.getClippingContextBufferForDraw() != null; // この描画オブジェクトはマスク対象か\n      const offset = masked ? invertedMask ? 2 : 1 : 0;\n      let shaderSet = new CubismShaderSet();\n      switch (colorBlendMode) {\n        case CubismBlendMode.CubismBlendMode_Normal:\n        default:\n          shaderSet = this._shaderSets.at(ShaderNames.ShaderNames_NormalPremultipliedAlpha + offset);\n          SRC_COLOR = this.gl.ONE;\n          DST_COLOR = this.gl.ONE_MINUS_SRC_ALPHA;\n          SRC_ALPHA = this.gl.ONE;\n          DST_ALPHA = this.gl.ONE_MINUS_SRC_ALPHA;\n          break;\n        case CubismBlendMode.CubismBlendMode_Additive:\n          shaderSet = this._shaderSets.at(ShaderNames.ShaderNames_AddPremultipliedAlpha + offset);\n          SRC_COLOR = this.gl.ONE;\n          DST_COLOR = this.gl.ONE;\n          SRC_ALPHA = this.gl.ZERO;\n          DST_ALPHA = this.gl.ONE;\n          break;\n        case CubismBlendMode.CubismBlendMode_Multiplicative:\n          shaderSet = this._shaderSets.at(ShaderNames.ShaderNames_MultPremultipliedAlpha + offset);\n          SRC_COLOR = this.gl.DST_COLOR;\n          DST_COLOR = this.gl.ONE_MINUS_SRC_ALPHA;\n          SRC_ALPHA = this.gl.ZERO;\n          DST_ALPHA = this.gl.ONE;\n          break;\n      }\n      this.gl.useProgram(shaderSet.shaderProgram);\n\n      // 頂点配列の設定\n      if (bufferData.vertex == null) {\n        bufferData.vertex = this.gl.createBuffer();\n      }\n      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, bufferData.vertex);\n      this.gl.bufferData(this.gl.ARRAY_BUFFER, vertexArray, this.gl.DYNAMIC_DRAW);\n      this.gl.enableVertexAttribArray(shaderSet.attributePositionLocation);\n      this.gl.vertexAttribPointer(shaderSet.attributePositionLocation, 2, this.gl.FLOAT, false, 0, 0);\n\n      // テクスチャ頂点の設定\n      if (bufferData.uv == null) {\n        bufferData.uv = this.gl.createBuffer();\n      }\n      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, bufferData.uv);\n      this.gl.bufferData(this.gl.ARRAY_BUFFER, uvArray, this.gl.DYNAMIC_DRAW);\n      this.gl.enableVertexAttribArray(shaderSet.attributeTexCoordLocation);\n      this.gl.vertexAttribPointer(shaderSet.attributeTexCoordLocation, 2, this.gl.FLOAT, false, 0, 0);\n      if (masked) {\n        this.gl.activeTexture(this.gl.TEXTURE1);\n        const tex = renderer.getClippingContextBufferForDraw().getClippingManager().getColorBuffer().at(renderer.getClippingContextBufferForDraw()._bufferIndex);\n        this.gl.bindTexture(this.gl.TEXTURE_2D, tex);\n        this.gl.uniform1i(shaderSet.samplerTexture1Location, 1);\n\n        // view座標をClippingContextの座標に変換するための行列を設定\n        this.gl.uniformMatrix4fv(shaderSet.uniformClipMatrixLocation, false, renderer.getClippingContextBufferForDraw()._matrixForDraw.getArray());\n\n        // 使用するカラーチャンネルを設定\n        const channelNo = renderer.getClippingContextBufferForDraw()._layoutChannelNo;\n        const colorChannel = renderer.getClippingContextBufferForDraw().getClippingManager().getChannelFlagAsColor(channelNo);\n        this.gl.uniform4f(shaderSet.uniformChannelFlagLocation, colorChannel.R, colorChannel.G, colorChannel.B, colorChannel.A);\n      }\n\n      // テクスチャ設定\n      this.gl.activeTexture(this.gl.TEXTURE0);\n      this.gl.bindTexture(this.gl.TEXTURE_2D, textureId);\n      this.gl.uniform1i(shaderSet.samplerTexture0Location, 0);\n\n      // 座標変換\n      this.gl.uniformMatrix4fv(shaderSet.uniformMatrixLocation, false, matrix4x4.getArray());\n      this.gl.uniform4f(shaderSet.uniformBaseColorLocation, baseColor.R, baseColor.G, baseColor.B, baseColor.A);\n      this.gl.uniform4f(shaderSet.uniformMultiplyColorLocation, multiplyColor.R, multiplyColor.G, multiplyColor.B, multiplyColor.A);\n      this.gl.uniform4f(shaderSet.uniformScreenColorLocation, screenColor.R, screenColor.G, screenColor.B, screenColor.A);\n    }\n\n    // IBOを作成し、データを転送\n    if (bufferData.index == null) {\n      bufferData.index = this.gl.createBuffer();\n    }\n    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, bufferData.index);\n    this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, indexArray, this.gl.DYNAMIC_DRAW);\n    this.gl.blendFuncSeparate(SRC_COLOR, DST_COLOR, SRC_ALPHA, DST_ALPHA);\n  }\n\n  /**\n   * シェーダープログラムを解放する\n   */\n  releaseShaderProgram() {\n    for (let i = 0; i < this._shaderSets.getSize(); i++) {\n      this.gl.deleteProgram(this._shaderSets.at(i).shaderProgram);\n      this._shaderSets.at(i).shaderProgram = 0;\n      this._shaderSets.set(i, void 0);\n      this._shaderSets.set(i, null);\n    }\n  }\n\n  /**\n   * シェーダープログラムを初期化する\n   * @param vertShaderSrc 頂点シェーダのソース\n   * @param fragShaderSrc フラグメントシェーダのソース\n   */\n  generateShaders() {\n    for (let i = 0; i < ShaderCount; i++) {\n      this._shaderSets.pushBack(new CubismShaderSet());\n    }\n    this._shaderSets.at(0).shaderProgram = this.loadShaderProgram(vertexShaderSrcSetupMask, fragmentShaderSrcsetupMask);\n    this._shaderSets.at(1).shaderProgram = this.loadShaderProgram(vertexShaderSrc, fragmentShaderSrcPremultipliedAlpha);\n    this._shaderSets.at(2).shaderProgram = this.loadShaderProgram(vertexShaderSrcMasked, fragmentShaderSrcMaskPremultipliedAlpha);\n    this._shaderSets.at(3).shaderProgram = this.loadShaderProgram(vertexShaderSrcMasked, fragmentShaderSrcMaskInvertedPremultipliedAlpha);\n\n    // 加算も通常と同じシェーダーを利用する\n    this._shaderSets.at(4).shaderProgram = this._shaderSets.at(1).shaderProgram;\n    this._shaderSets.at(5).shaderProgram = this._shaderSets.at(2).shaderProgram;\n    this._shaderSets.at(6).shaderProgram = this._shaderSets.at(3).shaderProgram;\n\n    // 乗算も通常と同じシェーダーを利用する\n    this._shaderSets.at(7).shaderProgram = this._shaderSets.at(1).shaderProgram;\n    this._shaderSets.at(8).shaderProgram = this._shaderSets.at(2).shaderProgram;\n    this._shaderSets.at(9).shaderProgram = this._shaderSets.at(3).shaderProgram;\n\n    // SetupMask\n    this._shaderSets.at(0).attributePositionLocation = this.gl.getAttribLocation(this._shaderSets.at(0).shaderProgram, 'a_position');\n    this._shaderSets.at(0).attributeTexCoordLocation = this.gl.getAttribLocation(this._shaderSets.at(0).shaderProgram, 'a_texCoord');\n    this._shaderSets.at(0).samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets.at(0).shaderProgram, 's_texture0');\n    this._shaderSets.at(0).uniformClipMatrixLocation = this.gl.getUniformLocation(this._shaderSets.at(0).shaderProgram, 'u_clipMatrix');\n    this._shaderSets.at(0).uniformChannelFlagLocation = this.gl.getUniformLocation(this._shaderSets.at(0).shaderProgram, 'u_channelFlag');\n    this._shaderSets.at(0).uniformBaseColorLocation = this.gl.getUniformLocation(this._shaderSets.at(0).shaderProgram, 'u_baseColor');\n    this._shaderSets.at(0).uniformMultiplyColorLocation = this.gl.getUniformLocation(this._shaderSets.at(0).shaderProgram, 'u_multiplyColor');\n    this._shaderSets.at(0).uniformScreenColorLocation = this.gl.getUniformLocation(this._shaderSets.at(0).shaderProgram, 'u_screenColor');\n\n    // 通常（PremultipliedAlpha）\n    this._shaderSets.at(1).attributePositionLocation = this.gl.getAttribLocation(this._shaderSets.at(1).shaderProgram, 'a_position');\n    this._shaderSets.at(1).attributeTexCoordLocation = this.gl.getAttribLocation(this._shaderSets.at(1).shaderProgram, 'a_texCoord');\n    this._shaderSets.at(1).samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets.at(1).shaderProgram, 's_texture0');\n    this._shaderSets.at(1).uniformMatrixLocation = this.gl.getUniformLocation(this._shaderSets.at(1).shaderProgram, 'u_matrix');\n    this._shaderSets.at(1).uniformBaseColorLocation = this.gl.getUniformLocation(this._shaderSets.at(1).shaderProgram, 'u_baseColor');\n    this._shaderSets.at(1).uniformMultiplyColorLocation = this.gl.getUniformLocation(this._shaderSets.at(1).shaderProgram, 'u_multiplyColor');\n    this._shaderSets.at(1).uniformScreenColorLocation = this.gl.getUniformLocation(this._shaderSets.at(1).shaderProgram, 'u_screenColor');\n\n    // 通常（クリッピング、PremultipliedAlpha）\n    this._shaderSets.at(2).attributePositionLocation = this.gl.getAttribLocation(this._shaderSets.at(2).shaderProgram, 'a_position');\n    this._shaderSets.at(2).attributeTexCoordLocation = this.gl.getAttribLocation(this._shaderSets.at(2).shaderProgram, 'a_texCoord');\n    this._shaderSets.at(2).samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets.at(2).shaderProgram, 's_texture0');\n    this._shaderSets.at(2).samplerTexture1Location = this.gl.getUniformLocation(this._shaderSets.at(2).shaderProgram, 's_texture1');\n    this._shaderSets.at(2).uniformMatrixLocation = this.gl.getUniformLocation(this._shaderSets.at(2).shaderProgram, 'u_matrix');\n    this._shaderSets.at(2).uniformClipMatrixLocation = this.gl.getUniformLocation(this._shaderSets.at(2).shaderProgram, 'u_clipMatrix');\n    this._shaderSets.at(2).uniformChannelFlagLocation = this.gl.getUniformLocation(this._shaderSets.at(2).shaderProgram, 'u_channelFlag');\n    this._shaderSets.at(2).uniformBaseColorLocation = this.gl.getUniformLocation(this._shaderSets.at(2).shaderProgram, 'u_baseColor');\n    this._shaderSets.at(2).uniformMultiplyColorLocation = this.gl.getUniformLocation(this._shaderSets.at(2).shaderProgram, 'u_multiplyColor');\n    this._shaderSets.at(2).uniformScreenColorLocation = this.gl.getUniformLocation(this._shaderSets.at(2).shaderProgram, 'u_screenColor');\n\n    // 通常（クリッピング・反転, PremultipliedAlpha）\n    this._shaderSets.at(3).attributePositionLocation = this.gl.getAttribLocation(this._shaderSets.at(3).shaderProgram, 'a_position');\n    this._shaderSets.at(3).attributeTexCoordLocation = this.gl.getAttribLocation(this._shaderSets.at(3).shaderProgram, 'a_texCoord');\n    this._shaderSets.at(3).samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets.at(3).shaderProgram, 's_texture0');\n    this._shaderSets.at(3).samplerTexture1Location = this.gl.getUniformLocation(this._shaderSets.at(3).shaderProgram, 's_texture1');\n    this._shaderSets.at(3).uniformMatrixLocation = this.gl.getUniformLocation(this._shaderSets.at(3).shaderProgram, 'u_matrix');\n    this._shaderSets.at(3).uniformClipMatrixLocation = this.gl.getUniformLocation(this._shaderSets.at(3).shaderProgram, 'u_clipMatrix');\n    this._shaderSets.at(3).uniformChannelFlagLocation = this.gl.getUniformLocation(this._shaderSets.at(3).shaderProgram, 'u_channelFlag');\n    this._shaderSets.at(3).uniformBaseColorLocation = this.gl.getUniformLocation(this._shaderSets.at(3).shaderProgram, 'u_baseColor');\n    this._shaderSets.at(3).uniformMultiplyColorLocation = this.gl.getUniformLocation(this._shaderSets.at(3).shaderProgram, 'u_multiplyColor');\n    this._shaderSets.at(3).uniformScreenColorLocation = this.gl.getUniformLocation(this._shaderSets.at(3).shaderProgram, 'u_screenColor');\n\n    // 加算（PremultipliedAlpha）\n    this._shaderSets.at(4).attributePositionLocation = this.gl.getAttribLocation(this._shaderSets.at(4).shaderProgram, 'a_position');\n    this._shaderSets.at(4).attributeTexCoordLocation = this.gl.getAttribLocation(this._shaderSets.at(4).shaderProgram, 'a_texCoord');\n    this._shaderSets.at(4).samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets.at(4).shaderProgram, 's_texture0');\n    this._shaderSets.at(4).uniformMatrixLocation = this.gl.getUniformLocation(this._shaderSets.at(4).shaderProgram, 'u_matrix');\n    this._shaderSets.at(4).uniformBaseColorLocation = this.gl.getUniformLocation(this._shaderSets.at(4).shaderProgram, 'u_baseColor');\n    this._shaderSets.at(4).uniformMultiplyColorLocation = this.gl.getUniformLocation(this._shaderSets.at(4).shaderProgram, 'u_multiplyColor');\n    this._shaderSets.at(4).uniformScreenColorLocation = this.gl.getUniformLocation(this._shaderSets.at(4).shaderProgram, 'u_screenColor');\n\n    // 加算（クリッピング、PremultipliedAlpha）\n    this._shaderSets.at(5).attributePositionLocation = this.gl.getAttribLocation(this._shaderSets.at(5).shaderProgram, 'a_position');\n    this._shaderSets.at(5).attributeTexCoordLocation = this.gl.getAttribLocation(this._shaderSets.at(5).shaderProgram, 'a_texCoord');\n    this._shaderSets.at(5).samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets.at(5).shaderProgram, 's_texture0');\n    this._shaderSets.at(5).samplerTexture1Location = this.gl.getUniformLocation(this._shaderSets.at(5).shaderProgram, 's_texture1');\n    this._shaderSets.at(5).uniformMatrixLocation = this.gl.getUniformLocation(this._shaderSets.at(5).shaderProgram, 'u_matrix');\n    this._shaderSets.at(5).uniformClipMatrixLocation = this.gl.getUniformLocation(this._shaderSets.at(5).shaderProgram, 'u_clipMatrix');\n    this._shaderSets.at(5).uniformChannelFlagLocation = this.gl.getUniformLocation(this._shaderSets.at(5).shaderProgram, 'u_channelFlag');\n    this._shaderSets.at(5).uniformBaseColorLocation = this.gl.getUniformLocation(this._shaderSets.at(5).shaderProgram, 'u_baseColor');\n    this._shaderSets.at(5).uniformMultiplyColorLocation = this.gl.getUniformLocation(this._shaderSets.at(5).shaderProgram, 'u_multiplyColor');\n    this._shaderSets.at(5).uniformScreenColorLocation = this.gl.getUniformLocation(this._shaderSets.at(5).shaderProgram, 'u_screenColor');\n\n    // 加算（クリッピング・反転、PremultipliedAlpha）\n    this._shaderSets.at(6).attributePositionLocation = this.gl.getAttribLocation(this._shaderSets.at(6).shaderProgram, 'a_position');\n    this._shaderSets.at(6).attributeTexCoordLocation = this.gl.getAttribLocation(this._shaderSets.at(6).shaderProgram, 'a_texCoord');\n    this._shaderSets.at(6).samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets.at(6).shaderProgram, 's_texture0');\n    this._shaderSets.at(6).samplerTexture1Location = this.gl.getUniformLocation(this._shaderSets.at(6).shaderProgram, 's_texture1');\n    this._shaderSets.at(6).uniformMatrixLocation = this.gl.getUniformLocation(this._shaderSets.at(6).shaderProgram, 'u_matrix');\n    this._shaderSets.at(6).uniformClipMatrixLocation = this.gl.getUniformLocation(this._shaderSets.at(6).shaderProgram, 'u_clipMatrix');\n    this._shaderSets.at(6).uniformChannelFlagLocation = this.gl.getUniformLocation(this._shaderSets.at(6).shaderProgram, 'u_channelFlag');\n    this._shaderSets.at(6).uniformBaseColorLocation = this.gl.getUniformLocation(this._shaderSets.at(6).shaderProgram, 'u_baseColor');\n    this._shaderSets.at(6).uniformMultiplyColorLocation = this.gl.getUniformLocation(this._shaderSets.at(6).shaderProgram, 'u_multiplyColor');\n    this._shaderSets.at(6).uniformScreenColorLocation = this.gl.getUniformLocation(this._shaderSets.at(6).shaderProgram, 'u_screenColor');\n\n    // 乗算（PremultipliedAlpha）\n    this._shaderSets.at(7).attributePositionLocation = this.gl.getAttribLocation(this._shaderSets.at(7).shaderProgram, 'a_position');\n    this._shaderSets.at(7).attributeTexCoordLocation = this.gl.getAttribLocation(this._shaderSets.at(7).shaderProgram, 'a_texCoord');\n    this._shaderSets.at(7).samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets.at(7).shaderProgram, 's_texture0');\n    this._shaderSets.at(7).uniformMatrixLocation = this.gl.getUniformLocation(this._shaderSets.at(7).shaderProgram, 'u_matrix');\n    this._shaderSets.at(7).uniformBaseColorLocation = this.gl.getUniformLocation(this._shaderSets.at(7).shaderProgram, 'u_baseColor');\n    this._shaderSets.at(7).uniformMultiplyColorLocation = this.gl.getUniformLocation(this._shaderSets.at(7).shaderProgram, 'u_multiplyColor');\n    this._shaderSets.at(7).uniformScreenColorLocation = this.gl.getUniformLocation(this._shaderSets.at(7).shaderProgram, 'u_screenColor');\n\n    // 乗算（クリッピング、PremultipliedAlpha）\n    this._shaderSets.at(8).attributePositionLocation = this.gl.getAttribLocation(this._shaderSets.at(8).shaderProgram, 'a_position');\n    this._shaderSets.at(8).attributeTexCoordLocation = this.gl.getAttribLocation(this._shaderSets.at(8).shaderProgram, 'a_texCoord');\n    this._shaderSets.at(8).samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets.at(8).shaderProgram, 's_texture0');\n    this._shaderSets.at(8).samplerTexture1Location = this.gl.getUniformLocation(this._shaderSets.at(8).shaderProgram, 's_texture1');\n    this._shaderSets.at(8).uniformMatrixLocation = this.gl.getUniformLocation(this._shaderSets.at(8).shaderProgram, 'u_matrix');\n    this._shaderSets.at(8).uniformClipMatrixLocation = this.gl.getUniformLocation(this._shaderSets.at(8).shaderProgram, 'u_clipMatrix');\n    this._shaderSets.at(8).uniformChannelFlagLocation = this.gl.getUniformLocation(this._shaderSets.at(8).shaderProgram, 'u_channelFlag');\n    this._shaderSets.at(8).uniformBaseColorLocation = this.gl.getUniformLocation(this._shaderSets.at(8).shaderProgram, 'u_baseColor');\n    this._shaderSets.at(8).uniformMultiplyColorLocation = this.gl.getUniformLocation(this._shaderSets.at(8).shaderProgram, 'u_multiplyColor');\n    this._shaderSets.at(8).uniformScreenColorLocation = this.gl.getUniformLocation(this._shaderSets.at(8).shaderProgram, 'u_screenColor');\n\n    // 乗算（クリッピング・反転、PremultipliedAlpha）\n    this._shaderSets.at(9).attributePositionLocation = this.gl.getAttribLocation(this._shaderSets.at(9).shaderProgram, 'a_position');\n    this._shaderSets.at(9).attributeTexCoordLocation = this.gl.getAttribLocation(this._shaderSets.at(9).shaderProgram, 'a_texCoord');\n    this._shaderSets.at(9).samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets.at(9).shaderProgram, 's_texture0');\n    this._shaderSets.at(9).samplerTexture1Location = this.gl.getUniformLocation(this._shaderSets.at(9).shaderProgram, 's_texture1');\n    this._shaderSets.at(9).uniformMatrixLocation = this.gl.getUniformLocation(this._shaderSets.at(9).shaderProgram, 'u_matrix');\n    this._shaderSets.at(9).uniformClipMatrixLocation = this.gl.getUniformLocation(this._shaderSets.at(9).shaderProgram, 'u_clipMatrix');\n    this._shaderSets.at(9).uniformChannelFlagLocation = this.gl.getUniformLocation(this._shaderSets.at(9).shaderProgram, 'u_channelFlag');\n    this._shaderSets.at(9).uniformBaseColorLocation = this.gl.getUniformLocation(this._shaderSets.at(9).shaderProgram, 'u_baseColor');\n    this._shaderSets.at(9).uniformMultiplyColorLocation = this.gl.getUniformLocation(this._shaderSets.at(9).shaderProgram, 'u_multiplyColor');\n    this._shaderSets.at(9).uniformScreenColorLocation = this.gl.getUniformLocation(this._shaderSets.at(9).shaderProgram, 'u_screenColor');\n  }\n\n  /**\n   * シェーダプログラムをロードしてアドレスを返す\n   * @param vertexShaderSource    頂点シェーダのソース\n   * @param fragmentShaderSource  フラグメントシェーダのソース\n   * @return シェーダプログラムのアドレス\n   */\n  loadShaderProgram(vertexShaderSource, fragmentShaderSource) {\n    // Create Shader Program\n    let shaderProgram = this.gl.createProgram();\n    let vertShader = this.compileShaderSource(this.gl.VERTEX_SHADER, vertexShaderSource);\n    if (!vertShader) {\n      CubismLogError('Vertex shader compile error!');\n      return 0;\n    }\n    let fragShader = this.compileShaderSource(this.gl.FRAGMENT_SHADER, fragmentShaderSource);\n    if (!fragShader) {\n      CubismLogError('Vertex shader compile error!');\n      return 0;\n    }\n\n    // Attach vertex shader to program\n    this.gl.attachShader(shaderProgram, vertShader);\n\n    // Attach fragment shader to program\n    this.gl.attachShader(shaderProgram, fragShader);\n\n    // link program\n    this.gl.linkProgram(shaderProgram);\n    const linkStatus = this.gl.getProgramParameter(shaderProgram, this.gl.LINK_STATUS);\n\n    // リンクに失敗したらシェーダーを削除\n    if (!linkStatus) {\n      CubismLogError('Failed to link program: {0}', shaderProgram);\n      this.gl.deleteShader(vertShader);\n      vertShader = 0;\n      this.gl.deleteShader(fragShader);\n      fragShader = 0;\n      if (shaderProgram) {\n        this.gl.deleteProgram(shaderProgram);\n        shaderProgram = 0;\n      }\n      return 0;\n    }\n\n    // Release vertex and fragment shaders.\n    this.gl.deleteShader(vertShader);\n    this.gl.deleteShader(fragShader);\n    return shaderProgram;\n  }\n\n  /**\n   * シェーダープログラムをコンパイルする\n   * @param shaderType シェーダタイプ(Vertex/Fragment)\n   * @param shaderSource シェーダソースコード\n   *\n   * @return コンパイルされたシェーダープログラム\n   */\n  compileShaderSource(shaderType, shaderSource) {\n    const source = shaderSource;\n    const shader = this.gl.createShader(shaderType);\n    this.gl.shaderSource(shader, source);\n    this.gl.compileShader(shader);\n    if (!shader) {\n      const log = this.gl.getShaderInfoLog(shader);\n      CubismLogError('Shader compile log: {0} ', log);\n    }\n    const status = this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS);\n    if (!status) {\n      this.gl.deleteShader(shader);\n      return null;\n    }\n    return shader;\n  }\n  setGl(gl) {\n    this.gl = gl;\n  }\n\n  // webglコンテキスト\n}\n\n/**\n * CubismShader_WebGLのインナークラス\n */\nexport class CubismShaderSet {\n  constructor() {\n    this.shaderProgram = void 0;\n    // シェーダープログラムのアドレス\n    this.attributePositionLocation = void 0;\n    // シェーダープログラムに渡す変数のアドレス（Position）\n    this.attributeTexCoordLocation = void 0;\n    // シェーダープログラムに渡す変数のアドレス（TexCoord）\n    this.uniformMatrixLocation = void 0;\n    // シェーダープログラムに渡す変数のアドレス（Matrix）\n    this.uniformClipMatrixLocation = void 0;\n    // シェーダープログラムに渡す変数のアドレス（ClipMatrix）\n    this.samplerTexture0Location = void 0;\n    // シェーダープログラムに渡す変数のアドレス（Texture0）\n    this.samplerTexture1Location = void 0;\n    // シェーダープログラムに渡す変数のアドレス（Texture1）\n    this.uniformBaseColorLocation = void 0;\n    // シェーダープログラムに渡す変数のアドレス（BaseColor）\n    this.uniformChannelFlagLocation = void 0;\n    // シェーダープログラムに渡す変数のアドレス（ChannelFlag）\n    this.uniformMultiplyColorLocation = void 0;\n    // シェーダープログラムに渡す変数のアドレス（MultiplyColor）\n    this.uniformScreenColorLocation = void 0;\n  } // シェーダープログラムに渡す変数のアドレス（ScreenColor）\n}\nexport let ShaderNames = /*#__PURE__*/function (ShaderNames) {\n  ShaderNames[ShaderNames[\"ShaderNames_SetupMask\"] = 0] = \"ShaderNames_SetupMask\";\n  ShaderNames[ShaderNames[\"ShaderNames_NormalPremultipliedAlpha\"] = 1] = \"ShaderNames_NormalPremultipliedAlpha\";\n  ShaderNames[ShaderNames[\"ShaderNames_NormalMaskedPremultipliedAlpha\"] = 2] = \"ShaderNames_NormalMaskedPremultipliedAlpha\";\n  ShaderNames[ShaderNames[\"ShaderNames_NomralMaskedInvertedPremultipliedAlpha\"] = 3] = \"ShaderNames_NomralMaskedInvertedPremultipliedAlpha\";\n  ShaderNames[ShaderNames[\"ShaderNames_AddPremultipliedAlpha\"] = 4] = \"ShaderNames_AddPremultipliedAlpha\";\n  ShaderNames[ShaderNames[\"ShaderNames_AddMaskedPremultipliedAlpha\"] = 5] = \"ShaderNames_AddMaskedPremultipliedAlpha\";\n  ShaderNames[ShaderNames[\"ShaderNames_AddMaskedPremultipliedAlphaInverted\"] = 6] = \"ShaderNames_AddMaskedPremultipliedAlphaInverted\";\n  ShaderNames[ShaderNames[\"ShaderNames_MultPremultipliedAlpha\"] = 7] = \"ShaderNames_MultPremultipliedAlpha\";\n  ShaderNames[ShaderNames[\"ShaderNames_MultMaskedPremultipliedAlpha\"] = 8] = \"ShaderNames_MultMaskedPremultipliedAlpha\";\n  ShaderNames[ShaderNames[\"ShaderNames_MultMaskedPremultipliedAlphaInverted\"] = 9] = \"ShaderNames_MultMaskedPremultipliedAlphaInverted\";\n  return ShaderNames;\n}({});\nexport const vertexShaderSrcSetupMask = 'attribute vec4     a_position;' + 'attribute vec2     a_texCoord;' + 'varying vec2       v_texCoord;' + 'varying vec4       v_myPos;' + 'uniform mat4       u_clipMatrix;' + 'void main()' + '{' + '   gl_Position = u_clipMatrix * a_position;' + '   v_myPos = u_clipMatrix * a_position;' + '   v_texCoord = a_texCoord;' + '   v_texCoord.y = 1.0 - v_texCoord.y;' + '}';\nexport const fragmentShaderSrcsetupMask = 'precision mediump float;' + 'varying vec2       v_texCoord;' + 'varying vec4       v_myPos;' + 'uniform vec4       u_baseColor;' + 'uniform vec4       u_channelFlag;' + 'uniform sampler2D  s_texture0;' + 'void main()' + '{' + '   float isInside = ' + '       step(u_baseColor.x, v_myPos.x/v_myPos.w)' + '       * step(u_baseColor.y, v_myPos.y/v_myPos.w)' + '       * step(v_myPos.x/v_myPos.w, u_baseColor.z)' + '       * step(v_myPos.y/v_myPos.w, u_baseColor.w);' + '   gl_FragColor = u_channelFlag * texture2D(s_texture0, v_texCoord).a * isInside;' + '}';\n\n//----- バーテックスシェーダプログラム -----\n// Normal & Add & Mult 共通\nexport const vertexShaderSrc = 'attribute vec4     a_position;' +\n//v.vertex\n'attribute vec2     a_texCoord;' +\n//v.texcoord\n'varying vec2       v_texCoord;' +\n//v2f.texcoord\n'uniform mat4       u_matrix;' + 'void main()' + '{' + '   gl_Position = u_matrix * a_position;' + '   v_texCoord = a_texCoord;' + '   v_texCoord.y = 1.0 - v_texCoord.y;' + '}';\n\n// Normal & Add & Mult 共通（クリッピングされたものの描画用）\nexport const vertexShaderSrcMasked = 'attribute vec4     a_position;' + 'attribute vec2     a_texCoord;' + 'varying vec2       v_texCoord;' + 'varying vec4       v_clipPos;' + 'uniform mat4       u_matrix;' + 'uniform mat4       u_clipMatrix;' + 'void main()' + '{' + '   gl_Position = u_matrix * a_position;' + '   v_clipPos = u_clipMatrix * a_position;' + '   v_texCoord = a_texCoord;' + '   v_texCoord.y = 1.0 - v_texCoord.y;' + '}';\n\n//----- フラグメントシェーダプログラム -----\n// Normal & Add & Mult 共通 （PremultipliedAlpha）\nexport const fragmentShaderSrcPremultipliedAlpha = 'precision mediump float;' + 'varying vec2       v_texCoord;' +\n//v2f.texcoord\n'uniform vec4       u_baseColor;' + 'uniform sampler2D  s_texture0;' +\n//_MainTex\n'uniform vec4       u_multiplyColor;' + 'uniform vec4       u_screenColor;' + 'void main()' + '{' + '   vec4 texColor = texture2D(s_texture0, v_texCoord);' + '   texColor.rgb = texColor.rgb * u_multiplyColor.rgb;' + '   texColor.rgb = (texColor.rgb + u_screenColor.rgb * texColor.a) - (texColor.rgb * u_screenColor.rgb);' + '   vec4 color = texColor * u_baseColor;' + '   gl_FragColor = vec4(color.rgb, color.a);' + '}';\n\n// Normal （クリッピングされたものの描画用、PremultipliedAlpha兼用）\nexport const fragmentShaderSrcMaskPremultipliedAlpha = 'precision mediump float;' + 'varying vec2       v_texCoord;' + 'varying vec4       v_clipPos;' + 'uniform vec4       u_baseColor;' + 'uniform vec4       u_channelFlag;' + 'uniform sampler2D  s_texture0;' + 'uniform sampler2D  s_texture1;' + 'uniform vec4       u_multiplyColor;' + 'uniform vec4       u_screenColor;' + 'void main()' + '{' + '   vec4 texColor = texture2D(s_texture0, v_texCoord);' + '   texColor.rgb = texColor.rgb * u_multiplyColor.rgb;' + '   texColor.rgb = (texColor.rgb + u_screenColor.rgb * texColor.a) - (texColor.rgb * u_screenColor.rgb);' + '   vec4 col_formask = texColor * u_baseColor;' + '   vec4 clipMask = (1.0 - texture2D(s_texture1, v_clipPos.xy / v_clipPos.w)) * u_channelFlag;' + '   float maskVal = clipMask.r + clipMask.g + clipMask.b + clipMask.a;' + '   col_formask = col_formask * maskVal;' + '   gl_FragColor = col_formask;' + '}';\n\n// Normal & Add & Mult 共通（クリッピングされて反転使用の描画用、PremultipliedAlphaの場合）\nexport const fragmentShaderSrcMaskInvertedPremultipliedAlpha = 'precision mediump float;' + 'varying vec2      v_texCoord;' + 'varying vec4      v_clipPos;' + 'uniform sampler2D s_texture0;' + 'uniform sampler2D s_texture1;' + 'uniform vec4      u_channelFlag;' + 'uniform vec4      u_baseColor;' + 'uniform vec4      u_multiplyColor;' + 'uniform vec4      u_screenColor;' + 'void main()' + '{' + '   vec4 texColor = texture2D(s_texture0, v_texCoord);' + '   texColor.rgb = texColor.rgb * u_multiplyColor.rgb;' + '   texColor.rgb = (texColor.rgb + u_screenColor.rgb * texColor.a) - (texColor.rgb * u_screenColor.rgb);' + '   vec4 col_formask = texColor * u_baseColor;' + '   vec4 clipMask = (1.0 - texture2D(s_texture1, v_clipPos.xy / v_clipPos.w)) * u_channelFlag;' + '   float maskVal = clipMask.r + clipMask.g + clipMask.b + clipMask.a;' + '   col_formask = col_formask * (1.0 - maskVal);' + '   gl_FragColor = col_formask;' + '}';\n\n/**\n * WebGL用の描画命令を実装したクラス\n */\nexport class CubismRenderer_WebGL extends CubismRenderer {\n  /**\n   * レンダラの初期化処理を実行する\n   * 引数に渡したモデルからレンダラの初期化処理に必要な情報を取り出すことができる\n   *\n   * @param model モデルのインスタンス\n   * @param maskBufferCount バッファの生成数\n   */\n  initialize(model) {\n    let maskBufferCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    if (model.isUsingMasking()) {\n      this._clippingManager = new CubismClippingManager_WebGL(); // クリッピングマスク・バッファ前処理方式を初期化\n      this._clippingManager.initialize(model, model.getDrawableCount(), model.getDrawableMasks(), model.getDrawableMaskCounts(), maskBufferCount);\n    }\n    this._sortedDrawableIndexList.resize(model.getDrawableCount(), 0);\n    super.initialize(model); // 親クラスの処理を呼ぶ\n  }\n\n  /**\n   * WebGLテクスチャのバインド処理\n   * CubismRendererにテクスチャを設定し、CubismRenderer内でその画像を参照するためのIndex値を戻り値とする\n   * @param modelTextureNo セットするモデルテクスチャの番号\n   * @param glTextureNo WebGLテクスチャの番号\n   */\n  bindTexture(modelTextureNo, glTexture) {\n    this._textures.setValue(modelTextureNo, glTexture);\n  }\n\n  /**\n   * WebGLにバインドされたテクスチャのリストを取得する\n   * @return テクスチャのリスト\n   */\n  getBindedTextures() {\n    return this._textures;\n  }\n\n  /**\n   * クリッピングマスクバッファのサイズを設定する\n   * マスク用のFrameBufferを破棄、再作成する為処理コストは高い\n   * @param size クリッピングマスクバッファのサイズ\n   */\n  setClippingMaskBufferSize(size) {\n    // クリッピングマスクを利用しない場合は早期リターン\n    if (!this._model.isUsingMasking()) {\n      return;\n    }\n\n    // インスタンス破棄前にレンダーテクスチャの数を保存\n    const renderTextureCount = this._clippingManager.getRenderTextureCount();\n\n    // FrameBufferのサイズを変更するためにインスタンスを破棄・再作成する\n    this._clippingManager.release();\n    this._clippingManager = void 0;\n    this._clippingManager = null;\n    this._clippingManager = new CubismClippingManager_WebGL();\n    this._clippingManager.setClippingMaskBufferSize(size);\n    this._clippingManager.initialize(this.getModel(), this.getModel().getDrawableCount(), this.getModel().getDrawableMasks(), this.getModel().getDrawableMaskCounts(), renderTextureCount // インスタンス破棄前に保存したレンダーテクスチャの数\n    );\n  }\n\n  /**\n   * クリッピングマスクバッファのサイズを取得する\n   * @return クリッピングマスクバッファのサイズ\n   */\n  getClippingMaskBufferSize() {\n    return this._model.isUsingMasking() ? this._clippingManager.getClippingMaskBufferSize() : -1;\n  }\n\n  /**\n   * レンダーテクスチャの枚数を取得する\n   * @return レンダーテクスチャの枚数\n   */\n  getRenderTextureCount() {\n    return this._model.isUsingMasking() ? this._clippingManager.getRenderTextureCount() : -1;\n  }\n\n  /**\n   * コンストラクタ\n   */\n  constructor() {\n    super();\n    this._textures = void 0;\n    // モデルが参照するテクスチャとレンダラでバインドしているテクスチャとのマップ\n    this._sortedDrawableIndexList = void 0;\n    // 描画オブジェクトのインデックスを描画順に並べたリスト\n    this._clippingManager = void 0;\n    // クリッピングマスク管理オブジェクト\n    this._clippingContextBufferForMask = void 0;\n    // マスクテクスチャに描画するためのクリッピングコンテキスト\n    this._clippingContextBufferForDraw = void 0;\n    // 画面上描画するためのクリッピングコンテキスト\n    this._rendererProfile = void 0;\n    this.firstDraw = void 0;\n    this._bufferData = void 0;\n    // 頂点バッファデータ\n    this._extension = void 0;\n    // 拡張機能\n    this.gl = void 0;\n    this._clippingContextBufferForMask = null;\n    this._clippingContextBufferForDraw = null;\n    this._rendererProfile = new CubismRendererProfile_WebGL();\n    this.firstDraw = true;\n    this._textures = new csmMap();\n    this._sortedDrawableIndexList = new csmVector();\n    this._bufferData = {\n      vertex: WebGLBuffer = null,\n      uv: WebGLBuffer = null,\n      index: WebGLBuffer = null\n    };\n\n    // テクスチャ対応マップの容量を確保しておく\n    this._textures.prepareCapacity(32, true);\n  }\n\n  /**\n   * デストラクタ相当の処理\n   */\n  release() {\n    if (this._clippingManager) {\n      this._clippingManager.release();\n      this._clippingManager = void 0;\n      this._clippingManager = null;\n    }\n    if (this.gl == null) {\n      return;\n    }\n    this.gl.deleteBuffer(this._bufferData.vertex);\n    this._bufferData.vertex = null;\n    this.gl.deleteBuffer(this._bufferData.uv);\n    this._bufferData.uv = null;\n    this.gl.deleteBuffer(this._bufferData.index);\n    this._bufferData.index = null;\n    this._bufferData = null;\n    this._textures = null;\n  }\n\n  /**\n   * モデルを描画する実際の処理\n   */\n  doDrawModel() {\n    if (this.gl == null) {\n      CubismLogError(\"'gl' is null. WebGLRenderingContext is required.\\nPlease call 'CubimRenderer_WebGL.startUp' function.\");\n      return;\n    }\n\n    //------------ クリッピングマスク・バッファ前処理方式の場合 ------------\n    if (this._clippingManager != null) {\n      this.preDraw();\n      this._clippingManager.setupClippingContext(this.getModel(), this);\n    }\n\n    // 上記クリッピング処理内でも一度PreDrawを呼ぶので注意!!\n    this.preDraw();\n    const drawableCount = this.getModel().getDrawableCount();\n    const renderOrder = this.getModel().getDrawableRenderOrders();\n\n    // インデックスを描画順でソート\n    for (let i = 0; i < drawableCount; ++i) {\n      const order = renderOrder[i];\n      this._sortedDrawableIndexList.set(order, i);\n    }\n\n    // 描画\n    for (let i = 0; i < drawableCount; ++i) {\n      const drawableIndex = this._sortedDrawableIndexList.at(i);\n\n      // Drawableが表示状態でなければ処理をパスする\n      if (!this.getModel().getDrawableDynamicFlagIsVisible(drawableIndex)) {\n        continue;\n      }\n      const clipContext = this._clippingManager != null ? this._clippingManager.getClippingContextListForDraw().at(drawableIndex) : null;\n      if (clipContext != null && this.isUsingHighPrecisionMask()) {\n        // 描くことになっていた\n        if (clipContext._isUsing) {\n          // 生成したFrameBufferと同じサイズでビューポートを設定\n          this.gl.viewport(0, 0, this._clippingManager.getClippingMaskBufferSize(), this._clippingManager.getClippingMaskBufferSize());\n          this.preDraw(); // バッファをクリアする\n\n          // ---------- マスク描画処理 ----------\n          // マスク用RenderTextureをactiveにセット\n          this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, clipContext.getClippingManager().getMaskRenderTexture().at(clipContext._bufferIndex));\n\n          // マスクをクリアする\n          // (仮仕様) 1が無効（描かれない）領域、0が有効（描かれる）領域。（シェーダーCd*Csで0に近い値をかけてマスクを作る。1をかけると何も起こらない）\n          this.gl.clearColor(1.0, 1.0, 1.0, 1.0);\n          this.gl.clear(this.gl.COLOR_BUFFER_BIT);\n        }\n        {\n          const clipDrawCount = clipContext._clippingIdCount;\n          for (let index = 0; index < clipDrawCount; index++) {\n            const clipDrawIndex = clipContext._clippingIdList[index];\n\n            // 頂点情報が更新されておらず、信頼性がない場合は描画をパスする\n            if (!this._model.getDrawableDynamicFlagVertexPositionsDidChange(clipDrawIndex)) {\n              continue;\n            }\n            this.setIsCulling(this._model.getDrawableCulling(clipDrawIndex) != false);\n\n            // 今回専用の変換を適用して描く\n            // チャンネルも切り替える必要がある(A,R,G,B)\n            this.setClippingContextBufferForMask(clipContext);\n            this.drawMesh(this.getModel().getDrawableTextureIndex(clipDrawIndex), this.getModel().getDrawableVertexIndexCount(clipDrawIndex), this.getModel().getDrawableVertexCount(clipDrawIndex), this.getModel().getDrawableVertexIndices(clipDrawIndex), this.getModel().getDrawableVertices(clipDrawIndex), this.getModel().getDrawableVertexUvs(clipDrawIndex), this.getModel().getMultiplyColor(clipDrawIndex), this.getModel().getScreenColor(clipDrawIndex), this.getModel().getDrawableOpacity(clipDrawIndex), CubismBlendMode.CubismBlendMode_Normal,\n            // クリッピングは通常描画を強制\n            false // マスク生成時はクリッピングの反転使用は全く関係がない\n            );\n          }\n        }\n\n        {\n          // --- 後処理 ---\n          this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, s_fbo); // 描画対象を戻す\n          this.setClippingContextBufferForMask(null);\n          this.gl.viewport(s_viewport[0], s_viewport[1], s_viewport[2], s_viewport[3]);\n          this.preDraw(); // バッファをクリアする\n        }\n      }\n\n      // クリッピングマスクをセットする\n      this.setClippingContextBufferForDraw(clipContext);\n      this.setIsCulling(this.getModel().getDrawableCulling(drawableIndex));\n      this.drawMesh(this.getModel().getDrawableTextureIndex(drawableIndex), this.getModel().getDrawableVertexIndexCount(drawableIndex), this.getModel().getDrawableVertexCount(drawableIndex), this.getModel().getDrawableVertexIndices(drawableIndex), this.getModel().getDrawableVertices(drawableIndex), this.getModel().getDrawableVertexUvs(drawableIndex), this.getModel().getMultiplyColor(drawableIndex), this.getModel().getScreenColor(drawableIndex), this.getModel().getDrawableOpacity(drawableIndex), this.getModel().getDrawableBlendMode(drawableIndex), this.getModel().getDrawableInvertedMaskBit(drawableIndex));\n    }\n  }\n\n  /**\n   * [オーバーライド]\n   * 描画オブジェクト（アートメッシュ）を描画する。\n   * ポリゴンメッシュとテクスチャ番号をセットで渡す。\n   * @param textureNo 描画するテクスチャ番号\n   * @param indexCount 描画オブジェクトのインデックス値\n   * @param vertexCount ポリゴンメッシュの頂点数\n   * @param indexArray ポリゴンメッシュのインデックス配列\n   * @param vertexArray ポリゴンメッシュの頂点配列\n   * @param uvArray uv配列\n   * @param opacity 不透明度\n   * @param colorBlendMode カラー合成タイプ\n   * @param invertedMask マスク使用時のマスクの反転使用\n   */\n  drawMesh(textureNo, indexCount, vertexCount, indexArray, vertexArray, uvArray, multiplyColor, screenColor, opacity, colorBlendMode, invertedMask) {\n    // 裏面描画の有効・無効\n    if (this.isCulling()) {\n      this.gl.enable(this.gl.CULL_FACE);\n    } else {\n      this.gl.disable(this.gl.CULL_FACE);\n    }\n    this.gl.frontFace(this.gl.CCW); // Cubism SDK OpenGLはマスク・アートメッシュ共にCCWが表面\n\n    const modelColorRGBA = this.getModelColor();\n    if (this.getClippingContextBufferForMask() == null) {\n      // マスク生成時以外\n      modelColorRGBA.A *= opacity;\n      if (this.isPremultipliedAlpha()) {\n        modelColorRGBA.R *= modelColorRGBA.A;\n        modelColorRGBA.G *= modelColorRGBA.A;\n        modelColorRGBA.B *= modelColorRGBA.A;\n      }\n    }\n    let drawtexture; // シェーダに渡すテクスチャ\n\n    // テクスチャマップからバインド済みテクスチャＩＤを取得\n    // バインドされていなければダミーのテクスチャIDをセットする\n    if (this._textures.getValue(textureNo) != null) {\n      drawtexture = this._textures.getValue(textureNo);\n    } else {\n      drawtexture = null;\n    }\n    CubismShader_WebGL.getInstance().setupShaderProgram(this, drawtexture, vertexCount, vertexArray, indexArray, uvArray, this._bufferData, opacity, colorBlendMode, modelColorRGBA, multiplyColor, screenColor, this.isPremultipliedAlpha(), this.getMvpMatrix(), invertedMask);\n\n    // ポリゴンメッシュを描画する\n    this.gl.drawElements(this.gl.TRIANGLES, indexCount, this.gl.UNSIGNED_SHORT, 0);\n\n    // 後処理\n    this.gl.useProgram(null);\n    this.setClippingContextBufferForDraw(null);\n    this.setClippingContextBufferForMask(null);\n  }\n  saveProfile() {\n    this._rendererProfile.save();\n  }\n  restoreProfile() {\n    this._rendererProfile.restore();\n  }\n\n  /**\n   * レンダラが保持する静的なリソースを解放する\n   * WebGLの静的なシェーダープログラムを解放する\n   */\n  static doStaticRelease() {\n    CubismShader_WebGL.deleteInstance();\n  }\n\n  /**\n   * レンダーステートを設定する\n   * @param fbo アプリケーション側で指定しているフレームバッファ\n   * @param viewport ビューポート\n   */\n  setRenderState(fbo, viewport) {\n    s_fbo = fbo;\n    s_viewport = viewport;\n  }\n\n  /**\n   * 描画開始時の追加処理\n   * モデルを描画する前にクリッピングマスクに必要な処理を実装している\n   */\n  preDraw() {\n    if (this.firstDraw) {\n      this.firstDraw = false;\n    }\n    this.gl.disable(this.gl.SCISSOR_TEST);\n    this.gl.disable(this.gl.STENCIL_TEST);\n    this.gl.disable(this.gl.DEPTH_TEST);\n\n    // カリング（1.0beta3）\n    this.gl.frontFace(this.gl.CW);\n    this.gl.enable(this.gl.BLEND);\n    this.gl.colorMask(true, true, true, true);\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null); // 前にバッファがバインドされていたら破棄する必要がある\n    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);\n\n    // 異方性フィルタリングを適用する\n    if (this.getAnisotropy() > 0.0 && this._extension) {\n      for (let i = 0; i < this._textures.getSize(); ++i) {\n        this.gl.bindTexture(this.gl.TEXTURE_2D, this._textures.getValue(i));\n        this.gl.texParameterf(this.gl.TEXTURE_2D, this._extension.TEXTURE_MAX_ANISOTROPY_EXT, this.getAnisotropy());\n      }\n    }\n  }\n\n  /**\n   * マスクテクスチャに描画するクリッピングコンテキストをセットする\n   */\n  setClippingContextBufferForMask(clip) {\n    this._clippingContextBufferForMask = clip;\n  }\n\n  /**\n   * マスクテクスチャに描画するクリッピングコンテキストを取得する\n   * @return マスクテクスチャに描画するクリッピングコンテキスト\n   */\n  getClippingContextBufferForMask() {\n    return this._clippingContextBufferForMask;\n  }\n\n  /**\n   * 画面上に描画するクリッピングコンテキストをセットする\n   */\n  setClippingContextBufferForDraw(clip) {\n    this._clippingContextBufferForDraw = clip;\n  }\n\n  /**\n   * 画面上に描画するクリッピングコンテキストを取得する\n   * @return 画面上に描画するクリッピングコンテキスト\n   */\n  getClippingContextBufferForDraw() {\n    return this._clippingContextBufferForDraw;\n  }\n\n  /**\n   * glの設定\n   */\n  startUp(gl) {\n    this.gl = gl;\n    if (this._clippingManager) {\n      this._clippingManager.setGL(gl);\n    }\n    CubismShader_WebGL.getInstance().setGl(gl);\n    this._rendererProfile.setGl(gl);\n\n    // 異方性フィルタリングが使用できるかチェック\n    this._extension = this.gl.getExtension('EXT_texture_filter_anisotropic') || this.gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic') || this.gl.getExtension('MOZ_EXT_texture_filter_anisotropic');\n  }\n\n  // webglコンテキスト\n}\n\n/**\n * レンダラが保持する静的なリソースを開放する\n */\nCubismRenderer.staticRelease = () => {\n  CubismRenderer_WebGL.doStaticRelease();\n};\n\n// Namespace definition for compatibility.\nimport * as $ from './cubismrenderer_webgl';\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport let Live2DCubismFramework;\n(function (_Live2DCubismFramework) {\n  const CubismClippingContext = _Live2DCubismFramework.CubismClippingContext = $.CubismClippingContext;\n  const CubismClippingManager_WebGL = _Live2DCubismFramework.CubismClippingManager_WebGL = $.CubismClippingManager_WebGL;\n  const CubismRenderTextureResource = _Live2DCubismFramework.CubismRenderTextureResource = $.CubismRenderTextureResource;\n  const CubismRenderer_WebGL = _Live2DCubismFramework.CubismRenderer_WebGL = $.CubismRenderer_WebGL;\n  const CubismShaderSet = _Live2DCubismFramework.CubismShaderSet = $.CubismShaderSet;\n  const CubismShader_WebGL = _Live2DCubismFramework.CubismShader_WebGL = $.CubismShader_WebGL;\n  const ShaderNames = _Live2DCubismFramework.ShaderNames = $.ShaderNames;\n})(Live2DCubismFramework || (Live2DCubismFramework = {}));","map":{"version":3,"names":["Constant","CubismMatrix44","csmMap","csmRect","csmVector","CubismLogError","CubismLogWarning","CubismBlendMode","CubismRenderer","CubismTextureColor","ColorChannelCount","ClippingMaskMaxCountOnDefault","ClippingMaskMaxCountOnMultiRenderTexture","ShaderCount","s_instance","s_viewport","s_fbo","CubismClippingManager_WebGL","getChannelFlagAsColor","channelNo","_channelColors","at","getMaskRenderTexture","_maskTexture","textures","frameNo","_currentFrameNo","_maskRenderTextures","clear","_maskColorBuffers","size","_clippingMaskBufferSize","index","_renderTextureCount","pushBack","gl","createTexture","bindTexture","TEXTURE_2D","texImage2D","RGBA","UNSIGNED_BYTE","texParameteri","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","TEXTURE_MIN_FILTER","LINEAR","TEXTURE_MAG_FILTER","createFramebuffer","bindFramebuffer","FRAMEBUFFER","framebufferTexture2D","COLOR_ATTACHMENT0","CubismRenderTextureResource","setGL","calcClippedDrawTotalBounds","model","clippingContext","clippedDrawTotalMinX","Number","MAX_VALUE","clippedDrawTotalMinY","clippedDrawTotalMaxX","MIN_VALUE","clippedDrawTotalMaxY","clippedDrawCount","_clippedDrawableIndexList","length","clippedDrawableIndex","drawableIndex","drawableVertexCount","getDrawableVertexCount","drawableVertexes","getDrawableVertices","minX","minY","maxX","maxY","loop","vertexStep","pi","vertexOffset","x","y","_allClippedDrawRect","width","height","_isUsing","w","h","constructor","_currentMaskRenderTexture","_clippingContextListForMask","_clippingContextListForDraw","_tmpMatrix","_tmpMatrixForMask","_tmpMatrixForDraw","_tmpBoundsOnModel","_clearedFrameBufferflags","tmp","R","G","B","A","release","i","getSize","set","deleteFramebuffer","deleteTexture","initialize","drawableCount","drawableMasks","drawableMaskCounts","renderTextureCount","findSameClip","CubismClippingContext","addClippedDrawable","setupClippingContext","renderer","usingClipCount","clipIndex","cc","setupLayoutBounds","isUsingHighPrecisionMask","viewport","preDraw","clipContext","allClipedDrawRect","layoutBoundsOnTex01","_layoutBounds","MARGIN","scaleX","scaleY","clipContextRenderTexture","_bufferIndex","ppu","getPixelsPerUnit","maskPixelSize","getClippingManager","physicalMaskWidth","physicalMaskHeight","setRect","expand","loadIdentity","translateRelative","scaleRelative","setMatrix","getArray","_matrixForMask","_matrixForDraw","clipDrawCount","_clippingIdCount","clipDrawIndex","_clippingIdList","getDrawableDynamicFlagVertexPositionsDidChange","setIsCulling","getDrawableCulling","clearColor","COLOR_BUFFER_BIT","setClippingContextBufferForMask","drawMesh","getDrawableTextureIndex","getDrawableVertexIndexCount","getDrawableVertexIndices","getDrawableVertexUvs","getMultiplyColor","getScreenColor","getDrawableOpacity","CubismBlendMode_Normal","count","sameCount","j","clipId","k","useClippingMaskMaxCount","_layoutChannelNo","layoutCountMaxValue","countPerSheetDiv","countPerSheetMod","div","mod","curClipIndex","renderTextureNo","layoutCount","checkChannelNo","xpos","ypos","getColorBuffer","getClippingContextListForDraw","getClippingMaskCount","setClippingMaskBufferSize","getClippingMaskBufferSize","getRenderTextureCount","texture","manager","clippingDrawableIndices","clipCount","_owner","push","setGl","CubismRendererProfile_WebGL","setGlEnable","enabled","enable","disable","setGlEnableVertexAttribArray","enableVertexAttribArray","disableVertexAttribArray","save","_lastArrayBufferBinding","getParameter","ARRAY_BUFFER_BINDING","ELEMENT_ARRAY_BUFFER_BINDING","_lastProgram","CURRENT_PROGRAM","_lastActiveTexture","ACTIVE_TEXTURE","activeTexture","TEXTURE1","_lastTexture1Binding2D","TEXTURE_BINDING_2D","TEXTURE0","_lastTexture0Binding2D","_lastVertexAttribArrayEnabled","getVertexAttrib","VERTEX_ATTRIB_ARRAY_ENABLED","_lastScissorTest","isEnabled","SCISSOR_TEST","_lastStencilTest","STENCIL_TEST","_lastDepthTest","DEPTH_TEST","_lastCullFace","CULL_FACE","_lastBlend","BLEND","_lastFrontFace","FRONT_FACE","_lastColorMask","COLOR_WRITEMASK","_lastBlending","BLEND_SRC_RGB","BLEND_DST_RGB","BLEND_SRC_ALPHA","BLEND_DST_ALPHA","_lastFBO","FRAMEBUFFER_BINDING","_lastViewport","VIEWPORT","restore","useProgram","frontFace","colorMask","bindBuffer","ARRAY_BUFFER","ELEMENT_ARRAY_BUFFER","_lastElementArrayBufferBinding","blendFuncSeparate","Array","CubismShader_WebGL","getInstance","deleteInstance","_shaderSets","releaseShaderProgram","setupShaderProgram","textureId","vertexCount","vertexArray","indexArray","uvArray","bufferData","opacity","colorBlendMode","baseColor","multiplyColor","screenColor","isPremultipliedAlpha","matrix4x4","invertedMask","generateShaders","SRC_COLOR","DST_COLOR","SRC_ALPHA","DST_ALPHA","getClippingContextBufferForMask","shaderSet","ShaderNames","ShaderNames_SetupMask","shaderProgram","uniform1i","samplerTexture0Location","vertex","createBuffer","DYNAMIC_DRAW","attributePositionLocation","vertexAttribPointer","FLOAT","uv","attributeTexCoordLocation","colorChannel","uniform4f","uniformChannelFlagLocation","uniformMatrix4fv","uniformClipMatrixLocation","rect","uniformBaseColorLocation","getRight","getBottom","uniformMultiplyColorLocation","uniformScreenColorLocation","ZERO","ONE_MINUS_SRC_COLOR","ONE_MINUS_SRC_ALPHA","masked","getClippingContextBufferForDraw","offset","CubismShaderSet","ShaderNames_NormalPremultipliedAlpha","ONE","CubismBlendMode_Additive","ShaderNames_AddPremultipliedAlpha","CubismBlendMode_Multiplicative","ShaderNames_MultPremultipliedAlpha","tex","samplerTexture1Location","uniformMatrixLocation","deleteProgram","loadShaderProgram","vertexShaderSrcSetupMask","fragmentShaderSrcsetupMask","vertexShaderSrc","fragmentShaderSrcPremultipliedAlpha","vertexShaderSrcMasked","fragmentShaderSrcMaskPremultipliedAlpha","fragmentShaderSrcMaskInvertedPremultipliedAlpha","getAttribLocation","getUniformLocation","vertexShaderSource","fragmentShaderSource","createProgram","vertShader","compileShaderSource","VERTEX_SHADER","fragShader","FRAGMENT_SHADER","attachShader","linkProgram","linkStatus","getProgramParameter","LINK_STATUS","deleteShader","shaderType","shaderSource","source","shader","createShader","compileShader","log","getShaderInfoLog","status","getShaderParameter","COMPILE_STATUS","CubismRenderer_WebGL","maskBufferCount","arguments","undefined","isUsingMasking","_clippingManager","getDrawableCount","getDrawableMasks","getDrawableMaskCounts","_sortedDrawableIndexList","resize","modelTextureNo","glTexture","_textures","setValue","getBindedTextures","_model","getModel","_clippingContextBufferForMask","_clippingContextBufferForDraw","_rendererProfile","firstDraw","_bufferData","_extension","WebGLBuffer","prepareCapacity","deleteBuffer","doDrawModel","renderOrder","getDrawableRenderOrders","order","getDrawableDynamicFlagIsVisible","setClippingContextBufferForDraw","getDrawableBlendMode","getDrawableInvertedMaskBit","textureNo","indexCount","isCulling","CCW","modelColorRGBA","getModelColor","drawtexture","getValue","getMvpMatrix","drawElements","TRIANGLES","UNSIGNED_SHORT","saveProfile","restoreProfile","doStaticRelease","setRenderState","fbo","CW","getAnisotropy","texParameterf","TEXTURE_MAX_ANISOTROPY_EXT","clip","startUp","getExtension","staticRelease","$","Live2DCubismFramework","_Live2DCubismFramework"],"sources":["C:/Users/cleyc/OneDrive/Documents/RR/RRWebsiteRenewed/my-app/src/Samples/TypeScript/Demo/Framework/src/rendering/cubismrenderer_webgl.ts"],"sourcesContent":["/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\n\nimport { Constant } from '../live2dcubismframework';\nimport { CubismMatrix44 } from '../math/cubismmatrix44';\nimport { CubismModel } from '../model/cubismmodel';\nimport { csmMap } from '../type/csmmap';\nimport { csmRect } from '../type/csmrectf';\nimport { csmVector } from '../type/csmvector';\nimport { CubismLogError, CubismLogWarning } from '../utils/cubismdebug';\nimport {\n  CubismBlendMode,\n  CubismRenderer,\n  CubismTextureColor,\n} from './cubismrenderer';\n\nconst ColorChannelCount = 4; // 実験時に1チャンネルの場合は1、RGBだけの場合は3、アルファも含める場合は4\nconst ClippingMaskMaxCountOnDefault = 36; // 通常のフレームバッファ一枚あたりのマスク最大数\nconst ClippingMaskMaxCountOnMultiRenderTexture = 32; // フレームバッファが2枚以上ある場合のフレームバッファ一枚あたりのマスク最大数\n\nconst ShaderCount = 10; // シェーダーの数 = マスク生成用 + (通常用 + 加算 + 乗算) * (マスク無の乗算済アルファ対応版 + マスク有の乗算済アルファ対応版 + マスク有反転の乗算済アルファ対応版)\nlet s_instance: CubismShader_WebGL;\nlet s_viewport: number[];\nlet s_fbo: WebGLFramebuffer;\n\n/**\n * クリッピングマスクの処理を実行するクラス\n */\nexport class CubismClippingManager_WebGL {\n  /**\n   * カラーチャンネル（RGBA）のフラグを取得する\n   * @param channelNo カラーチャンネル（RGBA）の番号（0:R, 1:G, 2:B, 3:A）\n   */\n  public getChannelFlagAsColor(channelNo: number): CubismTextureColor {\n    return this._channelColors.at(channelNo);\n  }\n\n  /**\n   * テンポラリのレンダーテクスチャのアドレスを取得する\n   * FrameBufferObjectが存在しない場合、新しく生成する\n   *\n   * @return レンダーテクスチャの配列\n   */\n  public getMaskRenderTexture(): csmVector<WebGLFramebuffer> {\n    // テンポラリのRenderTextureを取得する\n    if (this._maskTexture && this._maskTexture.textures != null) {\n      // 前回使ったものを返す\n      this._maskTexture.frameNo = this._currentFrameNo;\n    } else {\n      // FrameBufferObjectが存在しない場合、新しく生成する\n      if (this._maskRenderTextures != null) {\n        this._maskRenderTextures.clear();\n      }\n      this._maskRenderTextures = new csmVector<WebGLFramebuffer>();\n\n      // ColorBufferObjectが存在しない場合、新しく生成する\n      if (this._maskColorBuffers != null) {\n        this._maskColorBuffers.clear();\n      }\n      this._maskColorBuffers = new csmVector<WebGLTexture>();\n\n      // クリッピングバッファサイズを取得\n      const size: number = this._clippingMaskBufferSize;\n\n      for (let index = 0; index < this._renderTextureCount; index++) {\n        this._maskColorBuffers.pushBack(this.gl.createTexture()); // 直接代入\n        this.gl.bindTexture(\n          this.gl.TEXTURE_2D,\n          this._maskColorBuffers.at(index)\n        );\n        this.gl.texImage2D(\n          this.gl.TEXTURE_2D,\n          0,\n          this.gl.RGBA,\n          size,\n          size,\n          0,\n          this.gl.RGBA,\n          this.gl.UNSIGNED_BYTE,\n          null\n        );\n        this.gl.texParameteri(\n          this.gl.TEXTURE_2D,\n          this.gl.TEXTURE_WRAP_S,\n          this.gl.CLAMP_TO_EDGE\n        );\n        this.gl.texParameteri(\n          this.gl.TEXTURE_2D,\n          this.gl.TEXTURE_WRAP_T,\n          this.gl.CLAMP_TO_EDGE\n        );\n        this.gl.texParameteri(\n          this.gl.TEXTURE_2D,\n          this.gl.TEXTURE_MIN_FILTER,\n          this.gl.LINEAR\n        );\n        this.gl.texParameteri(\n          this.gl.TEXTURE_2D,\n          this.gl.TEXTURE_MAG_FILTER,\n          this.gl.LINEAR\n        );\n        this.gl.bindTexture(this.gl.TEXTURE_2D, null);\n\n        this._maskRenderTextures.pushBack(this.gl.createFramebuffer());\n        this.gl.bindFramebuffer(\n          this.gl.FRAMEBUFFER,\n          this._maskRenderTextures.at(index)\n        );\n        this.gl.framebufferTexture2D(\n          this.gl.FRAMEBUFFER,\n          this.gl.COLOR_ATTACHMENT0,\n          this.gl.TEXTURE_2D,\n          this._maskColorBuffers.at(index),\n          0\n        );\n      }\n      this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, s_fbo);\n\n      this._maskTexture = new CubismRenderTextureResource(\n        this._currentFrameNo,\n        this._maskRenderTextures\n      );\n    }\n\n    return this._maskTexture.textures;\n  }\n\n  /**\n   * WebGLレンダリングコンテキストを設定する\n   * @param gl WebGLレンダリングコンテキスト\n   */\n  public setGL(gl: WebGLRenderingContext): void {\n    this.gl = gl;\n  }\n\n  /**\n   * マスクされる描画オブジェクト群全体を囲む矩形（モデル座標系）を計算する\n   * @param model モデルのインスタンス\n   * @param clippingContext クリッピングマスクのコンテキスト\n   */\n  public calcClippedDrawTotalBounds(\n    model: CubismModel,\n    clippingContext: CubismClippingContext\n  ): void {\n    // 被クリッピングマスク（マスクされる描画オブジェクト）の全体の矩形\n    let clippedDrawTotalMinX: number = Number.MAX_VALUE;\n    let clippedDrawTotalMinY: number = Number.MAX_VALUE;\n    let clippedDrawTotalMaxX: number = Number.MIN_VALUE;\n    let clippedDrawTotalMaxY: number = Number.MIN_VALUE;\n\n    // このマスクが実際に必要か判定する\n    // このクリッピングを利用する「描画オブジェクト」がひとつでも使用可能であればマスクを生成する必要がある\n    const clippedDrawCount: number =\n      clippingContext._clippedDrawableIndexList.length;\n\n    for (\n      let clippedDrawableIndex = 0;\n      clippedDrawableIndex < clippedDrawCount;\n      clippedDrawableIndex++\n    ) {\n      // マスクを使用する描画オブジェクトの描画される矩形を求める\n      const drawableIndex: number =\n        clippingContext._clippedDrawableIndexList[clippedDrawableIndex];\n\n      const drawableVertexCount: number =\n        model.getDrawableVertexCount(drawableIndex);\n      const drawableVertexes: Float32Array =\n        model.getDrawableVertices(drawableIndex);\n\n      let minX: number = Number.MAX_VALUE;\n      let minY: number = Number.MAX_VALUE;\n      let maxX: number = -Number.MAX_VALUE;\n      let maxY: number = -Number.MAX_VALUE;\n\n      const loop: number = drawableVertexCount * Constant.vertexStep;\n      for (\n        let pi: number = Constant.vertexOffset;\n        pi < loop;\n        pi += Constant.vertexStep\n      ) {\n        const x: number = drawableVertexes[pi];\n        const y: number = drawableVertexes[pi + 1];\n\n        if (x < minX) {\n          minX = x;\n        }\n        if (x > maxX) {\n          maxX = x;\n        }\n        if (y < minY) {\n          minY = y;\n        }\n        if (y > maxY) {\n          maxY = y;\n        }\n      }\n\n      // 有効な点が一つも取れなかったのでスキップ\n      if (minX == Number.MAX_VALUE) {\n        continue;\n      }\n\n      // 全体の矩形に反映\n      if (minX < clippedDrawTotalMinX) {\n        clippedDrawTotalMinX = minX;\n      }\n      if (minY < clippedDrawTotalMinY) {\n        clippedDrawTotalMinY = minY;\n      }\n      if (maxX > clippedDrawTotalMaxX) {\n        clippedDrawTotalMaxX = maxX;\n      }\n      if (maxY > clippedDrawTotalMaxY) {\n        clippedDrawTotalMaxY = maxY;\n      }\n\n      if (clippedDrawTotalMinX == Number.MAX_VALUE) {\n        clippingContext._allClippedDrawRect.x = 0.0;\n        clippingContext._allClippedDrawRect.y = 0.0;\n        clippingContext._allClippedDrawRect.width = 0.0;\n        clippingContext._allClippedDrawRect.height = 0.0;\n        clippingContext._isUsing = false;\n      } else {\n        clippingContext._isUsing = true;\n        const w: number = clippedDrawTotalMaxX - clippedDrawTotalMinX;\n        const h: number = clippedDrawTotalMaxY - clippedDrawTotalMinY;\n        clippingContext._allClippedDrawRect.x = clippedDrawTotalMinX;\n        clippingContext._allClippedDrawRect.y = clippedDrawTotalMinY;\n        clippingContext._allClippedDrawRect.width = w;\n        clippingContext._allClippedDrawRect.height = h;\n      }\n    }\n  }\n\n  /**\n   * コンストラクタ\n   */\n  public constructor() {\n    this._currentMaskRenderTexture = null;\n    this._maskColorBuffers = null;\n    this._currentFrameNo = 0;\n    this._renderTextureCount = 0;\n    this._clippingMaskBufferSize = 256;\n    this._clippingContextListForMask = new csmVector<CubismClippingContext>();\n    this._clippingContextListForDraw = new csmVector<CubismClippingContext>();\n    this._channelColors = new csmVector<CubismTextureColor>();\n    this._tmpBoundsOnModel = new csmRect();\n    this._tmpMatrix = new CubismMatrix44();\n    this._tmpMatrixForMask = new CubismMatrix44();\n    this._tmpMatrixForDraw = new CubismMatrix44();\n    this._maskTexture = null;\n\n    let tmp: CubismTextureColor = new CubismTextureColor();\n    tmp.R = 1.0;\n    tmp.G = 0.0;\n    tmp.B = 0.0;\n    tmp.A = 0.0;\n    this._channelColors.pushBack(tmp);\n\n    tmp = new CubismTextureColor();\n    tmp.R = 0.0;\n    tmp.G = 1.0;\n    tmp.B = 0.0;\n    tmp.A = 0.0;\n    this._channelColors.pushBack(tmp);\n\n    tmp = new CubismTextureColor();\n    tmp.R = 0.0;\n    tmp.G = 0.0;\n    tmp.B = 1.0;\n    tmp.A = 0.0;\n    this._channelColors.pushBack(tmp);\n\n    tmp = new CubismTextureColor();\n    tmp.R = 0.0;\n    tmp.G = 0.0;\n    tmp.B = 0.0;\n    tmp.A = 1.0;\n    this._channelColors.pushBack(tmp);\n  }\n\n  /**\n   * デストラクタ相当の処理\n   */\n  public release(): void {\n    for (let i = 0; i < this._clippingContextListForMask.getSize(); i++) {\n      if (this._clippingContextListForMask.at(i)) {\n        this._clippingContextListForMask.at(i).release();\n        this._clippingContextListForMask.set(i, void 0);\n      }\n      this._clippingContextListForMask.set(i, null);\n    }\n    this._clippingContextListForMask = null;\n\n    // _clippingContextListForDrawは_clippingContextListForMaskにあるインスタンスを指している。上記の処理により要素ごとのDELETEは不要。\n    for (let i = 0; i < this._clippingContextListForDraw.getSize(); i++) {\n      this._clippingContextListForDraw.set(i, null);\n    }\n    this._clippingContextListForDraw = null;\n\n    if (this._maskTexture) {\n      for (let i = 0; i < this._maskTexture.textures.getSize(); i++) {\n        this.gl.deleteFramebuffer(this._maskTexture.textures.at(i));\n      }\n      this._maskTexture.textures.clear();\n      this._maskTexture.textures = null;\n      this._maskTexture = null;\n    }\n\n    for (let i = 0; i < this._channelColors.getSize(); i++) {\n      this._channelColors.set(i, null);\n    }\n\n    this._channelColors = null;\n\n    // テクスチャ解放\n    if (this._maskColorBuffers != null) {\n      for (let index = 0; index < this._maskColorBuffers.getSize(); index++) {\n        this.gl.deleteTexture(this._maskColorBuffers.at(index));\n      }\n      this._maskColorBuffers.clear();\n    }\n    this._maskColorBuffers = null;\n\n    if (this._maskRenderTextures != null) {\n      this._maskRenderTextures.clear();\n    }\n    this._maskRenderTextures = null;\n\n    if (this._clearedFrameBufferflags != null) {\n      this._clearedFrameBufferflags.clear();\n    }\n    this._clearedFrameBufferflags = null;\n  }\n\n  /**\n   * マネージャの初期化処理\n   * クリッピングマスクを使う描画オブジェクトの登録を行う\n   * @param model モデルのインスタンス\n   * @param drawableCount 描画オブジェクトの数\n   * @param drawableMasks 描画オブジェクトをマスクする描画オブジェクトのインデックスのリスト\n   * @param drawableMaskCounts 描画オブジェクトをマスクする描画オブジェクトの数\n   * @param renderTextureCount バッファの生成数\n   */\n  public initialize(\n    model: CubismModel,\n    drawableCount: number,\n    drawableMasks: Int32Array[],\n    drawableMaskCounts: Int32Array,\n    renderTextureCount: number\n  ): void {\n    // レンダーテクスチャの合計枚数の設定\n    // 1以上の整数でない場合はそれぞれ警告を出す\n    if (renderTextureCount % 1 != 0) {\n      CubismLogWarning(\n        'The number of render textures must be specified as an integer. The decimal point is rounded down and corrected to an integer.'\n      );\n      // 小数点以下を除去\n      renderTextureCount = ~~renderTextureCount;\n    }\n    if (renderTextureCount < 1) {\n      CubismLogWarning(\n        'The number of render textures must be an integer greater than or equal to 1. Set the number of render textures to 1.'\n      );\n    }\n    // 負の値が使われている場合は強制的に1枚と設定する\n    this._renderTextureCount = renderTextureCount < 1 ? 1 : renderTextureCount;\n\n    this._clearedFrameBufferflags = new csmVector<boolean>(\n      this._renderTextureCount\n    );\n\n    // クリッピングマスクを使う描画オブジェクトをすべて登録する\n    // クリッピングマスクは、通常数個程度に限定して使うものとする\n    for (let i = 0; i < drawableCount; i++) {\n      if (drawableMaskCounts[i] <= 0) {\n        // クリッピングマスクが使用されていないアートメッシュ（多くの場合使用しない）\n        this._clippingContextListForDraw.pushBack(null);\n        continue;\n      }\n\n      // 既にあるClipContextと同じかチェックする\n      let clippingContext: CubismClippingContext = this.findSameClip(\n        drawableMasks[i],\n        drawableMaskCounts[i]\n      );\n      if (clippingContext == null) {\n        // 同一のマスクが存在していない場合は生成する\n        clippingContext = new CubismClippingContext(\n          this,\n          drawableMasks[i],\n          drawableMaskCounts[i]\n        );\n        this._clippingContextListForMask.pushBack(clippingContext);\n      }\n\n      clippingContext.addClippedDrawable(i);\n\n      this._clippingContextListForDraw.pushBack(clippingContext);\n    }\n  }\n\n  /**\n   * クリッピングコンテキストを作成する。モデル描画時に実行する。\n   * @param model モデルのインスタンス\n   * @param renderer レンダラのインスタンス\n   */\n  public setupClippingContext(\n    model: CubismModel,\n    renderer: CubismRenderer_WebGL\n  ): void {\n    this._currentFrameNo++;\n\n    // 全てのクリッピングを用意する\n    // 同じクリップ（複数の場合はまとめて一つのクリップ）を使う場合は1度だけ設定する\n    let usingClipCount = 0;\n    for (\n      let clipIndex = 0;\n      clipIndex < this._clippingContextListForMask.getSize();\n      clipIndex++\n    ) {\n      // 1つのクリッピングマスクに関して\n      const cc: CubismClippingContext =\n        this._clippingContextListForMask.at(clipIndex);\n\n      // このクリップを利用する描画オブジェクト群全体を囲む矩形を計算\n      this.calcClippedDrawTotalBounds(model, cc);\n\n      if (cc._isUsing) {\n        usingClipCount++; // 使用中としてカウント\n      }\n    }\n\n    // マスク作成処理\n    if (usingClipCount > 0) {\n      // 各マスクのレイアウトを決定していく\n      this.setupLayoutBounds(\n        renderer.isUsingHighPrecisionMask() ? 0 : usingClipCount\n      );\n\n      if (!renderer.isUsingHighPrecisionMask()) {\n        // 生成したFrameBufferと同じサイズでビューポートを設定\n        this.gl.viewport(\n          0,\n          0,\n          this._clippingMaskBufferSize,\n          this._clippingMaskBufferSize\n        );\n\n        // 後の計算のためにインデックスの最初をセット\n        this._currentMaskRenderTexture = this.getMaskRenderTexture().at(0);\n\n        renderer.preDraw(); // バッファをクリアする\n\n        // ---------- マスク描画処理 ----------\n        // マスク用RenderTextureをactiveにセット\n        this.gl.bindFramebuffer(\n          this.gl.FRAMEBUFFER,\n          this._currentMaskRenderTexture\n        );\n      }\n\n      // サイズがレンダーテクスチャの枚数と合わない場合は合わせる\n      if (this._clearedFrameBufferflags.getSize() != this._renderTextureCount) {\n        this._clearedFrameBufferflags.clear();\n        this._clearedFrameBufferflags = new csmVector<boolean>(\n          this._renderTextureCount\n        );\n      }\n\n      // マスクのクリアフラグを毎フレーム開始時に初期化\n      for (\n        let index = 0;\n        index < this._clearedFrameBufferflags.getSize();\n        index++\n      ) {\n        this._clearedFrameBufferflags.set(index, false);\n      }\n\n      // 実際にマスクを生成する\n      // 全てのマスクをどのようにレイアウトして描くかを決定し、ClipContext, ClippedDrawContextに記憶する\n      for (\n        let clipIndex = 0;\n        clipIndex < this._clippingContextListForMask.getSize();\n        clipIndex++\n      ) {\n        // --- 実際に1つのマスクを描く ---\n        const clipContext: CubismClippingContext =\n          this._clippingContextListForMask.at(clipIndex);\n        const allClipedDrawRect: csmRect = clipContext._allClippedDrawRect; // このマスクを使う、すべての描画オブジェクトの論理座標上の囲み矩形\n        const layoutBoundsOnTex01: csmRect = clipContext._layoutBounds; // この中にマスクを収める\n        const MARGIN = 0.05; // モデル座標上の矩形を、適宜マージンを付けて使う\n        let scaleX = 0;\n        let scaleY = 0;\n\n        // clipContextに設定したレンダーテクスチャをインデックスで取得\n        const clipContextRenderTexture = this.getMaskRenderTexture().at(\n          clipContext._bufferIndex\n        );\n\n        // 現在のレンダーテクスチャがclipContextのものと異なる場合\n        if (\n          this._currentMaskRenderTexture != clipContextRenderTexture &&\n          !renderer.isUsingHighPrecisionMask()\n        ) {\n          this._currentMaskRenderTexture = clipContextRenderTexture;\n          renderer.preDraw(); // バッファをクリアする\n          // マスク用RenderTextureをactiveにセット\n          this.gl.bindFramebuffer(\n            this.gl.FRAMEBUFFER,\n            this._currentMaskRenderTexture\n          );\n        }\n\n        if (renderer.isUsingHighPrecisionMask()) {\n          const ppu: number = model.getPixelsPerUnit();\n          const maskPixelSize: number =\n            clipContext.getClippingManager()._clippingMaskBufferSize;\n          const physicalMaskWidth: number =\n            layoutBoundsOnTex01.width * maskPixelSize;\n          const physicalMaskHeight: number =\n            layoutBoundsOnTex01.height * maskPixelSize;\n\n          this._tmpBoundsOnModel.setRect(allClipedDrawRect);\n\n          if (this._tmpBoundsOnModel.width * ppu > physicalMaskWidth) {\n            this._tmpBoundsOnModel.expand(\n              allClipedDrawRect.width * MARGIN,\n              0.0\n            );\n            scaleX = layoutBoundsOnTex01.width / this._tmpBoundsOnModel.width;\n          } else {\n            scaleX = ppu / physicalMaskWidth;\n          }\n\n          if (this._tmpBoundsOnModel.height * ppu > physicalMaskHeight) {\n            this._tmpBoundsOnModel.expand(\n              0.0,\n              allClipedDrawRect.height * MARGIN\n            );\n            scaleY = layoutBoundsOnTex01.height / this._tmpBoundsOnModel.height;\n          } else {\n            scaleY = ppu / physicalMaskHeight;\n          }\n        } else {\n          this._tmpBoundsOnModel.setRect(allClipedDrawRect);\n          this._tmpBoundsOnModel.expand(\n            allClipedDrawRect.width * MARGIN,\n            allClipedDrawRect.height * MARGIN\n          );\n          //########## 本来は割り当てられた領域の全体を使わず必要最低限のサイズがよい\n\n          // シェーダ用の計算式を求める。回転を考慮しない場合は以下のとおり\n          // movePeriod' = movePeriod * scaleX + offX\t\t  [[ movePeriod' = (movePeriod - tmpBoundsOnModel.movePeriod)*scale + layoutBoundsOnTex01.movePeriod ]]\n          scaleX = layoutBoundsOnTex01.width / this._tmpBoundsOnModel.width;\n          scaleY = layoutBoundsOnTex01.height / this._tmpBoundsOnModel.height;\n        }\n\n        // マスク生成時に使う行列を求める\n        {\n          // シェーダに渡す行列を求める <<<<<<<<<<<<<<<<<<<<<<<< 要最適化（逆順に計算すればシンプルにできる）\n          this._tmpMatrix.loadIdentity();\n          {\n            // layout0..1 を -1..1に変換\n            this._tmpMatrix.translateRelative(-1.0, -1.0);\n            this._tmpMatrix.scaleRelative(2.0, 2.0);\n          }\n          {\n            // view to layout0..1\n            this._tmpMatrix.translateRelative(\n              layoutBoundsOnTex01.x,\n              layoutBoundsOnTex01.y\n            );\n            this._tmpMatrix.scaleRelative(scaleX, scaleY); // new = [translate][scale]\n            this._tmpMatrix.translateRelative(\n              -this._tmpBoundsOnModel.x,\n              -this._tmpBoundsOnModel.y\n            );\n            // new = [translate][scale][translate]\n          }\n          // tmpMatrixForMaskが計算結果\n          this._tmpMatrixForMask.setMatrix(this._tmpMatrix.getArray());\n        }\n\n        //--------- draw時の mask 参照用行列を計算\n        {\n          // シェーダに渡す行列を求める <<<<<<<<<<<<<<<<<<<<<<<< 要最適化（逆順に計算すればシンプルにできる）\n          this._tmpMatrix.loadIdentity();\n          {\n            this._tmpMatrix.translateRelative(\n              layoutBoundsOnTex01.x,\n              layoutBoundsOnTex01.y\n            );\n            this._tmpMatrix.scaleRelative(scaleX, scaleY); // new = [translate][scale]\n            this._tmpMatrix.translateRelative(\n              -this._tmpBoundsOnModel.x,\n              -this._tmpBoundsOnModel.y\n            );\n            // new = [translate][scale][translate]\n          }\n          this._tmpMatrixForDraw.setMatrix(this._tmpMatrix.getArray());\n        }\n        clipContext._matrixForMask.setMatrix(this._tmpMatrixForMask.getArray());\n        clipContext._matrixForDraw.setMatrix(this._tmpMatrixForDraw.getArray());\n\n        if (!renderer.isUsingHighPrecisionMask()) {\n          const clipDrawCount: number = clipContext._clippingIdCount;\n          for (let i = 0; i < clipDrawCount; i++) {\n            const clipDrawIndex: number = clipContext._clippingIdList[i];\n\n            // 頂点情報が更新されておらず、信頼性がない場合は描画をパスする\n            if (\n              !model.getDrawableDynamicFlagVertexPositionsDidChange(\n                clipDrawIndex\n              )\n            ) {\n              continue;\n            }\n\n            renderer.setIsCulling(\n              model.getDrawableCulling(clipDrawIndex) != false\n            );\n\n            // マスクがクリアされていないなら処理する\n            if (!this._clearedFrameBufferflags.at(clipContext._bufferIndex)) {\n              // マスクをクリアする\n              // (仮仕様) 1が無効（描かれない）領域、0が有効（描かれる）領域。（シェーダーCd*Csで0に近い値をかけてマスクを作る。1をかけると何も起こらない）\n              this.gl.clearColor(1.0, 1.0, 1.0, 1.0);\n              this.gl.clear(this.gl.COLOR_BUFFER_BIT);\n              this._clearedFrameBufferflags.set(clipContext._bufferIndex, true);\n            }\n\n            // 今回専用の変換を適用して描く\n            // チャンネルも切り替える必要がある(A,R,G,B)\n            renderer.setClippingContextBufferForMask(clipContext);\n            renderer.drawMesh(\n              model.getDrawableTextureIndex(clipDrawIndex),\n              model.getDrawableVertexIndexCount(clipDrawIndex),\n              model.getDrawableVertexCount(clipDrawIndex),\n              model.getDrawableVertexIndices(clipDrawIndex),\n              model.getDrawableVertices(clipDrawIndex),\n              model.getDrawableVertexUvs(clipDrawIndex),\n              model.getMultiplyColor(clipDrawIndex),\n              model.getScreenColor(clipDrawIndex),\n              model.getDrawableOpacity(clipDrawIndex),\n              CubismBlendMode.CubismBlendMode_Normal, // クリッピングは通常描画を強制\n              false // マスク生成時はクリッピングの反転使用は全く関係がない\n            );\n          }\n        }\n      }\n\n      if (!renderer.isUsingHighPrecisionMask()) {\n        // --- 後処理 ---\n        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, s_fbo); // 描画対象を戻す\n        renderer.setClippingContextBufferForMask(null);\n\n        this.gl.viewport(\n          s_viewport[0],\n          s_viewport[1],\n          s_viewport[2],\n          s_viewport[3]\n        );\n      }\n    }\n  }\n\n  /**\n   * 既にマスクを作っているかを確認\n   * 作っている様であれば該当するクリッピングマスクのインスタンスを返す\n   * 作っていなければNULLを返す\n   * @param drawableMasks 描画オブジェクトをマスクする描画オブジェクトのリスト\n   * @param drawableMaskCounts 描画オブジェクトをマスクする描画オブジェクトの数\n   * @return 該当するクリッピングマスクが存在すればインスタンスを返し、なければNULLを返す\n   */\n  public findSameClip(\n    drawableMasks: Int32Array,\n    drawableMaskCounts: number\n  ): CubismClippingContext {\n    // 作成済みClippingContextと一致するか確認\n    for (let i = 0; i < this._clippingContextListForMask.getSize(); i++) {\n      const clippingContext: CubismClippingContext =\n        this._clippingContextListForMask.at(i);\n      const count: number = clippingContext._clippingIdCount;\n\n      // 個数が違う場合は別物\n      if (count != drawableMaskCounts) {\n        continue;\n      }\n\n      let sameCount = 0;\n\n      // 同じIDを持つか確認。配列の数が同じなので、一致した個数が同じなら同じ物を持つとする\n      for (let j = 0; j < count; j++) {\n        const clipId: number = clippingContext._clippingIdList[j];\n\n        for (let k = 0; k < count; k++) {\n          if (drawableMasks[k] == clipId) {\n            sameCount++;\n            break;\n          }\n        }\n      }\n\n      if (sameCount == count) {\n        return clippingContext;\n      }\n    }\n\n    return null; // 見つからなかった\n  }\n\n  /**\n   * クリッピングコンテキストを配置するレイアウト\n   * 指定された数のレンダーテクスチャを極力いっぱいに使ってマスクをレイアウトする\n   * マスクグループの数が4以下ならRGBA各チャンネルに一つずつマスクを配置し、5以上6以下ならRGBAを2,2,1,1と配置する。\n   *\n   * @param usingClipCount 配置するクリッピングコンテキストの数\n   */\n  public setupLayoutBounds(usingClipCount: number): void {\n    const useClippingMaskMaxCount =\n      this._renderTextureCount <= 1\n        ? ClippingMaskMaxCountOnDefault\n        : ClippingMaskMaxCountOnMultiRenderTexture * this._renderTextureCount;\n\n    if (usingClipCount <= 0 || usingClipCount > useClippingMaskMaxCount) {\n      if (usingClipCount > useClippingMaskMaxCount) {\n        // マスクの制限数の警告を出す\n        CubismLogError(\n          'not supported mask count : {0}\\n[Details] render texture count : {1}, mask count : {2}',\n          usingClipCount - useClippingMaskMaxCount,\n          this._renderTextureCount,\n          usingClipCount\n        );\n      }\n      // この場合は一つのマスクターゲットを毎回クリアして使用する\n      for (\n        let index = 0;\n        index < this._clippingContextListForMask.getSize();\n        index++\n      ) {\n        const clipContext: CubismClippingContext =\n          this._clippingContextListForMask.at(index);\n        clipContext._layoutChannelNo = 0; // どうせ毎回消すので固定\n        clipContext._layoutBounds.x = 0.0;\n        clipContext._layoutBounds.y = 0.0;\n        clipContext._layoutBounds.width = 1.0;\n        clipContext._layoutBounds.height = 1.0;\n        clipContext._bufferIndex = 0;\n      }\n      return;\n    }\n\n    // レンダーテクスチャが1枚なら9分割する（最大36枚）\n    const layoutCountMaxValue = this._renderTextureCount <= 1 ? 9 : 8;\n\n    // 指定された数のレンダーテクスチャを極力いっぱいに使ってマスクをレイアウトする（デフォルトなら1）\n    // マスクグループの数が4以下ならRGBA各チャンネルに1つずつマスクを配置し、5以上6以下ならRGBAを2,2,1,1と配置する\n    let countPerSheetDiv: number = usingClipCount / this._renderTextureCount; // レンダーテクスチャ1枚あたり何枚割り当てるか\n    let countPerSheetMod: number = usingClipCount % this._renderTextureCount; // この番号のレンダーテクスチャまでに一つずつ配分する\n\n    // 小数点は切り捨てる\n    countPerSheetDiv = ~~countPerSheetDiv;\n    countPerSheetMod = ~~countPerSheetMod;\n\n    // RGBAを順番に使っていく\n    let div: number = countPerSheetDiv / ColorChannelCount; // 1チャンネルに配置する基本のマスク\n    let mod: number = countPerSheetDiv % ColorChannelCount; // 余り、この番号のチャンネルまでに一つずつ配分する\n\n    // 小数点は切り捨てる\n    div = ~~div;\n    mod = ~~mod;\n\n    // RGBAそれぞれのチャンネルを用意していく（0:R, 1:G, 2:B, 3:A）\n    let curClipIndex = 0; // 順番に設定していく\n\n    for (\n      let renderTextureNo = 0;\n      renderTextureNo < this._renderTextureCount;\n      renderTextureNo++\n    ) {\n      for (let channelNo = 0; channelNo < ColorChannelCount; channelNo++) {\n        // このチャンネルにレイアウトする数\n        let layoutCount: number = div + (channelNo < mod ? 1 : 0);\n\n        // このレンダーテクスチャにまだ割り当てられていなければ追加する\n        const checkChannelNo = mod + 1 >= ColorChannelCount ? 0 : mod + 1;\n        if (layoutCount < layoutCountMaxValue && channelNo == checkChannelNo) {\n          layoutCount += renderTextureNo < countPerSheetMod ? 1 : 0;\n        }\n\n        // 分割方法を決定する\n        if (layoutCount == 0) {\n          // 何もしない\n        } else if (layoutCount == 1) {\n          // 全てをそのまま使う\n          const clipContext: CubismClippingContext =\n            this._clippingContextListForMask.at(curClipIndex++);\n          clipContext._layoutChannelNo = channelNo;\n          clipContext._layoutBounds.x = 0.0;\n          clipContext._layoutBounds.y = 0.0;\n          clipContext._layoutBounds.width = 1.0;\n          clipContext._layoutBounds.height = 1.0;\n          clipContext._bufferIndex = renderTextureNo;\n        } else if (layoutCount == 2) {\n          for (let i = 0; i < layoutCount; i++) {\n            let xpos: number = i % 2;\n\n            // 小数点は切り捨てる\n            xpos = ~~xpos;\n\n            const cc: CubismClippingContext =\n              this._clippingContextListForMask.at(curClipIndex++);\n            cc._layoutChannelNo = channelNo;\n\n            // UVを2つに分解して使う\n            cc._layoutBounds.x = xpos * 0.5;\n            cc._layoutBounds.y = 0.0;\n            cc._layoutBounds.width = 0.5;\n            cc._layoutBounds.height = 1.0;\n            cc._bufferIndex = renderTextureNo;\n          }\n        } else if (layoutCount <= 4) {\n          // 4分割して使う\n          for (let i = 0; i < layoutCount; i++) {\n            let xpos: number = i % 2;\n            let ypos: number = i / 2;\n\n            // 小数点は切り捨てる\n            xpos = ~~xpos;\n            ypos = ~~ypos;\n\n            const cc = this._clippingContextListForMask.at(curClipIndex++);\n            cc._layoutChannelNo = channelNo;\n\n            cc._layoutBounds.x = xpos * 0.5;\n            cc._layoutBounds.y = ypos * 0.5;\n            cc._layoutBounds.width = 0.5;\n            cc._layoutBounds.height = 0.5;\n            cc._bufferIndex = renderTextureNo;\n          }\n        } else if (layoutCount <= layoutCountMaxValue) {\n          // 9分割して使う\n          for (let i = 0; i < layoutCount; i++) {\n            let xpos = i % 3;\n            let ypos = i / 3;\n\n            // 小数点は切り捨てる\n            xpos = ~~xpos;\n            ypos = ~~ypos;\n\n            const cc: CubismClippingContext =\n              this._clippingContextListForMask.at(curClipIndex++);\n            cc._layoutChannelNo = channelNo;\n\n            cc._layoutBounds.x = xpos / 3.0;\n            cc._layoutBounds.y = ypos / 3.0;\n            cc._layoutBounds.width = 1.0 / 3.0;\n            cc._layoutBounds.height = 1.0 / 3.0;\n            cc._bufferIndex = renderTextureNo;\n          }\n        } else {\n          // マスクの制限枚数を超えた場合の処理\n          CubismLogError(\n            'not supported mask count : {0}\\n[Details] render texture count : {1}, mask count : {2}',\n            usingClipCount - useClippingMaskMaxCount,\n            this._renderTextureCount,\n            usingClipCount\n          );\n\n          // SetupShaderProgramでオーバーアクセスが発生するので仮で数値を入れる\n          // もちろん描画結果は正しいものではなくなる\n          for (let index = 0; index < layoutCount; index++) {\n            const cc: CubismClippingContext =\n              this._clippingContextListForMask.at(curClipIndex++);\n\n            cc._layoutChannelNo = 0;\n\n            cc._layoutBounds.x = 0.0;\n            cc._layoutBounds.y = 0.0;\n            cc._layoutBounds.width = 1.0;\n            cc._layoutBounds.height = 1.0;\n            cc._bufferIndex = 0;\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * カラーバッファを取得する\n   * @return カラーバッファ\n   */\n  public getColorBuffer(): csmVector<WebGLTexture> {\n    return this._maskColorBuffers;\n  }\n\n  /**\n   * 画面描画に使用するクリッピングマスクのリストを取得する\n   * @return 画面描画に使用するクリッピングマスクのリスト\n   */\n  public getClippingContextListForDraw(): csmVector<CubismClippingContext> {\n    return this._clippingContextListForDraw;\n  }\n\n  /**\n   * マスクの合計数をカウント\n   * @returns\n   */\n  public getClippingMaskCount(): number {\n    return this._clippingContextListForMask.getSize();\n  }\n\n  /**\n   * クリッピングマスクバッファのサイズを設定する\n   * @param size クリッピングマスクバッファのサイズ\n   */\n  public setClippingMaskBufferSize(size: number): void {\n    this._clippingMaskBufferSize = size;\n  }\n\n  /**\n   * クリッピングマスクバッファのサイズを取得する\n   * @return クリッピングマスクバッファのサイズ\n   */\n  public getClippingMaskBufferSize(): number {\n    return this._clippingMaskBufferSize;\n  }\n\n  /**\n   * このバッファのレンダーテクスチャの枚数を取得する\n   * @return このバッファのレンダーテクスチャの枚数\n   */\n  public getRenderTextureCount(): number {\n    return this._renderTextureCount;\n  }\n\n  public _currentMaskRenderTexture: WebGLFramebuffer; // マスク用レンダーテクスチャのアドレス\n  public _maskRenderTextures: csmVector<WebGLFramebuffer>; // レンダーテクスチャのリスト\n  public _maskColorBuffers: csmVector<WebGLTexture>; // マスク用カラーバッファーのアドレスのリスト\n  public _currentFrameNo: number; // マスクテクスチャに与えるフレーム番号\n\n  public _channelColors: csmVector<CubismTextureColor>;\n  public _maskTexture: CubismRenderTextureResource; // マスク用のテクスチャリソースのリスト\n  public _clippingContextListForMask: csmVector<CubismClippingContext>; // マスク用クリッピングコンテキストのリスト\n  public _clippingContextListForDraw: csmVector<CubismClippingContext>; // 描画用クリッピングコンテキストのリスト\n  public _clippingMaskBufferSize: number; // クリッピングマスクのバッファサイズ（初期値:256）\n  public _renderTextureCount: number; // 生成するレンダーテクスチャの枚数\n\n  private _tmpMatrix: CubismMatrix44; // マスク計算用の行列\n  private _tmpMatrixForMask: CubismMatrix44; // マスク計算用の行列\n  private _tmpMatrixForDraw: CubismMatrix44; // マスク計算用の行列\n  private _tmpBoundsOnModel: csmRect; // マスク配置計算用の矩形\n  private _clearedFrameBufferflags: csmVector<boolean>; //マスクのクリアフラグの配列\n\n  gl: WebGLRenderingContext; // WebGLレンダリングコンテキスト\n}\n\n/**\n * レンダーテクスチャのリソースを定義する構造体\n * クリッピングマスクで使用する\n */\nexport class CubismRenderTextureResource {\n  /**\n   * 引数付きコンストラクタ\n   * @param frameNo レンダラーのフレーム番号\n   * @param texture テクスチャのアドレス\n   */\n  public constructor(frameNo: number, texture: csmVector<WebGLFramebuffer>) {\n    this.frameNo = frameNo;\n    this.textures = texture;\n  }\n\n  public frameNo: number; // レンダラのフレーム番号\n  public textures: csmVector<WebGLFramebuffer>; // テクスチャのアドレス\n}\n\n/**\n * クリッピングマスクのコンテキスト\n */\nexport class CubismClippingContext {\n  /**\n   * 引数付きコンストラクタ\n   */\n  public constructor(\n    manager: CubismClippingManager_WebGL,\n    clippingDrawableIndices: Int32Array,\n    clipCount: number\n  ) {\n    this._owner = manager;\n\n    // クリップしている（＝マスク用の）Drawableのインデックスリスト\n    this._clippingIdList = clippingDrawableIndices;\n\n    // マスクの数\n    this._clippingIdCount = clipCount;\n\n    this._allClippedDrawRect = new csmRect();\n    this._layoutBounds = new csmRect();\n\n    this._clippedDrawableIndexList = [];\n\n    this._matrixForMask = new CubismMatrix44();\n    this._matrixForDraw = new CubismMatrix44();\n\n    this._bufferIndex = 0;\n  }\n\n  /**\n   * デストラクタ相当の処理\n   */\n  public release(): void {\n    if (this._layoutBounds != null) {\n      this._layoutBounds = null;\n    }\n\n    if (this._allClippedDrawRect != null) {\n      this._allClippedDrawRect = null;\n    }\n\n    if (this._clippedDrawableIndexList != null) {\n      this._clippedDrawableIndexList = null;\n    }\n  }\n\n  /**\n   * このマスクにクリップされる描画オブジェクトを追加する\n   *\n   * @param drawableIndex クリッピング対象に追加する描画オブジェクトのインデックス\n   */\n  public addClippedDrawable(drawableIndex: number) {\n    this._clippedDrawableIndexList.push(drawableIndex);\n  }\n\n  /**\n   * このマスクを管理するマネージャのインスタンスを取得する\n   * @return クリッピングマネージャのインスタンス\n   */\n  public getClippingManager(): CubismClippingManager_WebGL {\n    return this._owner;\n  }\n\n  public setGl(gl: WebGLRenderingContext): void {\n    this._owner.setGL(gl);\n  }\n\n  public _isUsing: boolean; // 現在の描画状態でマスクの準備が必要ならtrue\n  public readonly _clippingIdList: Int32Array; // クリッピングマスクのIDリスト\n  public _clippingIdCount: number; // クリッピングマスクの数\n  public _layoutChannelNo: number; // RGBAのいずれのチャンネルにこのクリップを配置するか（0:R, 1:G, 2:B, 3:A）\n  public _layoutBounds: csmRect; // マスク用チャンネルのどの領域にマスクを入れるか（View座標-1~1, UVは0~1に直す）\n  public _allClippedDrawRect: csmRect; // このクリッピングで、クリッピングされるすべての描画オブジェクトの囲み矩形（毎回更新）\n  public _matrixForMask: CubismMatrix44; // マスクの位置計算結果を保持する行列\n  public _matrixForDraw: CubismMatrix44; // 描画オブジェクトの位置計算結果を保持する行列\n  public _clippedDrawableIndexList: number[]; // このマスクにクリップされる描画オブジェクトのリスト\n  public _bufferIndex: number; // このマスクが割り当てられるレンダーテクスチャ（フレームバッファ）やカラーバッファのインデックス\n\n  private _owner: CubismClippingManager_WebGL; // このマスクを管理しているマネージャのインスタンス\n}\n\nexport class CubismRendererProfile_WebGL {\n  private setGlEnable(index: GLenum, enabled: GLboolean): void {\n    if (enabled) this.gl.enable(index);\n    else this.gl.disable(index);\n  }\n\n  private setGlEnableVertexAttribArray(\n    index: GLuint,\n    enabled: GLboolean\n  ): void {\n    if (enabled) this.gl.enableVertexAttribArray(index);\n    else this.gl.disableVertexAttribArray(index);\n  }\n\n  public save(): void {\n    if (this.gl == null) {\n      CubismLogError(\n        \"'gl' is null. WebGLRenderingContext is required.\\nPlease call 'CubimRenderer_WebGL.startUp' function.\"\n      );\n      return;\n    }\n    //-- push state --\n    this._lastArrayBufferBinding = this.gl.getParameter(\n      this.gl.ARRAY_BUFFER_BINDING\n    );\n    this._lastArrayBufferBinding = this.gl.getParameter(\n      this.gl.ELEMENT_ARRAY_BUFFER_BINDING\n    );\n    this._lastProgram = this.gl.getParameter(this.gl.CURRENT_PROGRAM);\n\n    this._lastActiveTexture = this.gl.getParameter(this.gl.ACTIVE_TEXTURE);\n    this.gl.activeTexture(this.gl.TEXTURE1); //テクスチャユニット1をアクティブに（以後の設定対象とする）\n    this._lastTexture1Binding2D = this.gl.getParameter(\n      this.gl.TEXTURE_BINDING_2D\n    );\n\n    this.gl.activeTexture(this.gl.TEXTURE0); //テクスチャユニット0をアクティブに（以後の設定対象とする）\n    this._lastTexture0Binding2D = this.gl.getParameter(\n      this.gl.TEXTURE_BINDING_2D\n    );\n\n    this._lastVertexAttribArrayEnabled[0] = this.gl.getVertexAttrib(\n      0,\n      this.gl.VERTEX_ATTRIB_ARRAY_ENABLED\n    );\n    this._lastVertexAttribArrayEnabled[1] = this.gl.getVertexAttrib(\n      1,\n      this.gl.VERTEX_ATTRIB_ARRAY_ENABLED\n    );\n    this._lastVertexAttribArrayEnabled[2] = this.gl.getVertexAttrib(\n      2,\n      this.gl.VERTEX_ATTRIB_ARRAY_ENABLED\n    );\n    this._lastVertexAttribArrayEnabled[3] = this.gl.getVertexAttrib(\n      3,\n      this.gl.VERTEX_ATTRIB_ARRAY_ENABLED\n    );\n\n    this._lastScissorTest = this.gl.isEnabled(this.gl.SCISSOR_TEST);\n    this._lastStencilTest = this.gl.isEnabled(this.gl.STENCIL_TEST);\n    this._lastDepthTest = this.gl.isEnabled(this.gl.DEPTH_TEST);\n    this._lastCullFace = this.gl.isEnabled(this.gl.CULL_FACE);\n    this._lastBlend = this.gl.isEnabled(this.gl.BLEND);\n\n    this._lastFrontFace = this.gl.getParameter(this.gl.FRONT_FACE);\n\n    this._lastColorMask = this.gl.getParameter(this.gl.COLOR_WRITEMASK);\n\n    // backup blending\n    this._lastBlending[0] = this.gl.getParameter(this.gl.BLEND_SRC_RGB);\n    this._lastBlending[1] = this.gl.getParameter(this.gl.BLEND_DST_RGB);\n    this._lastBlending[2] = this.gl.getParameter(this.gl.BLEND_SRC_ALPHA);\n    this._lastBlending[3] = this.gl.getParameter(this.gl.BLEND_DST_ALPHA);\n\n    // モデル描画直前のFBOとビューポートを保存\n    this._lastFBO = this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING);\n    this._lastViewport = this.gl.getParameter(this.gl.VIEWPORT);\n  }\n\n  public restore(): void {\n    if (this.gl == null) {\n      CubismLogError(\n        \"'gl' is null. WebGLRenderingContext is required.\\nPlease call 'CubimRenderer_WebGL.startUp' function.\"\n      );\n      return;\n    }\n    this.gl.useProgram(this._lastProgram);\n\n    this.setGlEnableVertexAttribArray(0, this._lastVertexAttribArrayEnabled[0]);\n    this.setGlEnableVertexAttribArray(1, this._lastVertexAttribArrayEnabled[1]);\n    this.setGlEnableVertexAttribArray(2, this._lastVertexAttribArrayEnabled[2]);\n    this.setGlEnableVertexAttribArray(3, this._lastVertexAttribArrayEnabled[3]);\n\n    this.setGlEnable(this.gl.SCISSOR_TEST, this._lastScissorTest);\n    this.setGlEnable(this.gl.STENCIL_TEST, this._lastStencilTest);\n    this.setGlEnable(this.gl.DEPTH_TEST, this._lastDepthTest);\n    this.setGlEnable(this.gl.CULL_FACE, this._lastCullFace);\n    this.setGlEnable(this.gl.BLEND, this._lastBlend);\n\n    this.gl.frontFace(this._lastFrontFace);\n\n    this.gl.colorMask(\n      this._lastColorMask[0],\n      this._lastColorMask[1],\n      this._lastColorMask[2],\n      this._lastColorMask[3]\n    );\n\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this._lastArrayBufferBinding); //前にバッファがバインドされていたら破棄する必要がある\n    this.gl.bindBuffer(\n      this.gl.ELEMENT_ARRAY_BUFFER,\n      this._lastElementArrayBufferBinding\n    );\n\n    this.gl.activeTexture(this.gl.TEXTURE1); //テクスチャユニット1を復元\n    this.gl.bindTexture(this.gl.TEXTURE_2D, this._lastTexture1Binding2D);\n\n    this.gl.activeTexture(this.gl.TEXTURE0); //テクスチャユニット0を復元\n    this.gl.bindTexture(this.gl.TEXTURE_2D, this._lastTexture0Binding2D);\n\n    this.gl.activeTexture(this._lastActiveTexture);\n\n    this.gl.blendFuncSeparate(\n      this._lastBlending[0],\n      this._lastBlending[1],\n      this._lastBlending[2],\n      this._lastBlending[3]\n    );\n  }\n\n  public setGl(gl: WebGLRenderingContext): void {\n    this.gl = gl;\n  }\n\n  constructor() {\n    this._lastVertexAttribArrayEnabled = new Array<GLboolean>(4);\n    this._lastColorMask = new Array<GLboolean>(4);\n    this._lastBlending = new Array<GLint>(4);\n    this._lastViewport = new Array<GLint>(4);\n  }\n\n  private _lastArrayBufferBinding: GLint; ///< モデル描画直前の頂点バッファ\n  private _lastElementArrayBufferBinding: GLint; ///< モデル描画直前のElementバッファ\n  private _lastProgram: GLint; ///< モデル描画直前のシェーダプログラムバッファ\n  private _lastActiveTexture: GLint; ///< モデル描画直前のアクティブなテクスチャ\n  private _lastTexture0Binding2D: GLint; ///< モデル描画直前のテクスチャユニット0\n  private _lastTexture1Binding2D: GLint; ///< モデル描画直前のテクスチャユニット1\n  private _lastVertexAttribArrayEnabled: GLboolean[]; ///< モデル描画直前のテクスチャユニット1\n  private _lastScissorTest: GLboolean; ///< モデル描画直前のGL_VERTEX_ATTRIB_ARRAY_ENABLEDパラメータ\n  private _lastBlend: GLboolean; ///< モデル描画直前のGL_SCISSOR_TESTパラメータ\n  private _lastStencilTest: GLboolean; ///< モデル描画直前のGL_STENCIL_TESTパラメータ\n  private _lastDepthTest: GLboolean; ///< モデル描画直前のGL_DEPTH_TESTパラメータ\n  private _lastCullFace: GLboolean; ///< モデル描画直前のGL_CULL_FACEパラメータ\n  private _lastFrontFace: GLint; ///< モデル描画直前のGL_CULL_FACEパラメータ\n  private _lastColorMask: GLboolean[]; ///< モデル描画直前のGL_COLOR_WRITEMASKパラメータ\n  private _lastBlending: GLint[]; ///< モデル描画直前のカラーブレンディングパラメータ\n  private _lastFBO: GLint; ///< モデル描画直前のフレームバッファ\n  private _lastViewport: GLint[]; ///< モデル描画直前のビューポート\n\n  gl: WebGLRenderingContext;\n}\n\n/**\n * WebGL用のシェーダープログラムを生成・破棄するクラス\n * シングルトンなクラスであり、CubismShader_WebGL.getInstanceからアクセスする。\n */\nexport class CubismShader_WebGL {\n  /**\n   * インスタンスを取得する（シングルトン）\n   * @return インスタンス\n   */\n  public static getInstance(): CubismShader_WebGL {\n    if (s_instance == null) {\n      s_instance = new CubismShader_WebGL();\n\n      return s_instance;\n    }\n    return s_instance;\n  }\n\n  /**\n   * インスタンスを開放する（シングルトン）\n   */\n  public static deleteInstance(): void {\n    if (s_instance) {\n      s_instance.release();\n      s_instance = null;\n    }\n  }\n\n  /**\n   * privateなコンストラクタ\n   */\n  private constructor() {\n    this._shaderSets = new csmVector<CubismShaderSet>();\n  }\n\n  /**\n   * デストラクタ相当の処理\n   */\n  public release(): void {\n    this.releaseShaderProgram();\n  }\n\n  /**\n   * シェーダープログラムの一連のセットアップを実行する\n   * @param renderer レンダラのインスタンス\n   * @param textureId GPUのテクスチャID\n   * @param vertexCount ポリゴンメッシュの頂点数\n   * @param vertexArray ポリゴンメッシュの頂点配列\n   * @param indexArray インデックスバッファの頂点配列\n   * @param uvArray uv配列\n   * @param opacity 不透明度\n   * @param colorBlendMode カラーブレンディングのタイプ\n   * @param baseColor ベースカラー\n   * @param isPremultipliedAlpha 乗算済みアルファかどうか\n   * @param matrix4x4 Model-View-Projection行列\n   * @param invertedMask マスクを反転して使用するフラグ\n   */\n  public setupShaderProgram(\n    renderer: CubismRenderer_WebGL,\n    textureId: WebGLTexture,\n    vertexCount: number,\n    vertexArray: Float32Array,\n    indexArray: Uint16Array,\n    uvArray: Float32Array,\n    bufferData: {\n      vertex: WebGLBuffer;\n      uv: WebGLBuffer;\n      index: WebGLBuffer;\n    },\n    opacity: number,\n    colorBlendMode: CubismBlendMode,\n    baseColor: CubismTextureColor,\n    multiplyColor: CubismTextureColor,\n    screenColor: CubismTextureColor,\n    isPremultipliedAlpha: boolean,\n    matrix4x4: CubismMatrix44,\n    invertedMask: boolean\n  ): void {\n    if (!isPremultipliedAlpha) {\n      CubismLogError('NoPremultipliedAlpha is not allowed');\n    }\n\n    if (this._shaderSets.getSize() == 0) {\n      this.generateShaders();\n    }\n\n    // Blending\n    let SRC_COLOR: number;\n    let DST_COLOR: number;\n    let SRC_ALPHA: number;\n    let DST_ALPHA: number;\n\n    if (renderer.getClippingContextBufferForMask() != null) {\n      // マスク生成時\n      const shaderSet: CubismShaderSet = this._shaderSets.at(\n        ShaderNames.ShaderNames_SetupMask\n      );\n      this.gl.useProgram(shaderSet.shaderProgram);\n\n      // テクスチャ設定\n      this.gl.activeTexture(this.gl.TEXTURE0);\n      this.gl.bindTexture(this.gl.TEXTURE_2D, textureId);\n      this.gl.uniform1i(shaderSet.samplerTexture0Location, 0);\n\n      // 頂点配列の設定(VBO)\n      if (bufferData.vertex == null) {\n        bufferData.vertex = this.gl.createBuffer();\n      }\n      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, bufferData.vertex);\n      this.gl.bufferData(\n        this.gl.ARRAY_BUFFER,\n        vertexArray,\n        this.gl.DYNAMIC_DRAW\n      );\n      this.gl.enableVertexAttribArray(shaderSet.attributePositionLocation);\n      this.gl.vertexAttribPointer(\n        shaderSet.attributePositionLocation,\n        2,\n        this.gl.FLOAT,\n        false,\n        0,\n        0\n      );\n\n      // テクスチャ頂点の設定\n      if (bufferData.uv == null) {\n        bufferData.uv = this.gl.createBuffer();\n      }\n      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, bufferData.uv);\n      this.gl.bufferData(this.gl.ARRAY_BUFFER, uvArray, this.gl.DYNAMIC_DRAW);\n      this.gl.enableVertexAttribArray(shaderSet.attributeTexCoordLocation);\n      this.gl.vertexAttribPointer(\n        shaderSet.attributeTexCoordLocation,\n        2,\n        this.gl.FLOAT,\n        false,\n        0,\n        0\n      );\n\n      // チャンネル\n      const channelNo: number =\n        renderer.getClippingContextBufferForMask()._layoutChannelNo;\n      const colorChannel: CubismTextureColor = renderer\n        .getClippingContextBufferForMask()\n        .getClippingManager()\n        .getChannelFlagAsColor(channelNo);\n      this.gl.uniform4f(\n        shaderSet.uniformChannelFlagLocation,\n        colorChannel.R,\n        colorChannel.G,\n        colorChannel.B,\n        colorChannel.A\n      );\n\n      this.gl.uniformMatrix4fv(\n        shaderSet.uniformClipMatrixLocation,\n        false,\n        renderer.getClippingContextBufferForMask()._matrixForMask.getArray()\n      );\n\n      const rect: csmRect =\n        renderer.getClippingContextBufferForMask()._layoutBounds;\n\n      this.gl.uniform4f(\n        shaderSet.uniformBaseColorLocation,\n        rect.x * 2.0 - 1.0,\n        rect.y * 2.0 - 1.0,\n        rect.getRight() * 2.0 - 1.0,\n        rect.getBottom() * 2.0 - 1.0\n      );\n\n      this.gl.uniform4f(\n        shaderSet.uniformMultiplyColorLocation,\n        multiplyColor.R,\n        multiplyColor.G,\n        multiplyColor.B,\n        multiplyColor.A\n      );\n\n      this.gl.uniform4f(\n        shaderSet.uniformScreenColorLocation,\n        screenColor.R,\n        screenColor.G,\n        screenColor.B,\n        screenColor.A\n      );\n\n      SRC_COLOR = this.gl.ZERO;\n      DST_COLOR = this.gl.ONE_MINUS_SRC_COLOR;\n      SRC_ALPHA = this.gl.ZERO;\n      DST_ALPHA = this.gl.ONE_MINUS_SRC_ALPHA;\n    } // マスク生成以外の場合\n    else {\n      const masked: boolean =\n        renderer.getClippingContextBufferForDraw() != null; // この描画オブジェクトはマスク対象か\n      const offset: number = masked ? (invertedMask ? 2 : 1) : 0;\n\n      let shaderSet: CubismShaderSet = new CubismShaderSet();\n\n      switch (colorBlendMode) {\n        case CubismBlendMode.CubismBlendMode_Normal:\n        default:\n          shaderSet = this._shaderSets.at(\n            ShaderNames.ShaderNames_NormalPremultipliedAlpha + offset\n          );\n          SRC_COLOR = this.gl.ONE;\n          DST_COLOR = this.gl.ONE_MINUS_SRC_ALPHA;\n          SRC_ALPHA = this.gl.ONE;\n          DST_ALPHA = this.gl.ONE_MINUS_SRC_ALPHA;\n          break;\n\n        case CubismBlendMode.CubismBlendMode_Additive:\n          shaderSet = this._shaderSets.at(\n            ShaderNames.ShaderNames_AddPremultipliedAlpha + offset\n          );\n          SRC_COLOR = this.gl.ONE;\n          DST_COLOR = this.gl.ONE;\n          SRC_ALPHA = this.gl.ZERO;\n          DST_ALPHA = this.gl.ONE;\n          break;\n\n        case CubismBlendMode.CubismBlendMode_Multiplicative:\n          shaderSet = this._shaderSets.at(\n            ShaderNames.ShaderNames_MultPremultipliedAlpha + offset\n          );\n          SRC_COLOR = this.gl.DST_COLOR;\n          DST_COLOR = this.gl.ONE_MINUS_SRC_ALPHA;\n          SRC_ALPHA = this.gl.ZERO;\n          DST_ALPHA = this.gl.ONE;\n          break;\n      }\n\n      this.gl.useProgram(shaderSet.shaderProgram);\n\n      // 頂点配列の設定\n      if (bufferData.vertex == null) {\n        bufferData.vertex = this.gl.createBuffer();\n      }\n      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, bufferData.vertex);\n      this.gl.bufferData(\n        this.gl.ARRAY_BUFFER,\n        vertexArray,\n        this.gl.DYNAMIC_DRAW\n      );\n      this.gl.enableVertexAttribArray(shaderSet.attributePositionLocation);\n      this.gl.vertexAttribPointer(\n        shaderSet.attributePositionLocation,\n        2,\n        this.gl.FLOAT,\n        false,\n        0,\n        0\n      );\n\n      // テクスチャ頂点の設定\n      if (bufferData.uv == null) {\n        bufferData.uv = this.gl.createBuffer();\n      }\n      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, bufferData.uv);\n      this.gl.bufferData(this.gl.ARRAY_BUFFER, uvArray, this.gl.DYNAMIC_DRAW);\n      this.gl.enableVertexAttribArray(shaderSet.attributeTexCoordLocation);\n      this.gl.vertexAttribPointer(\n        shaderSet.attributeTexCoordLocation,\n        2,\n        this.gl.FLOAT,\n        false,\n        0,\n        0\n      );\n\n      if (masked) {\n        this.gl.activeTexture(this.gl.TEXTURE1);\n        const tex: WebGLTexture = renderer\n          .getClippingContextBufferForDraw()\n          .getClippingManager()\n          .getColorBuffer()\n          .at(renderer.getClippingContextBufferForDraw()._bufferIndex);\n        this.gl.bindTexture(this.gl.TEXTURE_2D, tex);\n        this.gl.uniform1i(shaderSet.samplerTexture1Location, 1);\n\n        // view座標をClippingContextの座標に変換するための行列を設定\n        this.gl.uniformMatrix4fv(\n          shaderSet.uniformClipMatrixLocation,\n          false,\n          renderer.getClippingContextBufferForDraw()._matrixForDraw.getArray()\n        );\n\n        // 使用するカラーチャンネルを設定\n        const channelNo: number =\n          renderer.getClippingContextBufferForDraw()._layoutChannelNo;\n        const colorChannel: CubismTextureColor = renderer\n          .getClippingContextBufferForDraw()\n          .getClippingManager()\n          .getChannelFlagAsColor(channelNo);\n        this.gl.uniform4f(\n          shaderSet.uniformChannelFlagLocation,\n          colorChannel.R,\n          colorChannel.G,\n          colorChannel.B,\n          colorChannel.A\n        );\n      }\n\n      // テクスチャ設定\n      this.gl.activeTexture(this.gl.TEXTURE0);\n      this.gl.bindTexture(this.gl.TEXTURE_2D, textureId);\n      this.gl.uniform1i(shaderSet.samplerTexture0Location, 0);\n\n      // 座標変換\n      this.gl.uniformMatrix4fv(\n        shaderSet.uniformMatrixLocation,\n        false,\n        matrix4x4.getArray()\n      );\n\n      this.gl.uniform4f(\n        shaderSet.uniformBaseColorLocation,\n        baseColor.R,\n        baseColor.G,\n        baseColor.B,\n        baseColor.A\n      );\n\n      this.gl.uniform4f(\n        shaderSet.uniformMultiplyColorLocation,\n        multiplyColor.R,\n        multiplyColor.G,\n        multiplyColor.B,\n        multiplyColor.A\n      );\n\n      this.gl.uniform4f(\n        shaderSet.uniformScreenColorLocation,\n        screenColor.R,\n        screenColor.G,\n        screenColor.B,\n        screenColor.A\n      );\n    }\n\n    // IBOを作成し、データを転送\n    if (bufferData.index == null) {\n      bufferData.index = this.gl.createBuffer();\n    }\n    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, bufferData.index);\n    this.gl.bufferData(\n      this.gl.ELEMENT_ARRAY_BUFFER,\n      indexArray,\n      this.gl.DYNAMIC_DRAW\n    );\n    this.gl.blendFuncSeparate(SRC_COLOR, DST_COLOR, SRC_ALPHA, DST_ALPHA);\n  }\n\n  /**\n   * シェーダープログラムを解放する\n   */\n  public releaseShaderProgram(): void {\n    for (let i = 0; i < this._shaderSets.getSize(); i++) {\n      this.gl.deleteProgram(this._shaderSets.at(i).shaderProgram);\n      this._shaderSets.at(i).shaderProgram = 0;\n      this._shaderSets.set(i, void 0);\n      this._shaderSets.set(i, null);\n    }\n  }\n\n  /**\n   * シェーダープログラムを初期化する\n   * @param vertShaderSrc 頂点シェーダのソース\n   * @param fragShaderSrc フラグメントシェーダのソース\n   */\n  public generateShaders(): void {\n    for (let i = 0; i < ShaderCount; i++) {\n      this._shaderSets.pushBack(new CubismShaderSet());\n    }\n\n    this._shaderSets.at(0).shaderProgram = this.loadShaderProgram(\n      vertexShaderSrcSetupMask,\n      fragmentShaderSrcsetupMask\n    );\n\n    this._shaderSets.at(1).shaderProgram = this.loadShaderProgram(\n      vertexShaderSrc,\n      fragmentShaderSrcPremultipliedAlpha\n    );\n    this._shaderSets.at(2).shaderProgram = this.loadShaderProgram(\n      vertexShaderSrcMasked,\n      fragmentShaderSrcMaskPremultipliedAlpha\n    );\n    this._shaderSets.at(3).shaderProgram = this.loadShaderProgram(\n      vertexShaderSrcMasked,\n      fragmentShaderSrcMaskInvertedPremultipliedAlpha\n    );\n\n    // 加算も通常と同じシェーダーを利用する\n    this._shaderSets.at(4).shaderProgram = this._shaderSets.at(1).shaderProgram;\n    this._shaderSets.at(5).shaderProgram = this._shaderSets.at(2).shaderProgram;\n    this._shaderSets.at(6).shaderProgram = this._shaderSets.at(3).shaderProgram;\n\n    // 乗算も通常と同じシェーダーを利用する\n    this._shaderSets.at(7).shaderProgram = this._shaderSets.at(1).shaderProgram;\n    this._shaderSets.at(8).shaderProgram = this._shaderSets.at(2).shaderProgram;\n    this._shaderSets.at(9).shaderProgram = this._shaderSets.at(3).shaderProgram;\n\n    // SetupMask\n    this._shaderSets.at(0).attributePositionLocation =\n      this.gl.getAttribLocation(\n        this._shaderSets.at(0).shaderProgram,\n        'a_position'\n      );\n    this._shaderSets.at(0).attributeTexCoordLocation =\n      this.gl.getAttribLocation(\n        this._shaderSets.at(0).shaderProgram,\n        'a_texCoord'\n      );\n    this._shaderSets.at(0).samplerTexture0Location = this.gl.getUniformLocation(\n      this._shaderSets.at(0).shaderProgram,\n      's_texture0'\n    );\n    this._shaderSets.at(0).uniformClipMatrixLocation =\n      this.gl.getUniformLocation(\n        this._shaderSets.at(0).shaderProgram,\n        'u_clipMatrix'\n      );\n    this._shaderSets.at(0).uniformChannelFlagLocation =\n      this.gl.getUniformLocation(\n        this._shaderSets.at(0).shaderProgram,\n        'u_channelFlag'\n      );\n    this._shaderSets.at(0).uniformBaseColorLocation =\n      this.gl.getUniformLocation(\n        this._shaderSets.at(0).shaderProgram,\n        'u_baseColor'\n      );\n    this._shaderSets.at(0).uniformMultiplyColorLocation =\n      this.gl.getUniformLocation(\n        this._shaderSets.at(0).shaderProgram,\n        'u_multiplyColor'\n      );\n    this._shaderSets.at(0).uniformScreenColorLocation =\n      this.gl.getUniformLocation(\n        this._shaderSets.at(0).shaderProgram,\n        'u_screenColor'\n      );\n\n    // 通常（PremultipliedAlpha）\n    this._shaderSets.at(1).attributePositionLocation =\n      this.gl.getAttribLocation(\n        this._shaderSets.at(1).shaderProgram,\n        'a_position'\n      );\n    this._shaderSets.at(1).attributeTexCoordLocation =\n      this.gl.getAttribLocation(\n        this._shaderSets.at(1).shaderProgram,\n        'a_texCoord'\n      );\n    this._shaderSets.at(1).samplerTexture0Location = this.gl.getUniformLocation(\n      this._shaderSets.at(1).shaderProgram,\n      's_texture0'\n    );\n    this._shaderSets.at(1).uniformMatrixLocation = this.gl.getUniformLocation(\n      this._shaderSets.at(1).shaderProgram,\n      'u_matrix'\n    );\n    this._shaderSets.at(1).uniformBaseColorLocation =\n      this.gl.getUniformLocation(\n        this._shaderSets.at(1).shaderProgram,\n        'u_baseColor'\n      );\n    this._shaderSets.at(1).uniformMultiplyColorLocation =\n      this.gl.getUniformLocation(\n        this._shaderSets.at(1).shaderProgram,\n        'u_multiplyColor'\n      );\n    this._shaderSets.at(1).uniformScreenColorLocation =\n      this.gl.getUniformLocation(\n        this._shaderSets.at(1).shaderProgram,\n        'u_screenColor'\n      );\n\n    // 通常（クリッピング、PremultipliedAlpha）\n    this._shaderSets.at(2).attributePositionLocation =\n      this.gl.getAttribLocation(\n        this._shaderSets.at(2).shaderProgram,\n        'a_position'\n      );\n    this._shaderSets.at(2).attributeTexCoordLocation =\n      this.gl.getAttribLocation(\n        this._shaderSets.at(2).shaderProgram,\n        'a_texCoord'\n      );\n    this._shaderSets.at(2).samplerTexture0Location = this.gl.getUniformLocation(\n      this._shaderSets.at(2).shaderProgram,\n      's_texture0'\n    );\n    this._shaderSets.at(2).samplerTexture1Location = this.gl.getUniformLocation(\n      this._shaderSets.at(2).shaderProgram,\n      's_texture1'\n    );\n    this._shaderSets.at(2).uniformMatrixLocation = this.gl.getUniformLocation(\n      this._shaderSets.at(2).shaderProgram,\n      'u_matrix'\n    );\n    this._shaderSets.at(2).uniformClipMatrixLocation =\n      this.gl.getUniformLocation(\n        this._shaderSets.at(2).shaderProgram,\n        'u_clipMatrix'\n      );\n    this._shaderSets.at(2).uniformChannelFlagLocation =\n      this.gl.getUniformLocation(\n        this._shaderSets.at(2).shaderProgram,\n        'u_channelFlag'\n      );\n    this._shaderSets.at(2).uniformBaseColorLocation =\n      this.gl.getUniformLocation(\n        this._shaderSets.at(2).shaderProgram,\n        'u_baseColor'\n      );\n    this._shaderSets.at(2).uniformMultiplyColorLocation =\n      this.gl.getUniformLocation(\n        this._shaderSets.at(2).shaderProgram,\n        'u_multiplyColor'\n      );\n    this._shaderSets.at(2).uniformScreenColorLocation =\n      this.gl.getUniformLocation(\n        this._shaderSets.at(2).shaderProgram,\n        'u_screenColor'\n      );\n\n    // 通常（クリッピング・反転, PremultipliedAlpha）\n    this._shaderSets.at(3).attributePositionLocation =\n      this.gl.getAttribLocation(\n        this._shaderSets.at(3).shaderProgram,\n        'a_position'\n      );\n    this._shaderSets.at(3).attributeTexCoordLocation =\n      this.gl.getAttribLocation(\n        this._shaderSets.at(3).shaderProgram,\n        'a_texCoord'\n      );\n    this._shaderSets.at(3).samplerTexture0Location = this.gl.getUniformLocation(\n      this._shaderSets.at(3).shaderProgram,\n      's_texture0'\n    );\n    this._shaderSets.at(3).samplerTexture1Location = this.gl.getUniformLocation(\n      this._shaderSets.at(3).shaderProgram,\n      's_texture1'\n    );\n    this._shaderSets.at(3).uniformMatrixLocation = this.gl.getUniformLocation(\n      this._shaderSets.at(3).shaderProgram,\n      'u_matrix'\n    );\n    this._shaderSets.at(3).uniformClipMatrixLocation =\n      this.gl.getUniformLocation(\n        this._shaderSets.at(3).shaderProgram,\n        'u_clipMatrix'\n      );\n    this._shaderSets.at(3).uniformChannelFlagLocation =\n      this.gl.getUniformLocation(\n        this._shaderSets.at(3).shaderProgram,\n        'u_channelFlag'\n      );\n    this._shaderSets.at(3).uniformBaseColorLocation =\n      this.gl.getUniformLocation(\n        this._shaderSets.at(3).shaderProgram,\n        'u_baseColor'\n      );\n    this._shaderSets.at(3).uniformMultiplyColorLocation =\n      this.gl.getUniformLocation(\n        this._shaderSets.at(3).shaderProgram,\n        'u_multiplyColor'\n      );\n    this._shaderSets.at(3).uniformScreenColorLocation =\n      this.gl.getUniformLocation(\n        this._shaderSets.at(3).shaderProgram,\n        'u_screenColor'\n      );\n\n    // 加算（PremultipliedAlpha）\n    this._shaderSets.at(4).attributePositionLocation =\n      this.gl.getAttribLocation(\n        this._shaderSets.at(4).shaderProgram,\n        'a_position'\n      );\n    this._shaderSets.at(4).attributeTexCoordLocation =\n      this.gl.getAttribLocation(\n        this._shaderSets.at(4).shaderProgram,\n        'a_texCoord'\n      );\n    this._shaderSets.at(4).samplerTexture0Location = this.gl.getUniformLocation(\n      this._shaderSets.at(4).shaderProgram,\n      's_texture0'\n    );\n    this._shaderSets.at(4).uniformMatrixLocation = this.gl.getUniformLocation(\n      this._shaderSets.at(4).shaderProgram,\n      'u_matrix'\n    );\n    this._shaderSets.at(4).uniformBaseColorLocation =\n      this.gl.getUniformLocation(\n        this._shaderSets.at(4).shaderProgram,\n        'u_baseColor'\n      );\n    this._shaderSets.at(4).uniformMultiplyColorLocation =\n      this.gl.getUniformLocation(\n        this._shaderSets.at(4).shaderProgram,\n        'u_multiplyColor'\n      );\n    this._shaderSets.at(4).uniformScreenColorLocation =\n      this.gl.getUniformLocation(\n        this._shaderSets.at(4).shaderProgram,\n        'u_screenColor'\n      );\n\n    // 加算（クリッピング、PremultipliedAlpha）\n    this._shaderSets.at(5).attributePositionLocation =\n      this.gl.getAttribLocation(\n        this._shaderSets.at(5).shaderProgram,\n        'a_position'\n      );\n    this._shaderSets.at(5).attributeTexCoordLocation =\n      this.gl.getAttribLocation(\n        this._shaderSets.at(5).shaderProgram,\n        'a_texCoord'\n      );\n    this._shaderSets.at(5).samplerTexture0Location = this.gl.getUniformLocation(\n      this._shaderSets.at(5).shaderProgram,\n      's_texture0'\n    );\n    this._shaderSets.at(5).samplerTexture1Location = this.gl.getUniformLocation(\n      this._shaderSets.at(5).shaderProgram,\n      's_texture1'\n    );\n    this._shaderSets.at(5).uniformMatrixLocation = this.gl.getUniformLocation(\n      this._shaderSets.at(5).shaderProgram,\n      'u_matrix'\n    );\n    this._shaderSets.at(5).uniformClipMatrixLocation =\n      this.gl.getUniformLocation(\n        this._shaderSets.at(5).shaderProgram,\n        'u_clipMatrix'\n      );\n    this._shaderSets.at(5).uniformChannelFlagLocation =\n      this.gl.getUniformLocation(\n        this._shaderSets.at(5).shaderProgram,\n        'u_channelFlag'\n      );\n    this._shaderSets.at(5).uniformBaseColorLocation =\n      this.gl.getUniformLocation(\n        this._shaderSets.at(5).shaderProgram,\n        'u_baseColor'\n      );\n    this._shaderSets.at(5).uniformMultiplyColorLocation =\n      this.gl.getUniformLocation(\n        this._shaderSets.at(5).shaderProgram,\n        'u_multiplyColor'\n      );\n    this._shaderSets.at(5).uniformScreenColorLocation =\n      this.gl.getUniformLocation(\n        this._shaderSets.at(5).shaderProgram,\n        'u_screenColor'\n      );\n\n    // 加算（クリッピング・反転、PremultipliedAlpha）\n    this._shaderSets.at(6).attributePositionLocation =\n      this.gl.getAttribLocation(\n        this._shaderSets.at(6).shaderProgram,\n        'a_position'\n      );\n    this._shaderSets.at(6).attributeTexCoordLocation =\n      this.gl.getAttribLocation(\n        this._shaderSets.at(6).shaderProgram,\n        'a_texCoord'\n      );\n    this._shaderSets.at(6).samplerTexture0Location = this.gl.getUniformLocation(\n      this._shaderSets.at(6).shaderProgram,\n      's_texture0'\n    );\n    this._shaderSets.at(6).samplerTexture1Location = this.gl.getUniformLocation(\n      this._shaderSets.at(6).shaderProgram,\n      's_texture1'\n    );\n    this._shaderSets.at(6).uniformMatrixLocation = this.gl.getUniformLocation(\n      this._shaderSets.at(6).shaderProgram,\n      'u_matrix'\n    );\n    this._shaderSets.at(6).uniformClipMatrixLocation =\n      this.gl.getUniformLocation(\n        this._shaderSets.at(6).shaderProgram,\n        'u_clipMatrix'\n      );\n    this._shaderSets.at(6).uniformChannelFlagLocation =\n      this.gl.getUniformLocation(\n        this._shaderSets.at(6).shaderProgram,\n        'u_channelFlag'\n      );\n    this._shaderSets.at(6).uniformBaseColorLocation =\n      this.gl.getUniformLocation(\n        this._shaderSets.at(6).shaderProgram,\n        'u_baseColor'\n      );\n    this._shaderSets.at(6).uniformMultiplyColorLocation =\n      this.gl.getUniformLocation(\n        this._shaderSets.at(6).shaderProgram,\n        'u_multiplyColor'\n      );\n    this._shaderSets.at(6).uniformScreenColorLocation =\n      this.gl.getUniformLocation(\n        this._shaderSets.at(6).shaderProgram,\n        'u_screenColor'\n      );\n\n    // 乗算（PremultipliedAlpha）\n    this._shaderSets.at(7).attributePositionLocation =\n      this.gl.getAttribLocation(\n        this._shaderSets.at(7).shaderProgram,\n        'a_position'\n      );\n    this._shaderSets.at(7).attributeTexCoordLocation =\n      this.gl.getAttribLocation(\n        this._shaderSets.at(7).shaderProgram,\n        'a_texCoord'\n      );\n    this._shaderSets.at(7).samplerTexture0Location = this.gl.getUniformLocation(\n      this._shaderSets.at(7).shaderProgram,\n      's_texture0'\n    );\n    this._shaderSets.at(7).uniformMatrixLocation = this.gl.getUniformLocation(\n      this._shaderSets.at(7).shaderProgram,\n      'u_matrix'\n    );\n    this._shaderSets.at(7).uniformBaseColorLocation =\n      this.gl.getUniformLocation(\n        this._shaderSets.at(7).shaderProgram,\n        'u_baseColor'\n      );\n    this._shaderSets.at(7).uniformMultiplyColorLocation =\n      this.gl.getUniformLocation(\n        this._shaderSets.at(7).shaderProgram,\n        'u_multiplyColor'\n      );\n    this._shaderSets.at(7).uniformScreenColorLocation =\n      this.gl.getUniformLocation(\n        this._shaderSets.at(7).shaderProgram,\n        'u_screenColor'\n      );\n\n    // 乗算（クリッピング、PremultipliedAlpha）\n    this._shaderSets.at(8).attributePositionLocation =\n      this.gl.getAttribLocation(\n        this._shaderSets.at(8).shaderProgram,\n        'a_position'\n      );\n    this._shaderSets.at(8).attributeTexCoordLocation =\n      this.gl.getAttribLocation(\n        this._shaderSets.at(8).shaderProgram,\n        'a_texCoord'\n      );\n    this._shaderSets.at(8).samplerTexture0Location = this.gl.getUniformLocation(\n      this._shaderSets.at(8).shaderProgram,\n      's_texture0'\n    );\n    this._shaderSets.at(8).samplerTexture1Location = this.gl.getUniformLocation(\n      this._shaderSets.at(8).shaderProgram,\n      's_texture1'\n    );\n    this._shaderSets.at(8).uniformMatrixLocation = this.gl.getUniformLocation(\n      this._shaderSets.at(8).shaderProgram,\n      'u_matrix'\n    );\n    this._shaderSets.at(8).uniformClipMatrixLocation =\n      this.gl.getUniformLocation(\n        this._shaderSets.at(8).shaderProgram,\n        'u_clipMatrix'\n      );\n    this._shaderSets.at(8).uniformChannelFlagLocation =\n      this.gl.getUniformLocation(\n        this._shaderSets.at(8).shaderProgram,\n        'u_channelFlag'\n      );\n    this._shaderSets.at(8).uniformBaseColorLocation =\n      this.gl.getUniformLocation(\n        this._shaderSets.at(8).shaderProgram,\n        'u_baseColor'\n      );\n    this._shaderSets.at(8).uniformMultiplyColorLocation =\n      this.gl.getUniformLocation(\n        this._shaderSets.at(8).shaderProgram,\n        'u_multiplyColor'\n      );\n    this._shaderSets.at(8).uniformScreenColorLocation =\n      this.gl.getUniformLocation(\n        this._shaderSets.at(8).shaderProgram,\n        'u_screenColor'\n      );\n\n    // 乗算（クリッピング・反転、PremultipliedAlpha）\n    this._shaderSets.at(9).attributePositionLocation =\n      this.gl.getAttribLocation(\n        this._shaderSets.at(9).shaderProgram,\n        'a_position'\n      );\n    this._shaderSets.at(9).attributeTexCoordLocation =\n      this.gl.getAttribLocation(\n        this._shaderSets.at(9).shaderProgram,\n        'a_texCoord'\n      );\n    this._shaderSets.at(9).samplerTexture0Location = this.gl.getUniformLocation(\n      this._shaderSets.at(9).shaderProgram,\n      's_texture0'\n    );\n    this._shaderSets.at(9).samplerTexture1Location = this.gl.getUniformLocation(\n      this._shaderSets.at(9).shaderProgram,\n      's_texture1'\n    );\n    this._shaderSets.at(9).uniformMatrixLocation = this.gl.getUniformLocation(\n      this._shaderSets.at(9).shaderProgram,\n      'u_matrix'\n    );\n    this._shaderSets.at(9).uniformClipMatrixLocation =\n      this.gl.getUniformLocation(\n        this._shaderSets.at(9).shaderProgram,\n        'u_clipMatrix'\n      );\n    this._shaderSets.at(9).uniformChannelFlagLocation =\n      this.gl.getUniformLocation(\n        this._shaderSets.at(9).shaderProgram,\n        'u_channelFlag'\n      );\n    this._shaderSets.at(9).uniformBaseColorLocation =\n      this.gl.getUniformLocation(\n        this._shaderSets.at(9).shaderProgram,\n        'u_baseColor'\n      );\n    this._shaderSets.at(9).uniformMultiplyColorLocation =\n      this.gl.getUniformLocation(\n        this._shaderSets.at(9).shaderProgram,\n        'u_multiplyColor'\n      );\n    this._shaderSets.at(9).uniformScreenColorLocation =\n      this.gl.getUniformLocation(\n        this._shaderSets.at(9).shaderProgram,\n        'u_screenColor'\n      );\n  }\n\n  /**\n   * シェーダプログラムをロードしてアドレスを返す\n   * @param vertexShaderSource    頂点シェーダのソース\n   * @param fragmentShaderSource  フラグメントシェーダのソース\n   * @return シェーダプログラムのアドレス\n   */\n  public loadShaderProgram(\n    vertexShaderSource: string,\n    fragmentShaderSource: string\n  ): WebGLProgram {\n    // Create Shader Program\n    let shaderProgram: WebGLProgram = this.gl.createProgram();\n\n    let vertShader = this.compileShaderSource(\n      this.gl.VERTEX_SHADER,\n      vertexShaderSource\n    );\n\n    if (!vertShader) {\n      CubismLogError('Vertex shader compile error!');\n      return 0;\n    }\n\n    let fragShader = this.compileShaderSource(\n      this.gl.FRAGMENT_SHADER,\n      fragmentShaderSource\n    );\n    if (!fragShader) {\n      CubismLogError('Vertex shader compile error!');\n      return 0;\n    }\n\n    // Attach vertex shader to program\n    this.gl.attachShader(shaderProgram, vertShader);\n\n    // Attach fragment shader to program\n    this.gl.attachShader(shaderProgram, fragShader);\n\n    // link program\n    this.gl.linkProgram(shaderProgram);\n    const linkStatus = this.gl.getProgramParameter(\n      shaderProgram,\n      this.gl.LINK_STATUS\n    );\n\n    // リンクに失敗したらシェーダーを削除\n    if (!linkStatus) {\n      CubismLogError('Failed to link program: {0}', shaderProgram);\n\n      this.gl.deleteShader(vertShader);\n      vertShader = 0;\n\n      this.gl.deleteShader(fragShader);\n      fragShader = 0;\n\n      if (shaderProgram) {\n        this.gl.deleteProgram(shaderProgram);\n        shaderProgram = 0;\n      }\n\n      return 0;\n    }\n\n    // Release vertex and fragment shaders.\n    this.gl.deleteShader(vertShader);\n    this.gl.deleteShader(fragShader);\n\n    return shaderProgram;\n  }\n\n  /**\n   * シェーダープログラムをコンパイルする\n   * @param shaderType シェーダタイプ(Vertex/Fragment)\n   * @param shaderSource シェーダソースコード\n   *\n   * @return コンパイルされたシェーダープログラム\n   */\n  public compileShaderSource(\n    shaderType: GLenum,\n    shaderSource: string\n  ): WebGLProgram {\n    const source: string = shaderSource;\n\n    const shader: WebGLProgram = this.gl.createShader(shaderType);\n    this.gl.shaderSource(shader, source);\n    this.gl.compileShader(shader);\n\n    if (!shader) {\n      const log: string = this.gl.getShaderInfoLog(shader);\n      CubismLogError('Shader compile log: {0} ', log);\n    }\n\n    const status: any = this.gl.getShaderParameter(\n      shader,\n      this.gl.COMPILE_STATUS\n    );\n    if (!status) {\n      this.gl.deleteShader(shader);\n      return null;\n    }\n\n    return shader;\n  }\n\n  public setGl(gl: WebGLRenderingContext): void {\n    this.gl = gl;\n  }\n\n  _shaderSets: csmVector<CubismShaderSet>; // ロードしたシェーダープログラムを保持する変数\n  gl: WebGLRenderingContext; // webglコンテキスト\n}\n\n/**\n * CubismShader_WebGLのインナークラス\n */\nexport class CubismShaderSet {\n  shaderProgram: WebGLProgram; // シェーダープログラムのアドレス\n  attributePositionLocation: GLuint; // シェーダープログラムに渡す変数のアドレス（Position）\n  attributeTexCoordLocation: GLuint; // シェーダープログラムに渡す変数のアドレス（TexCoord）\n  uniformMatrixLocation: WebGLUniformLocation; // シェーダープログラムに渡す変数のアドレス（Matrix）\n  uniformClipMatrixLocation: WebGLUniformLocation; // シェーダープログラムに渡す変数のアドレス（ClipMatrix）\n  samplerTexture0Location: WebGLUniformLocation; // シェーダープログラムに渡す変数のアドレス（Texture0）\n  samplerTexture1Location: WebGLUniformLocation; // シェーダープログラムに渡す変数のアドレス（Texture1）\n  uniformBaseColorLocation: WebGLUniformLocation; // シェーダープログラムに渡す変数のアドレス（BaseColor）\n  uniformChannelFlagLocation: WebGLUniformLocation; // シェーダープログラムに渡す変数のアドレス（ChannelFlag）\n  uniformMultiplyColorLocation: WebGLUniformLocation; // シェーダープログラムに渡す変数のアドレス（MultiplyColor）\n  uniformScreenColorLocation: WebGLUniformLocation; // シェーダープログラムに渡す変数のアドレス（ScreenColor）\n}\n\nexport enum ShaderNames {\n  // SetupMask\n  ShaderNames_SetupMask,\n\n  // Normal\n  ShaderNames_NormalPremultipliedAlpha,\n  ShaderNames_NormalMaskedPremultipliedAlpha,\n  ShaderNames_NomralMaskedInvertedPremultipliedAlpha,\n\n  // Add\n  ShaderNames_AddPremultipliedAlpha,\n  ShaderNames_AddMaskedPremultipliedAlpha,\n  ShaderNames_AddMaskedPremultipliedAlphaInverted,\n\n  // Mult\n  ShaderNames_MultPremultipliedAlpha,\n  ShaderNames_MultMaskedPremultipliedAlpha,\n  ShaderNames_MultMaskedPremultipliedAlphaInverted,\n}\n\nexport const vertexShaderSrcSetupMask =\n  'attribute vec4     a_position;' +\n  'attribute vec2     a_texCoord;' +\n  'varying vec2       v_texCoord;' +\n  'varying vec4       v_myPos;' +\n  'uniform mat4       u_clipMatrix;' +\n  'void main()' +\n  '{' +\n  '   gl_Position = u_clipMatrix * a_position;' +\n  '   v_myPos = u_clipMatrix * a_position;' +\n  '   v_texCoord = a_texCoord;' +\n  '   v_texCoord.y = 1.0 - v_texCoord.y;' +\n  '}';\nexport const fragmentShaderSrcsetupMask =\n  'precision mediump float;' +\n  'varying vec2       v_texCoord;' +\n  'varying vec4       v_myPos;' +\n  'uniform vec4       u_baseColor;' +\n  'uniform vec4       u_channelFlag;' +\n  'uniform sampler2D  s_texture0;' +\n  'void main()' +\n  '{' +\n  '   float isInside = ' +\n  '       step(u_baseColor.x, v_myPos.x/v_myPos.w)' +\n  '       * step(u_baseColor.y, v_myPos.y/v_myPos.w)' +\n  '       * step(v_myPos.x/v_myPos.w, u_baseColor.z)' +\n  '       * step(v_myPos.y/v_myPos.w, u_baseColor.w);' +\n  '   gl_FragColor = u_channelFlag * texture2D(s_texture0, v_texCoord).a * isInside;' +\n  '}';\n\n//----- バーテックスシェーダプログラム -----\n// Normal & Add & Mult 共通\nexport const vertexShaderSrc =\n  'attribute vec4     a_position;' + //v.vertex\n  'attribute vec2     a_texCoord;' + //v.texcoord\n  'varying vec2       v_texCoord;' + //v2f.texcoord\n  'uniform mat4       u_matrix;' +\n  'void main()' +\n  '{' +\n  '   gl_Position = u_matrix * a_position;' +\n  '   v_texCoord = a_texCoord;' +\n  '   v_texCoord.y = 1.0 - v_texCoord.y;' +\n  '}';\n\n// Normal & Add & Mult 共通（クリッピングされたものの描画用）\nexport const vertexShaderSrcMasked =\n  'attribute vec4     a_position;' +\n  'attribute vec2     a_texCoord;' +\n  'varying vec2       v_texCoord;' +\n  'varying vec4       v_clipPos;' +\n  'uniform mat4       u_matrix;' +\n  'uniform mat4       u_clipMatrix;' +\n  'void main()' +\n  '{' +\n  '   gl_Position = u_matrix * a_position;' +\n  '   v_clipPos = u_clipMatrix * a_position;' +\n  '   v_texCoord = a_texCoord;' +\n  '   v_texCoord.y = 1.0 - v_texCoord.y;' +\n  '}';\n\n//----- フラグメントシェーダプログラム -----\n// Normal & Add & Mult 共通 （PremultipliedAlpha）\nexport const fragmentShaderSrcPremultipliedAlpha =\n  'precision mediump float;' +\n  'varying vec2       v_texCoord;' + //v2f.texcoord\n  'uniform vec4       u_baseColor;' +\n  'uniform sampler2D  s_texture0;' + //_MainTex\n  'uniform vec4       u_multiplyColor;' +\n  'uniform vec4       u_screenColor;' +\n  'void main()' +\n  '{' +\n  '   vec4 texColor = texture2D(s_texture0, v_texCoord);' +\n  '   texColor.rgb = texColor.rgb * u_multiplyColor.rgb;' +\n  '   texColor.rgb = (texColor.rgb + u_screenColor.rgb * texColor.a) - (texColor.rgb * u_screenColor.rgb);' +\n  '   vec4 color = texColor * u_baseColor;' +\n  '   gl_FragColor = vec4(color.rgb, color.a);' +\n  '}';\n\n// Normal （クリッピングされたものの描画用、PremultipliedAlpha兼用）\nexport const fragmentShaderSrcMaskPremultipliedAlpha =\n  'precision mediump float;' +\n  'varying vec2       v_texCoord;' +\n  'varying vec4       v_clipPos;' +\n  'uniform vec4       u_baseColor;' +\n  'uniform vec4       u_channelFlag;' +\n  'uniform sampler2D  s_texture0;' +\n  'uniform sampler2D  s_texture1;' +\n  'uniform vec4       u_multiplyColor;' +\n  'uniform vec4       u_screenColor;' +\n  'void main()' +\n  '{' +\n  '   vec4 texColor = texture2D(s_texture0, v_texCoord);' +\n  '   texColor.rgb = texColor.rgb * u_multiplyColor.rgb;' +\n  '   texColor.rgb = (texColor.rgb + u_screenColor.rgb * texColor.a) - (texColor.rgb * u_screenColor.rgb);' +\n  '   vec4 col_formask = texColor * u_baseColor;' +\n  '   vec4 clipMask = (1.0 - texture2D(s_texture1, v_clipPos.xy / v_clipPos.w)) * u_channelFlag;' +\n  '   float maskVal = clipMask.r + clipMask.g + clipMask.b + clipMask.a;' +\n  '   col_formask = col_formask * maskVal;' +\n  '   gl_FragColor = col_formask;' +\n  '}';\n\n// Normal & Add & Mult 共通（クリッピングされて反転使用の描画用、PremultipliedAlphaの場合）\nexport const fragmentShaderSrcMaskInvertedPremultipliedAlpha =\n  'precision mediump float;' +\n  'varying vec2      v_texCoord;' +\n  'varying vec4      v_clipPos;' +\n  'uniform sampler2D s_texture0;' +\n  'uniform sampler2D s_texture1;' +\n  'uniform vec4      u_channelFlag;' +\n  'uniform vec4      u_baseColor;' +\n  'uniform vec4      u_multiplyColor;' +\n  'uniform vec4      u_screenColor;' +\n  'void main()' +\n  '{' +\n  '   vec4 texColor = texture2D(s_texture0, v_texCoord);' +\n  '   texColor.rgb = texColor.rgb * u_multiplyColor.rgb;' +\n  '   texColor.rgb = (texColor.rgb + u_screenColor.rgb * texColor.a) - (texColor.rgb * u_screenColor.rgb);' +\n  '   vec4 col_formask = texColor * u_baseColor;' +\n  '   vec4 clipMask = (1.0 - texture2D(s_texture1, v_clipPos.xy / v_clipPos.w)) * u_channelFlag;' +\n  '   float maskVal = clipMask.r + clipMask.g + clipMask.b + clipMask.a;' +\n  '   col_formask = col_formask * (1.0 - maskVal);' +\n  '   gl_FragColor = col_formask;' +\n  '}';\n\n/**\n * WebGL用の描画命令を実装したクラス\n */\nexport class CubismRenderer_WebGL extends CubismRenderer {\n  /**\n   * レンダラの初期化処理を実行する\n   * 引数に渡したモデルからレンダラの初期化処理に必要な情報を取り出すことができる\n   *\n   * @param model モデルのインスタンス\n   * @param maskBufferCount バッファの生成数\n   */\n  public initialize(model: CubismModel, maskBufferCount = 1): void {\n    if (model.isUsingMasking()) {\n      this._clippingManager = new CubismClippingManager_WebGL(); // クリッピングマスク・バッファ前処理方式を初期化\n      this._clippingManager.initialize(\n        model,\n        model.getDrawableCount(),\n        model.getDrawableMasks(),\n        model.getDrawableMaskCounts(),\n        maskBufferCount\n      );\n    }\n\n    this._sortedDrawableIndexList.resize(model.getDrawableCount(), 0);\n\n    super.initialize(model); // 親クラスの処理を呼ぶ\n  }\n\n  /**\n   * WebGLテクスチャのバインド処理\n   * CubismRendererにテクスチャを設定し、CubismRenderer内でその画像を参照するためのIndex値を戻り値とする\n   * @param modelTextureNo セットするモデルテクスチャの番号\n   * @param glTextureNo WebGLテクスチャの番号\n   */\n  public bindTexture(modelTextureNo: number, glTexture: WebGLTexture): void {\n    this._textures.setValue(modelTextureNo, glTexture);\n  }\n\n  /**\n   * WebGLにバインドされたテクスチャのリストを取得する\n   * @return テクスチャのリスト\n   */\n  public getBindedTextures(): csmMap<number, WebGLTexture> {\n    return this._textures;\n  }\n\n  /**\n   * クリッピングマスクバッファのサイズを設定する\n   * マスク用のFrameBufferを破棄、再作成する為処理コストは高い\n   * @param size クリッピングマスクバッファのサイズ\n   */\n  public setClippingMaskBufferSize(size: number) {\n    // クリッピングマスクを利用しない場合は早期リターン\n    if (!this._model.isUsingMasking()) {\n      return;\n    }\n\n    // インスタンス破棄前にレンダーテクスチャの数を保存\n    const renderTextureCount: number =\n      this._clippingManager.getRenderTextureCount();\n\n    // FrameBufferのサイズを変更するためにインスタンスを破棄・再作成する\n    this._clippingManager.release();\n    this._clippingManager = void 0;\n    this._clippingManager = null;\n\n    this._clippingManager = new CubismClippingManager_WebGL();\n\n    this._clippingManager.setClippingMaskBufferSize(size);\n\n    this._clippingManager.initialize(\n      this.getModel(),\n      this.getModel().getDrawableCount(),\n      this.getModel().getDrawableMasks(),\n      this.getModel().getDrawableMaskCounts(),\n      renderTextureCount // インスタンス破棄前に保存したレンダーテクスチャの数\n    );\n  }\n\n  /**\n   * クリッピングマスクバッファのサイズを取得する\n   * @return クリッピングマスクバッファのサイズ\n   */\n  public getClippingMaskBufferSize(): number {\n    return this._model.isUsingMasking()\n      ? this._clippingManager.getClippingMaskBufferSize()\n      : -1;\n  }\n\n  /**\n   * レンダーテクスチャの枚数を取得する\n   * @return レンダーテクスチャの枚数\n   */\n  public getRenderTextureCount(): number {\n    return this._model.isUsingMasking()\n      ? this._clippingManager.getRenderTextureCount()\n      : -1;\n  }\n\n  /**\n   * コンストラクタ\n   */\n  public constructor() {\n    super();\n    this._clippingContextBufferForMask = null;\n    this._clippingContextBufferForDraw = null;\n    this._rendererProfile = new CubismRendererProfile_WebGL();\n    this.firstDraw = true;\n    this._textures = new csmMap<number, number>();\n    this._sortedDrawableIndexList = new csmVector<number>();\n    this._bufferData = {\n      vertex: (WebGLBuffer = null),\n      uv: (WebGLBuffer = null),\n      index: (WebGLBuffer = null),\n    };\n\n    // テクスチャ対応マップの容量を確保しておく\n    this._textures.prepareCapacity(32, true);\n  }\n\n  /**\n   * デストラクタ相当の処理\n   */\n  public release(): void {\n    if (this._clippingManager) {\n      this._clippingManager.release();\n      this._clippingManager = void 0;\n      this._clippingManager = null;\n    }\n\n    if (this.gl == null) {\n      return;\n    }\n    this.gl.deleteBuffer(this._bufferData.vertex);\n    this._bufferData.vertex = null;\n    this.gl.deleteBuffer(this._bufferData.uv);\n    this._bufferData.uv = null;\n    this.gl.deleteBuffer(this._bufferData.index);\n    this._bufferData.index = null;\n    this._bufferData = null;\n\n    this._textures = null;\n  }\n\n  /**\n   * モデルを描画する実際の処理\n   */\n  public doDrawModel(): void {\n    if (this.gl == null) {\n      CubismLogError(\n        \"'gl' is null. WebGLRenderingContext is required.\\nPlease call 'CubimRenderer_WebGL.startUp' function.\"\n      );\n      return;\n    }\n\n    //------------ クリッピングマスク・バッファ前処理方式の場合 ------------\n    if (this._clippingManager != null) {\n      this.preDraw();\n      this._clippingManager.setupClippingContext(this.getModel(), this);\n    }\n\n    // 上記クリッピング処理内でも一度PreDrawを呼ぶので注意!!\n    this.preDraw();\n\n    const drawableCount: number = this.getModel().getDrawableCount();\n    const renderOrder: Int32Array = this.getModel().getDrawableRenderOrders();\n\n    // インデックスを描画順でソート\n    for (let i = 0; i < drawableCount; ++i) {\n      const order: number = renderOrder[i];\n      this._sortedDrawableIndexList.set(order, i);\n    }\n\n    // 描画\n    for (let i = 0; i < drawableCount; ++i) {\n      const drawableIndex: number = this._sortedDrawableIndexList.at(i);\n\n      // Drawableが表示状態でなければ処理をパスする\n      if (!this.getModel().getDrawableDynamicFlagIsVisible(drawableIndex)) {\n        continue;\n      }\n\n      const clipContext =\n        this._clippingManager != null\n          ? this._clippingManager\n              .getClippingContextListForDraw()\n              .at(drawableIndex)\n          : null;\n\n      if (clipContext != null && this.isUsingHighPrecisionMask()) {\n        // 描くことになっていた\n        if (clipContext._isUsing) {\n          // 生成したFrameBufferと同じサイズでビューポートを設定\n          this.gl.viewport(\n            0,\n            0,\n            this._clippingManager.getClippingMaskBufferSize(),\n            this._clippingManager.getClippingMaskBufferSize()\n          );\n\n          this.preDraw(); // バッファをクリアする\n\n          // ---------- マスク描画処理 ----------\n          // マスク用RenderTextureをactiveにセット\n          this.gl.bindFramebuffer(\n            this.gl.FRAMEBUFFER,\n            clipContext\n              .getClippingManager()\n              .getMaskRenderTexture()\n              .at(clipContext._bufferIndex)\n          );\n\n          // マスクをクリアする\n          // (仮仕様) 1が無効（描かれない）領域、0が有効（描かれる）領域。（シェーダーCd*Csで0に近い値をかけてマスクを作る。1をかけると何も起こらない）\n          this.gl.clearColor(1.0, 1.0, 1.0, 1.0);\n          this.gl.clear(this.gl.COLOR_BUFFER_BIT);\n        }\n\n        {\n          const clipDrawCount: number = clipContext._clippingIdCount;\n\n          for (let index = 0; index < clipDrawCount; index++) {\n            const clipDrawIndex: number = clipContext._clippingIdList[index];\n\n            // 頂点情報が更新されておらず、信頼性がない場合は描画をパスする\n            if (\n              !this._model.getDrawableDynamicFlagVertexPositionsDidChange(\n                clipDrawIndex\n              )\n            ) {\n              continue;\n            }\n\n            this.setIsCulling(\n              this._model.getDrawableCulling(clipDrawIndex) != false\n            );\n\n            // 今回専用の変換を適用して描く\n            // チャンネルも切り替える必要がある(A,R,G,B)\n            this.setClippingContextBufferForMask(clipContext);\n\n            this.drawMesh(\n              this.getModel().getDrawableTextureIndex(clipDrawIndex),\n              this.getModel().getDrawableVertexIndexCount(clipDrawIndex),\n              this.getModel().getDrawableVertexCount(clipDrawIndex),\n              this.getModel().getDrawableVertexIndices(clipDrawIndex),\n              this.getModel().getDrawableVertices(clipDrawIndex),\n              this.getModel().getDrawableVertexUvs(clipDrawIndex),\n              this.getModel().getMultiplyColor(clipDrawIndex),\n              this.getModel().getScreenColor(clipDrawIndex),\n              this.getModel().getDrawableOpacity(clipDrawIndex),\n              CubismBlendMode.CubismBlendMode_Normal, // クリッピングは通常描画を強制\n              false // マスク生成時はクリッピングの反転使用は全く関係がない\n            );\n          }\n        }\n\n        {\n          // --- 後処理 ---\n          this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, s_fbo); // 描画対象を戻す\n          this.setClippingContextBufferForMask(null);\n\n          this.gl.viewport(\n            s_viewport[0],\n            s_viewport[1],\n            s_viewport[2],\n            s_viewport[3]\n          );\n\n          this.preDraw(); // バッファをクリアする\n        }\n      }\n\n      // クリッピングマスクをセットする\n      this.setClippingContextBufferForDraw(clipContext);\n\n      this.setIsCulling(this.getModel().getDrawableCulling(drawableIndex));\n\n      this.drawMesh(\n        this.getModel().getDrawableTextureIndex(drawableIndex),\n        this.getModel().getDrawableVertexIndexCount(drawableIndex),\n        this.getModel().getDrawableVertexCount(drawableIndex),\n        this.getModel().getDrawableVertexIndices(drawableIndex),\n        this.getModel().getDrawableVertices(drawableIndex),\n        this.getModel().getDrawableVertexUvs(drawableIndex),\n        this.getModel().getMultiplyColor(drawableIndex),\n        this.getModel().getScreenColor(drawableIndex),\n        this.getModel().getDrawableOpacity(drawableIndex),\n        this.getModel().getDrawableBlendMode(drawableIndex),\n        this.getModel().getDrawableInvertedMaskBit(drawableIndex)\n      );\n    }\n  }\n\n  /**\n   * [オーバーライド]\n   * 描画オブジェクト（アートメッシュ）を描画する。\n   * ポリゴンメッシュとテクスチャ番号をセットで渡す。\n   * @param textureNo 描画するテクスチャ番号\n   * @param indexCount 描画オブジェクトのインデックス値\n   * @param vertexCount ポリゴンメッシュの頂点数\n   * @param indexArray ポリゴンメッシュのインデックス配列\n   * @param vertexArray ポリゴンメッシュの頂点配列\n   * @param uvArray uv配列\n   * @param opacity 不透明度\n   * @param colorBlendMode カラー合成タイプ\n   * @param invertedMask マスク使用時のマスクの反転使用\n   */\n  public drawMesh(\n    textureNo: number,\n    indexCount: number,\n    vertexCount: number,\n    indexArray: Uint16Array,\n    vertexArray: Float32Array,\n    uvArray: Float32Array,\n    multiplyColor: CubismTextureColor,\n    screenColor: CubismTextureColor,\n    opacity: number,\n    colorBlendMode: CubismBlendMode,\n    invertedMask: boolean\n  ): void {\n    // 裏面描画の有効・無効\n    if (this.isCulling()) {\n      this.gl.enable(this.gl.CULL_FACE);\n    } else {\n      this.gl.disable(this.gl.CULL_FACE);\n    }\n\n    this.gl.frontFace(this.gl.CCW); // Cubism SDK OpenGLはマスク・アートメッシュ共にCCWが表面\n\n    const modelColorRGBA: CubismTextureColor = this.getModelColor();\n\n    if (this.getClippingContextBufferForMask() == null) {\n      // マスク生成時以外\n      modelColorRGBA.A *= opacity;\n      if (this.isPremultipliedAlpha()) {\n        modelColorRGBA.R *= modelColorRGBA.A;\n        modelColorRGBA.G *= modelColorRGBA.A;\n        modelColorRGBA.B *= modelColorRGBA.A;\n      }\n    }\n\n    let drawtexture: WebGLTexture; // シェーダに渡すテクスチャ\n\n    // テクスチャマップからバインド済みテクスチャＩＤを取得\n    // バインドされていなければダミーのテクスチャIDをセットする\n    if (this._textures.getValue(textureNo) != null) {\n      drawtexture = this._textures.getValue(textureNo);\n    } else {\n      drawtexture = null;\n    }\n\n    CubismShader_WebGL.getInstance().setupShaderProgram(\n      this,\n      drawtexture,\n      vertexCount,\n      vertexArray,\n      indexArray,\n      uvArray,\n      this._bufferData,\n      opacity,\n      colorBlendMode,\n      modelColorRGBA,\n      multiplyColor,\n      screenColor,\n      this.isPremultipliedAlpha(),\n      this.getMvpMatrix(),\n      invertedMask\n    );\n\n    // ポリゴンメッシュを描画する\n    this.gl.drawElements(\n      this.gl.TRIANGLES,\n      indexCount,\n      this.gl.UNSIGNED_SHORT,\n      0\n    );\n\n    // 後処理\n    this.gl.useProgram(null);\n    this.setClippingContextBufferForDraw(null);\n    this.setClippingContextBufferForMask(null);\n  }\n\n  protected saveProfile(): void {\n    this._rendererProfile.save();\n  }\n\n  protected restoreProfile(): void {\n    this._rendererProfile.restore();\n  }\n\n  /**\n   * レンダラが保持する静的なリソースを解放する\n   * WebGLの静的なシェーダープログラムを解放する\n   */\n  public static doStaticRelease(): void {\n    CubismShader_WebGL.deleteInstance();\n  }\n\n  /**\n   * レンダーステートを設定する\n   * @param fbo アプリケーション側で指定しているフレームバッファ\n   * @param viewport ビューポート\n   */\n  public setRenderState(fbo: WebGLFramebuffer, viewport: number[]): void {\n    s_fbo = fbo;\n    s_viewport = viewport;\n  }\n\n  /**\n   * 描画開始時の追加処理\n   * モデルを描画する前にクリッピングマスクに必要な処理を実装している\n   */\n  public preDraw(): void {\n    if (this.firstDraw) {\n      this.firstDraw = false;\n    }\n\n    this.gl.disable(this.gl.SCISSOR_TEST);\n    this.gl.disable(this.gl.STENCIL_TEST);\n    this.gl.disable(this.gl.DEPTH_TEST);\n\n    // カリング（1.0beta3）\n    this.gl.frontFace(this.gl.CW);\n\n    this.gl.enable(this.gl.BLEND);\n    this.gl.colorMask(true, true, true, true);\n\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null); // 前にバッファがバインドされていたら破棄する必要がある\n    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);\n\n    // 異方性フィルタリングを適用する\n    if (this.getAnisotropy() > 0.0 && this._extension) {\n      for (let i = 0; i < this._textures.getSize(); ++i) {\n        this.gl.bindTexture(this.gl.TEXTURE_2D, this._textures.getValue(i));\n        this.gl.texParameterf(\n          this.gl.TEXTURE_2D,\n          this._extension.TEXTURE_MAX_ANISOTROPY_EXT,\n          this.getAnisotropy()\n        );\n      }\n    }\n  }\n\n  /**\n   * マスクテクスチャに描画するクリッピングコンテキストをセットする\n   */\n  public setClippingContextBufferForMask(clip: CubismClippingContext) {\n    this._clippingContextBufferForMask = clip;\n  }\n\n  /**\n   * マスクテクスチャに描画するクリッピングコンテキストを取得する\n   * @return マスクテクスチャに描画するクリッピングコンテキスト\n   */\n  public getClippingContextBufferForMask(): CubismClippingContext {\n    return this._clippingContextBufferForMask;\n  }\n\n  /**\n   * 画面上に描画するクリッピングコンテキストをセットする\n   */\n  public setClippingContextBufferForDraw(clip: CubismClippingContext): void {\n    this._clippingContextBufferForDraw = clip;\n  }\n\n  /**\n   * 画面上に描画するクリッピングコンテキストを取得する\n   * @return 画面上に描画するクリッピングコンテキスト\n   */\n  public getClippingContextBufferForDraw(): CubismClippingContext {\n    return this._clippingContextBufferForDraw;\n  }\n\n  /**\n   * glの設定\n   */\n  public startUp(gl: WebGLRenderingContext): void {\n    this.gl = gl;\n\n    if (this._clippingManager) {\n      this._clippingManager.setGL(gl);\n    }\n\n    CubismShader_WebGL.getInstance().setGl(gl);\n    this._rendererProfile.setGl(gl);\n\n    // 異方性フィルタリングが使用できるかチェック\n    this._extension =\n      this.gl.getExtension('EXT_texture_filter_anisotropic') ||\n      this.gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic') ||\n      this.gl.getExtension('MOZ_EXT_texture_filter_anisotropic');\n  }\n\n  _textures: csmMap<number, WebGLTexture>; // モデルが参照するテクスチャとレンダラでバインドしているテクスチャとのマップ\n  _sortedDrawableIndexList: csmVector<number>; // 描画オブジェクトのインデックスを描画順に並べたリスト\n  _clippingManager: CubismClippingManager_WebGL; // クリッピングマスク管理オブジェクト\n  _clippingContextBufferForMask: CubismClippingContext; // マスクテクスチャに描画するためのクリッピングコンテキスト\n  _clippingContextBufferForDraw: CubismClippingContext; // 画面上描画するためのクリッピングコンテキスト\n  _rendererProfile: CubismRendererProfile_WebGL;\n  firstDraw: boolean;\n  _bufferData: {\n    vertex: WebGLBuffer;\n    uv: WebGLBuffer;\n    index: WebGLBuffer;\n  }; // 頂点バッファデータ\n  _extension: any; // 拡張機能\n  gl: WebGLRenderingContext; // webglコンテキスト\n}\n\n/**\n * レンダラが保持する静的なリソースを開放する\n */\nCubismRenderer.staticRelease = (): void => {\n  CubismRenderer_WebGL.doStaticRelease();\n};\n\n// Namespace definition for compatibility.\nimport * as $ from './cubismrenderer_webgl';\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport namespace Live2DCubismFramework {\n  export const CubismClippingContext = $.CubismClippingContext;\n  export type CubismClippingContext = $.CubismClippingContext;\n  export const CubismClippingManager_WebGL = $.CubismClippingManager_WebGL;\n  export type CubismClippingManager_WebGL = $.CubismClippingManager_WebGL;\n  export const CubismRenderTextureResource = $.CubismRenderTextureResource;\n  export type CubismRenderTextureResource = $.CubismRenderTextureResource;\n  export const CubismRenderer_WebGL = $.CubismRenderer_WebGL;\n  export type CubismRenderer_WebGL = $.CubismRenderer_WebGL;\n  export const CubismShaderSet = $.CubismShaderSet;\n  export type CubismShaderSet = $.CubismShaderSet;\n  export const CubismShader_WebGL = $.CubismShader_WebGL;\n  export type CubismShader_WebGL = $.CubismShader_WebGL;\n  export const ShaderNames = $.ShaderNames;\n  export type ShaderNames = $.ShaderNames;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}