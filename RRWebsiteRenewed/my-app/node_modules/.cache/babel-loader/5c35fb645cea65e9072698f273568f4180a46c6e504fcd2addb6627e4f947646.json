{"ast":null,"code":"/**\r\n * Copyright(c) Live2D Inc. All rights reserved.\r\n *\r\n * Use of this source code is governed by the Live2D Open Software license\r\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\r\n */\n\nimport { Live2DCubismFramework as cubismvector2 } from './cubismvector2';\nvar CubismVector2 = cubismvector2.CubismVector2;\nexport let Live2DCubismFramework;\n(function (_Live2DCubismFramework) {\n  class CubismMath {\n    /**\r\n     * 第一引数の値を最小値と最大値の範囲に収めた値を返す\r\n     *\r\n     * @param value 収められる値\r\n     * @param min   範囲の最小値\r\n     * @param max   範囲の最大値\r\n     * @return 最小値と最大値の範囲に収めた値\r\n     */\n    static range(value, min, max) {\n      if (value < min) {\n        value = min;\n      } else if (value > max) {\n        value = max;\n      }\n      return value;\n    }\n\n    /**\r\n     * サイン関数の値を求める\r\n     *\r\n     * @param x 角度値（ラジアン）\r\n     * @return サイン関数sin(x)の値\r\n     */\n    static sin(x) {\n      return Math.sin(x);\n    }\n\n    /**\r\n     * コサイン関数の値を求める\r\n     *\r\n     * @param x 角度値(ラジアン)\r\n     * @return コサイン関数cos(x)の値\r\n     */\n    static cos(x) {\n      return Math.cos(x);\n    }\n\n    /**\r\n     * 値の絶対値を求める\r\n     *\r\n     * @param x 絶対値を求める値\r\n     * @return 値の絶対値\r\n     */\n    static abs(x) {\n      return Math.abs(x);\n    }\n\n    /**\r\n     * 平方根(ルート)を求める\r\n     * @param x -> 平方根を求める値\r\n     * @return 値の平方根\r\n     */\n    static sqrt(x) {\n      return Math.sqrt(x);\n    }\n\n    /**\r\n     * イージング処理されたサインを求める\r\n     * フェードイン・アウト時のイージングに利用できる\r\n     *\r\n     * @param value イージングを行う値\r\n     * @return イージング処理されたサイン値\r\n     */\n    static getEasingSine(value) {\n      if (value < 0.0) {\n        return 0.0;\n      } else if (value > 1.0) {\n        return 1.0;\n      }\n      return 0.5 - 0.5 * this.cos(value * Math.PI);\n    }\n\n    /**\r\n     * 大きい方の値を返す\r\n     *\r\n     * @param left 左辺の値\r\n     * @param right 右辺の値\r\n     * @return 大きい方の値\r\n     */\n    static max(left, right) {\n      return left > right ? left : right;\n    }\n\n    /**\r\n     * 小さい方の値を返す\r\n     *\r\n     * @param left  左辺の値\r\n     * @param right 右辺の値\r\n     * @return 小さい方の値\r\n     */\n    static min(left, right) {\n      return left > right ? right : left;\n    }\n\n    /**\r\n     * 角度値をラジアン値に変換する\r\n     *\r\n     * @param degrees   角度値\r\n     * @return 角度値から変換したラジアン値\r\n     */\n    static degreesToRadian(degrees) {\n      return degrees / 180.0 * Math.PI;\n    }\n\n    /**\r\n     * ラジアン値を角度値に変換する\r\n     *\r\n     * @param radian    ラジアン値\r\n     * @return ラジアン値から変換した角度値\r\n     */\n    static radianToDegrees(radian) {\n      return radian * 180.0 / Math.PI;\n    }\n\n    /**\r\n     * ２つのベクトルからラジアン値を求める\r\n     *\r\n     * @param from  始点ベクトル\r\n     * @param to    終点ベクトル\r\n     * @return ラジアン値から求めた方向ベクトル\r\n     */\n    static directionToRadian(from, to) {\n      const q1 = Math.atan2(to.y, to.x);\n      const q2 = Math.atan2(from.y, from.x);\n      let ret = q1 - q2;\n      while (ret < -Math.PI) {\n        ret += Math.PI * 2.0;\n      }\n      while (ret > Math.PI) {\n        ret -= Math.PI * 2.0;\n      }\n      return ret;\n    }\n\n    /**\r\n     * ２つのベクトルから角度値を求める\r\n     *\r\n     * @param from  始点ベクトル\r\n     * @param to    終点ベクトル\r\n     * @return 角度値から求めた方向ベクトル\r\n     */\n    static directionToDegrees(from, to) {\n      const radian = this.directionToRadian(from, to);\n      let degree = this.radianToDegrees(radian);\n      if (to.x - from.x > 0.0) {\n        degree = -degree;\n      }\n      return degree;\n    }\n\n    /**\r\n     * ラジアン値を方向ベクトルに変換する。\r\n     *\r\n     * @param totalAngle    ラジアン値\r\n     * @return ラジアン値から変換した方向ベクトル\r\n     */\n\n    static radianToDirection(totalAngle) {\n      const ret = new CubismVector2();\n      ret.x = this.sin(totalAngle);\n      ret.y = this.cos(totalAngle);\n      return ret;\n    }\n\n    /**\r\n     * コンストラクタ\r\n     */\n    constructor() {}\n  }\n  _Live2DCubismFramework.CubismMath = CubismMath;\n})(Live2DCubismFramework || (Live2DCubismFramework = {}));","map":{"version":3,"names":["Live2DCubismFramework","cubismvector2","CubismVector2","_Live2DCubismFramework","CubismMath","range","value","min","max","sin","x","Math","cos","abs","sqrt","getEasingSine","PI","left","right","degreesToRadian","degrees","radianToDegrees","radian","directionToRadian","from","to","q1","atan2","y","q2","ret","directionToDegrees","degree","radianToDirection","totalAngle","constructor"],"sources":["C:/Users/cleyc/OneDrive/Documents/RR/RRWebsiteRenewed/my-app/src/mylive2d/react-live2d/Samples/TypeScript/Demo/Framework/src/math/cubismmath.ts"],"sourcesContent":["/**\r\n * Copyright(c) Live2D Inc. All rights reserved.\r\n *\r\n * Use of this source code is governed by the Live2D Open Software license\r\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\r\n */\r\n\r\nimport { Live2DCubismFramework as cubismvector2 } from './cubismvector2';\r\nimport CubismVector2 = cubismvector2.CubismVector2;\r\n\r\nexport namespace Live2DCubismFramework {\r\n  /**\r\n   * 数値計算などに使用するユーティリティクラス\r\n   */\r\n  export class CubismMath {\r\n    /**\r\n     * 第一引数の値を最小値と最大値の範囲に収めた値を返す\r\n     *\r\n     * @param value 収められる値\r\n     * @param min   範囲の最小値\r\n     * @param max   範囲の最大値\r\n     * @return 最小値と最大値の範囲に収めた値\r\n     */\r\n    static range(value: number, min: number, max: number): number {\r\n      if (value < min) {\r\n        value = min;\r\n      } else if (value > max) {\r\n        value = max;\r\n      }\r\n\r\n      return value;\r\n    }\r\n\r\n    /**\r\n     * サイン関数の値を求める\r\n     *\r\n     * @param x 角度値（ラジアン）\r\n     * @return サイン関数sin(x)の値\r\n     */\r\n    static sin(x: number): number {\r\n      return Math.sin(x);\r\n    }\r\n\r\n    /**\r\n     * コサイン関数の値を求める\r\n     *\r\n     * @param x 角度値(ラジアン)\r\n     * @return コサイン関数cos(x)の値\r\n     */\r\n    static cos(x: number): number {\r\n      return Math.cos(x);\r\n    }\r\n\r\n    /**\r\n     * 値の絶対値を求める\r\n     *\r\n     * @param x 絶対値を求める値\r\n     * @return 値の絶対値\r\n     */\r\n    static abs(x: number): number {\r\n      return Math.abs(x);\r\n    }\r\n\r\n    /**\r\n     * 平方根(ルート)を求める\r\n     * @param x -> 平方根を求める値\r\n     * @return 値の平方根\r\n     */\r\n    static sqrt(x: number): number {\r\n      return Math.sqrt(x);\r\n    }\r\n\r\n    /**\r\n     * イージング処理されたサインを求める\r\n     * フェードイン・アウト時のイージングに利用できる\r\n     *\r\n     * @param value イージングを行う値\r\n     * @return イージング処理されたサイン値\r\n     */\r\n    static getEasingSine(value: number): number {\r\n      if (value < 0.0) {\r\n        return 0.0;\r\n      } else if (value > 1.0) {\r\n        return 1.0;\r\n      }\r\n\r\n      return 0.5 - 0.5 * this.cos(value * Math.PI);\r\n    }\r\n\r\n    /**\r\n     * 大きい方の値を返す\r\n     *\r\n     * @param left 左辺の値\r\n     * @param right 右辺の値\r\n     * @return 大きい方の値\r\n     */\r\n    static max(left: number, right: number): number {\r\n      return left > right ? left : right;\r\n    }\r\n\r\n    /**\r\n     * 小さい方の値を返す\r\n     *\r\n     * @param left  左辺の値\r\n     * @param right 右辺の値\r\n     * @return 小さい方の値\r\n     */\r\n    static min(left: number, right: number): number {\r\n      return left > right ? right : left;\r\n    }\r\n\r\n    /**\r\n     * 角度値をラジアン値に変換する\r\n     *\r\n     * @param degrees   角度値\r\n     * @return 角度値から変換したラジアン値\r\n     */\r\n    static degreesToRadian(degrees: number): number {\r\n      return (degrees / 180.0) * Math.PI;\r\n    }\r\n\r\n    /**\r\n     * ラジアン値を角度値に変換する\r\n     *\r\n     * @param radian    ラジアン値\r\n     * @return ラジアン値から変換した角度値\r\n     */\r\n    static radianToDegrees(radian: number): number {\r\n      return (radian * 180.0) / Math.PI;\r\n    }\r\n\r\n    /**\r\n     * ２つのベクトルからラジアン値を求める\r\n     *\r\n     * @param from  始点ベクトル\r\n     * @param to    終点ベクトル\r\n     * @return ラジアン値から求めた方向ベクトル\r\n     */\r\n    static directionToRadian(from: CubismVector2, to: CubismVector2): number {\r\n      const q1: number = Math.atan2(to.y, to.x);\r\n      const q2: number = Math.atan2(from.y, from.x);\r\n\r\n      let ret: number = q1 - q2;\r\n\r\n      while (ret < -Math.PI) {\r\n        ret += Math.PI * 2.0;\r\n      }\r\n\r\n      while (ret > Math.PI) {\r\n        ret -= Math.PI * 2.0;\r\n      }\r\n\r\n      return ret;\r\n    }\r\n\r\n    /**\r\n     * ２つのベクトルから角度値を求める\r\n     *\r\n     * @param from  始点ベクトル\r\n     * @param to    終点ベクトル\r\n     * @return 角度値から求めた方向ベクトル\r\n     */\r\n    static directionToDegrees(from: CubismVector2, to: CubismVector2): number {\r\n      const radian: number = this.directionToRadian(from, to);\r\n      let degree: number = this.radianToDegrees(radian);\r\n\r\n      if (to.x - from.x > 0.0) {\r\n        degree = -degree;\r\n      }\r\n\r\n      return degree;\r\n    }\r\n\r\n    /**\r\n     * ラジアン値を方向ベクトルに変換する。\r\n     *\r\n     * @param totalAngle    ラジアン値\r\n     * @return ラジアン値から変換した方向ベクトル\r\n     */\r\n\r\n    static radianToDirection(totalAngle: number): CubismVector2 {\r\n      const ret: CubismVector2 = new CubismVector2();\r\n\r\n      ret.x = this.sin(totalAngle);\r\n      ret.y = this.cos(totalAngle);\r\n\r\n      return ret;\r\n    }\r\n\r\n    /**\r\n     * コンストラクタ\r\n     */\r\n    private constructor() {}\r\n  }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}