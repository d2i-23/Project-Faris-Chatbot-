{"ast":null,"code":"/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\n\nimport { CubismMath } from '../math/cubismmath';\nimport { CubismVector2 } from '../math/cubismvector2';\nimport { csmVector } from '../type/csmvector';\nimport { CubismPhysicsInput, CubismPhysicsOutput, CubismPhysicsParticle, CubismPhysicsRig, CubismPhysicsSource, CubismPhysicsSubRig, CubismPhysicsTargetType } from './cubismphysicsinternal';\nimport { CubismPhysicsJson } from './cubismphysicsjson';\n\n// physics types tags.\nconst PhysicsTypeTagX = 'X';\nconst PhysicsTypeTagY = 'Y';\nconst PhysicsTypeTagAngle = 'Angle';\n\n// Constant of air resistance.\nconst AirResistance = 5.0;\n\n// Constant of maximum weight of input and output ratio.\nconst MaximumWeight = 100.0;\n\n// Constant of threshold of movement.\nconst MovementThreshold = 0.001;\n\n// Constant of maximum allowed delta time\nconst MaxDeltaTime = 5.0;\n\n/**\n * 物理演算クラス\n */\nexport class CubismPhysics {\n  /**\n   * インスタンスの作成\n   * @param buffer    physics3.jsonが読み込まれているバッファ\n   * @param size      バッファのサイズ\n   * @return 作成されたインスタンス\n   */\n  static create(buffer, size) {\n    const ret = new CubismPhysics();\n    ret.parse(buffer, size);\n    ret._physicsRig.gravity.y = 0;\n    return ret;\n  }\n\n  /**\n   * インスタンスを破棄する\n   * @param physics 破棄するインスタンス\n   */\n  static delete(physics) {\n    if (physics != null) {\n      physics.release();\n      physics = null;\n    }\n  }\n\n  /**\n   * physics3.jsonをパースする。\n   * @param physicsJson physics3.jsonが読み込まれているバッファ\n   * @param size バッファのサイズ\n   */\n  parse(physicsJson, size) {\n    this._physicsRig = new CubismPhysicsRig();\n    let json = new CubismPhysicsJson(physicsJson, size);\n    this._physicsRig.gravity = json.getGravity();\n    this._physicsRig.wind = json.getWind();\n    this._physicsRig.subRigCount = json.getSubRigCount();\n    this._physicsRig.fps = json.getFps();\n    this._physicsRig.settings.updateSize(this._physicsRig.subRigCount, CubismPhysicsSubRig, true);\n    this._physicsRig.inputs.updateSize(json.getTotalInputCount(), CubismPhysicsInput, true);\n    this._physicsRig.outputs.updateSize(json.getTotalOutputCount(), CubismPhysicsOutput, true);\n    this._physicsRig.particles.updateSize(json.getVertexCount(), CubismPhysicsParticle, true);\n    this._currentRigOutputs.clear();\n    this._previousRigOutputs.clear();\n    let inputIndex = 0,\n      outputIndex = 0,\n      particleIndex = 0;\n    for (let i = 0; i < this._physicsRig.settings.getSize(); ++i) {\n      this._physicsRig.settings.at(i).normalizationPosition.minimum = json.getNormalizationPositionMinimumValue(i);\n      this._physicsRig.settings.at(i).normalizationPosition.maximum = json.getNormalizationPositionMaximumValue(i);\n      this._physicsRig.settings.at(i).normalizationPosition.defalut = json.getNormalizationPositionDefaultValue(i);\n      this._physicsRig.settings.at(i).normalizationAngle.minimum = json.getNormalizationAngleMinimumValue(i);\n      this._physicsRig.settings.at(i).normalizationAngle.maximum = json.getNormalizationAngleMaximumValue(i);\n      this._physicsRig.settings.at(i).normalizationAngle.defalut = json.getNormalizationAngleDefaultValue(i);\n\n      // Input\n      this._physicsRig.settings.at(i).inputCount = json.getInputCount(i);\n      this._physicsRig.settings.at(i).baseInputIndex = inputIndex;\n      for (let j = 0; j < this._physicsRig.settings.at(i).inputCount; ++j) {\n        this._physicsRig.inputs.at(inputIndex + j).sourceParameterIndex = -1;\n        this._physicsRig.inputs.at(inputIndex + j).weight = json.getInputWeight(i, j);\n        this._physicsRig.inputs.at(inputIndex + j).reflect = json.getInputReflect(i, j);\n        if (json.getInputType(i, j) == PhysicsTypeTagX) {\n          this._physicsRig.inputs.at(inputIndex + j).type = CubismPhysicsSource.CubismPhysicsSource_X;\n          this._physicsRig.inputs.at(inputIndex + j).getNormalizedParameterValue = getInputTranslationXFromNormalizedParameterValue;\n        } else if (json.getInputType(i, j) == PhysicsTypeTagY) {\n          this._physicsRig.inputs.at(inputIndex + j).type = CubismPhysicsSource.CubismPhysicsSource_Y;\n          this._physicsRig.inputs.at(inputIndex + j).getNormalizedParameterValue = getInputTranslationYFromNormalizedParamterValue;\n        } else if (json.getInputType(i, j) == PhysicsTypeTagAngle) {\n          this._physicsRig.inputs.at(inputIndex + j).type = CubismPhysicsSource.CubismPhysicsSource_Angle;\n          this._physicsRig.inputs.at(inputIndex + j).getNormalizedParameterValue = getInputAngleFromNormalizedParameterValue;\n        }\n        this._physicsRig.inputs.at(inputIndex + j).source.targetType = CubismPhysicsTargetType.CubismPhysicsTargetType_Parameter;\n        this._physicsRig.inputs.at(inputIndex + j).source.id = json.getInputSourceId(i, j);\n      }\n      inputIndex += this._physicsRig.settings.at(i).inputCount;\n\n      // Output\n      this._physicsRig.settings.at(i).outputCount = json.getOutputCount(i);\n      this._physicsRig.settings.at(i).baseOutputIndex = outputIndex;\n      const currentRigOutput = new PhysicsOutput();\n      currentRigOutput.outputs.resize(this._physicsRig.settings.at(i).outputCount);\n      const previousRigOutput = new PhysicsOutput();\n      previousRigOutput.outputs.resize(this._physicsRig.settings.at(i).outputCount);\n      for (let j = 0; j < this._physicsRig.settings.at(i).outputCount; ++j) {\n        // initialize\n        currentRigOutput.outputs.set(j, 0.0);\n        previousRigOutput.outputs.set(j, 0.0);\n        this._physicsRig.outputs.at(outputIndex + j).destinationParameterIndex = -1;\n        this._physicsRig.outputs.at(outputIndex + j).vertexIndex = json.getOutputVertexIndex(i, j);\n        this._physicsRig.outputs.at(outputIndex + j).angleScale = json.getOutputAngleScale(i, j);\n        this._physicsRig.outputs.at(outputIndex + j).weight = json.getOutputWeight(i, j);\n        this._physicsRig.outputs.at(outputIndex + j).destination.targetType = CubismPhysicsTargetType.CubismPhysicsTargetType_Parameter;\n        this._physicsRig.outputs.at(outputIndex + j).destination.id = json.getOutputDestinationId(i, j);\n        if (json.getOutputType(i, j) == PhysicsTypeTagX) {\n          this._physicsRig.outputs.at(outputIndex + j).type = CubismPhysicsSource.CubismPhysicsSource_X;\n          this._physicsRig.outputs.at(outputIndex + j).getValue = getOutputTranslationX;\n          this._physicsRig.outputs.at(outputIndex + j).getScale = getOutputScaleTranslationX;\n        } else if (json.getOutputType(i, j) == PhysicsTypeTagY) {\n          this._physicsRig.outputs.at(outputIndex + j).type = CubismPhysicsSource.CubismPhysicsSource_Y;\n          this._physicsRig.outputs.at(outputIndex + j).getValue = getOutputTranslationY;\n          this._physicsRig.outputs.at(outputIndex + j).getScale = getOutputScaleTranslationY;\n        } else if (json.getOutputType(i, j) == PhysicsTypeTagAngle) {\n          this._physicsRig.outputs.at(outputIndex + j).type = CubismPhysicsSource.CubismPhysicsSource_Angle;\n          this._physicsRig.outputs.at(outputIndex + j).getValue = getOutputAngle;\n          this._physicsRig.outputs.at(outputIndex + j).getScale = getOutputScaleAngle;\n        }\n        this._physicsRig.outputs.at(outputIndex + j).reflect = json.getOutputReflect(i, j);\n      }\n      this._currentRigOutputs.pushBack(currentRigOutput);\n      this._previousRigOutputs.pushBack(previousRigOutput);\n      outputIndex += this._physicsRig.settings.at(i).outputCount;\n\n      // Particle\n      this._physicsRig.settings.at(i).particleCount = json.getParticleCount(i);\n      this._physicsRig.settings.at(i).baseParticleIndex = particleIndex;\n      for (let j = 0; j < this._physicsRig.settings.at(i).particleCount; ++j) {\n        this._physicsRig.particles.at(particleIndex + j).mobility = json.getParticleMobility(i, j);\n        this._physicsRig.particles.at(particleIndex + j).delay = json.getParticleDelay(i, j);\n        this._physicsRig.particles.at(particleIndex + j).acceleration = json.getParticleAcceleration(i, j);\n        this._physicsRig.particles.at(particleIndex + j).radius = json.getParticleRadius(i, j);\n        this._physicsRig.particles.at(particleIndex + j).position = json.getParticlePosition(i, j);\n      }\n      particleIndex += this._physicsRig.settings.at(i).particleCount;\n    }\n    this.initialize();\n    json.release();\n    json = void 0;\n    json = null;\n  }\n\n  /**\n   * 現在のパラメータ値で物理演算が安定化する状態を演算する。\n   * @param model 物理演算の結果を適用するモデル\n   */\n  stabilization(model) {\n    var _this$_parameterCache, _this$_parameterCache2, _this$_parameterInput, _this$_parameterInput2;\n    let totalAngle;\n    let weight;\n    let radAngle;\n    let outputValue;\n    const totalTranslation = new CubismVector2();\n    let currentSetting;\n    let currentInputs;\n    let currentOutputs;\n    let currentParticles;\n    let parameterValues;\n    let parameterMaximumValues;\n    let parameterMinimumValues;\n    let parameterDefaultValues;\n    parameterValues = model.getModel().parameters.values;\n    parameterMaximumValues = model.getModel().parameters.maximumValues;\n    parameterMinimumValues = model.getModel().parameters.minimumValues;\n    parameterDefaultValues = model.getModel().parameters.defaultValues;\n    if (((_this$_parameterCache = (_this$_parameterCache2 = this._parameterCaches) === null || _this$_parameterCache2 === void 0 ? void 0 : _this$_parameterCache2.length) !== null && _this$_parameterCache !== void 0 ? _this$_parameterCache : 0) < model.getParameterCount()) {\n      this._parameterCaches = new Float32Array(model.getParameterCount());\n    }\n    if (((_this$_parameterInput = (_this$_parameterInput2 = this._parameterInputCaches) === null || _this$_parameterInput2 === void 0 ? void 0 : _this$_parameterInput2.length) !== null && _this$_parameterInput !== void 0 ? _this$_parameterInput : 0) < model.getParameterCount()) {\n      this._parameterInputCaches = new Float32Array(model.getParameterCount());\n    }\n    for (let j = 0; j < model.getParameterCount(); ++j) {\n      this._parameterCaches[j] = parameterValues[j];\n      this._parameterInputCaches[j] = parameterValues[j];\n    }\n    for (let settingIndex = 0; settingIndex < this._physicsRig.subRigCount; ++settingIndex) {\n      totalAngle = {\n        angle: 0.0\n      };\n      totalTranslation.x = 0.0;\n      totalTranslation.y = 0.0;\n      currentSetting = this._physicsRig.settings.at(settingIndex);\n      currentInputs = this._physicsRig.inputs.get(currentSetting.baseInputIndex);\n      currentOutputs = this._physicsRig.outputs.get(currentSetting.baseOutputIndex);\n      currentParticles = this._physicsRig.particles.get(currentSetting.baseParticleIndex);\n\n      // Load input parameters\n      for (let i = 0; i < currentSetting.inputCount; ++i) {\n        weight = currentInputs[i].weight / MaximumWeight;\n        if (currentInputs[i].sourceParameterIndex == -1) {\n          currentInputs[i].sourceParameterIndex = model.getParameterIndex(currentInputs[i].source.id);\n        }\n        currentInputs[i].getNormalizedParameterValue(totalTranslation, totalAngle, parameterValues[currentInputs[i].sourceParameterIndex], parameterMinimumValues[currentInputs[i].sourceParameterIndex], parameterMaximumValues[currentInputs[i].sourceParameterIndex], parameterDefaultValues[currentInputs[i].sourceParameterIndex], currentSetting.normalizationPosition, currentSetting.normalizationAngle, currentInputs[i].reflect, weight);\n        this._parameterCaches[currentInputs[i].sourceParameterIndex] = parameterValues[currentInputs[i].sourceParameterIndex];\n      }\n      radAngle = CubismMath.degreesToRadian(-totalAngle.angle);\n      totalTranslation.x = totalTranslation.x * CubismMath.cos(radAngle) - totalTranslation.y * CubismMath.sin(radAngle);\n      totalTranslation.y = totalTranslation.x * CubismMath.sin(radAngle) + totalTranslation.y * CubismMath.cos(radAngle);\n\n      // Calculate particles position.\n      updateParticlesForStabilization(currentParticles, currentSetting.particleCount, totalTranslation, totalAngle.angle, this._options.wind, MovementThreshold * currentSetting.normalizationPosition.maximum);\n\n      // Update output parameters.\n      for (let i = 0; i < currentSetting.outputCount; ++i) {\n        const particleIndex = currentOutputs[i].vertexIndex;\n        if (currentOutputs[i].destinationParameterIndex == -1) {\n          currentOutputs[i].destinationParameterIndex = model.getParameterIndex(currentOutputs[i].destination.id);\n        }\n        if (particleIndex < 1 || particleIndex >= currentSetting.particleCount) {\n          continue;\n        }\n        let translation = new CubismVector2();\n        translation = currentParticles[particleIndex].position.substract(currentParticles[particleIndex - 1].position);\n        outputValue = currentOutputs[i].getValue(translation, currentParticles, particleIndex, currentOutputs[i].reflect, this._options.gravity);\n        this._currentRigOutputs.at(settingIndex).outputs.set(i, outputValue);\n        this._previousRigOutputs.at(settingIndex).outputs.set(i, outputValue);\n        const destinationParameterIndex = currentOutputs[i].destinationParameterIndex;\n        const outParameterCaches = !Float32Array.prototype.slice && 'subarray' in Float32Array.prototype ? JSON.parse(JSON.stringify(parameterValues.subarray(destinationParameterIndex))) // 値渡しするため、JSON.parse, JSON.stringify\n        : parameterValues.slice(destinationParameterIndex);\n        updateOutputParameterValue(outParameterCaches, parameterMinimumValues[destinationParameterIndex], parameterMaximumValues[destinationParameterIndex], outputValue, currentOutputs[i]);\n\n        // 値を反映\n        for (let offset = destinationParameterIndex, outParamIndex = 0; offset < this._parameterCaches.length; offset++, outParamIndex++) {\n          parameterValues[offset] = this._parameterCaches[offset] = outParameterCaches[outParamIndex];\n        }\n      }\n    }\n  }\n\n  /**\n   * 物理演算の評価\n   *\n   * Pendulum interpolation weights\n   *\n   * 振り子の計算結果は保存され、パラメータへの出力は保存された前回の結果で補間されます。\n   * The result of the pendulum calculation is saved and\n   * the output to the parameters is interpolated with the saved previous result of the pendulum calculation.\n   *\n   * 図で示すと[1]と[2]で補間されます。\n   * The figure shows the interpolation between [1] and [2].\n   *\n   * 補間の重みは最新の振り子計算タイミングと次回のタイミングの間で見た現在時間で決定する。\n   * The weight of the interpolation are determined by the current time seen between\n   * the latest pendulum calculation timing and the next timing.\n   *\n   * 図で示すと[2]と[4]の間でみた(3)の位置の重みになる。\n   * Figure shows the weight of position (3) as seen between [2] and [4].\n   *\n   * 解釈として振り子計算のタイミングと重み計算のタイミングがズレる。\n   * As an interpretation, the pendulum calculation and weights are misaligned.\n   *\n   * physics3.jsonにFPS情報が存在しない場合は常に前の振り子状態で設定される。\n   * If there is no FPS information in physics3.json, it is always set in the previous pendulum state.\n   *\n   * この仕様は補間範囲を逸脱したことが原因の震えたような見た目を回避を目的にしている。\n   * The purpose of this specification is to avoid the quivering appearance caused by deviations from the interpolation range.\n   *\n   * ------------ time -------------->\n   *\n   *                 |+++++|------| <- weight\n   * ==[1]====#=====[2]---(3)----(4)\n   *          ^ output contents\n   *\n   * 1:_previousRigOutputs\n   * 2:_currentRigOutputs\n   * 3:_currentRemainTime (now rendering)\n   * 4:next particles timing\n   * @param model 物理演算の結果を適用するモデル\n   * @param deltaTimeSeconds デルタ時間[秒]\n   */\n  evaluate(model, deltaTimeSeconds) {\n    var _this$_parameterCache3, _this$_parameterCache4, _this$_parameterInput3, _this$_parameterInput4;\n    let totalAngle;\n    let weight;\n    let radAngle;\n    let outputValue;\n    const totalTranslation = new CubismVector2();\n    let currentSetting;\n    let currentInputs;\n    let currentOutputs;\n    let currentParticles;\n    if (0.0 >= deltaTimeSeconds) {\n      return;\n    }\n    let parameterValues;\n    let parameterMaximumValues;\n    let parameterMinimumValues;\n    let parameterDefaultValues;\n    let physicsDeltaTime;\n    this._currentRemainTime += deltaTimeSeconds;\n    if (this._currentRemainTime > MaxDeltaTime) {\n      this._currentRemainTime = 0.0;\n    }\n    parameterValues = model.getModel().parameters.values;\n    parameterMaximumValues = model.getModel().parameters.maximumValues;\n    parameterMinimumValues = model.getModel().parameters.minimumValues;\n    parameterDefaultValues = model.getModel().parameters.defaultValues;\n    if (((_this$_parameterCache3 = (_this$_parameterCache4 = this._parameterCaches) === null || _this$_parameterCache4 === void 0 ? void 0 : _this$_parameterCache4.length) !== null && _this$_parameterCache3 !== void 0 ? _this$_parameterCache3 : 0) < model.getParameterCount()) {\n      this._parameterCaches = new Float32Array(model.getParameterCount());\n    }\n    if (((_this$_parameterInput3 = (_this$_parameterInput4 = this._parameterInputCaches) === null || _this$_parameterInput4 === void 0 ? void 0 : _this$_parameterInput4.length) !== null && _this$_parameterInput3 !== void 0 ? _this$_parameterInput3 : 0) < model.getParameterCount()) {\n      this._parameterInputCaches = new Float32Array(model.getParameterCount());\n      for (let j = 0; j < model.getParameterCount(); ++j) {\n        this._parameterInputCaches[j] = parameterValues[j];\n      }\n    }\n    if (this._physicsRig.fps > 0.0) {\n      physicsDeltaTime = 1.0 / this._physicsRig.fps;\n    } else {\n      physicsDeltaTime = deltaTimeSeconds;\n    }\n    while (this._currentRemainTime >= physicsDeltaTime) {\n      // copyRigOutputs _currentRigOutputs to _previousRigOutputs\n      for (let settingIndex = 0; settingIndex < this._physicsRig.subRigCount; ++settingIndex) {\n        currentSetting = this._physicsRig.settings.at(settingIndex);\n        currentOutputs = this._physicsRig.outputs.get(currentSetting.baseOutputIndex);\n        for (let i = 0; i < currentSetting.outputCount; ++i) {\n          this._previousRigOutputs.at(settingIndex).outputs.set(i, this._currentRigOutputs.at(settingIndex).outputs.at(i));\n        }\n      }\n\n      // 入力キャッシュとパラメータで線形補間してUpdateParticlesするタイミングでの入力を計算する。\n      // Calculate the input at the timing to UpdateParticles by linear interpolation with the _parameterInputCache and parameterValue.\n      // _parameterCacheはグループ間での値の伝搬の役割があるので_parameterInputCacheとの分離が必要。\n      // _parameterCache needs to be separated from _parameterInputCache because of its role in propagating values between groups.\n      const inputWeight = physicsDeltaTime / this._currentRemainTime;\n      for (let j = 0; j < model.getParameterCount(); ++j) {\n        this._parameterCaches[j] = this._parameterInputCaches[j] * (1.0 - inputWeight) + parameterValues[j] * inputWeight;\n        this._parameterInputCaches[j] = this._parameterCaches[j];\n      }\n      for (let settingIndex = 0; settingIndex < this._physicsRig.subRigCount; ++settingIndex) {\n        totalAngle = {\n          angle: 0.0\n        };\n        totalTranslation.x = 0.0;\n        totalTranslation.y = 0.0;\n        currentSetting = this._physicsRig.settings.at(settingIndex);\n        currentInputs = this._physicsRig.inputs.get(currentSetting.baseInputIndex);\n        currentOutputs = this._physicsRig.outputs.get(currentSetting.baseOutputIndex);\n        currentParticles = this._physicsRig.particles.get(currentSetting.baseParticleIndex);\n\n        // Load input parameters\n        for (let i = 0; i < currentSetting.inputCount; ++i) {\n          weight = currentInputs[i].weight / MaximumWeight;\n          if (currentInputs[i].sourceParameterIndex == -1) {\n            currentInputs[i].sourceParameterIndex = model.getParameterIndex(currentInputs[i].source.id);\n          }\n          currentInputs[i].getNormalizedParameterValue(totalTranslation, totalAngle, this._parameterCaches[currentInputs[i].sourceParameterIndex], parameterMinimumValues[currentInputs[i].sourceParameterIndex], parameterMaximumValues[currentInputs[i].sourceParameterIndex], parameterDefaultValues[currentInputs[i].sourceParameterIndex], currentSetting.normalizationPosition, currentSetting.normalizationAngle, currentInputs[i].reflect, weight);\n        }\n        radAngle = CubismMath.degreesToRadian(-totalAngle.angle);\n        totalTranslation.x = totalTranslation.x * CubismMath.cos(radAngle) - totalTranslation.y * CubismMath.sin(radAngle);\n        totalTranslation.y = totalTranslation.x * CubismMath.sin(radAngle) + totalTranslation.y * CubismMath.cos(radAngle);\n\n        // Calculate particles position.\n        updateParticles(currentParticles, currentSetting.particleCount, totalTranslation, totalAngle.angle, this._options.wind, MovementThreshold * currentSetting.normalizationPosition.maximum, physicsDeltaTime, AirResistance);\n\n        // Update output parameters.\n        for (let i = 0; i < currentSetting.outputCount; ++i) {\n          const particleIndex = currentOutputs[i].vertexIndex;\n          if (currentOutputs[i].destinationParameterIndex == -1) {\n            currentOutputs[i].destinationParameterIndex = model.getParameterIndex(currentOutputs[i].destination.id);\n          }\n          if (particleIndex < 1 || particleIndex >= currentSetting.particleCount) {\n            continue;\n          }\n          const translation = new CubismVector2();\n          translation.x = currentParticles[particleIndex].position.x - currentParticles[particleIndex - 1].position.x;\n          translation.y = currentParticles[particleIndex].position.y - currentParticles[particleIndex - 1].position.y;\n          outputValue = currentOutputs[i].getValue(translation, currentParticles, particleIndex, currentOutputs[i].reflect, this._options.gravity);\n          this._currentRigOutputs.at(settingIndex).outputs.set(i, outputValue);\n          const destinationParameterIndex = currentOutputs[i].destinationParameterIndex;\n          const outParameterCaches = !Float32Array.prototype.slice && 'subarray' in Float32Array.prototype ? JSON.parse(JSON.stringify(this._parameterCaches.subarray(destinationParameterIndex))) // 値渡しするため、JSON.parse, JSON.stringify\n          : this._parameterCaches.slice(destinationParameterIndex);\n          updateOutputParameterValue(outParameterCaches, parameterMinimumValues[destinationParameterIndex], parameterMaximumValues[destinationParameterIndex], outputValue, currentOutputs[i]);\n\n          // 値を反映\n          for (let offset = destinationParameterIndex, outParamIndex = 0; offset < this._parameterCaches.length; offset++, outParamIndex++) {\n            this._parameterCaches[offset] = outParameterCaches[outParamIndex];\n          }\n        }\n      }\n      this._currentRemainTime -= physicsDeltaTime;\n    }\n    const alpha = this._currentRemainTime / physicsDeltaTime;\n    this.interpolate(model, alpha);\n  }\n\n  /**\n   * 物理演算結果の適用\n   * 振り子演算の最新の結果と一つ前の結果から指定した重みで適用する。\n   * @param model 物理演算の結果を適用するモデル\n   * @param weight 最新結果の重み\n   */\n  interpolate(model, weight) {\n    let currentOutputs;\n    let currentSetting;\n    let parameterValues;\n    let parameterMaximumValues;\n    let parameterMinimumValues;\n    parameterValues = model.getModel().parameters.values;\n    parameterMaximumValues = model.getModel().parameters.maximumValues;\n    parameterMinimumValues = model.getModel().parameters.minimumValues;\n    for (let settingIndex = 0; settingIndex < this._physicsRig.subRigCount; ++settingIndex) {\n      currentSetting = this._physicsRig.settings.at(settingIndex);\n      currentOutputs = this._physicsRig.outputs.get(currentSetting.baseOutputIndex);\n\n      // Load input parameters.\n      for (let i = 0; i < currentSetting.outputCount; ++i) {\n        if (currentOutputs[i].destinationParameterIndex == -1) {\n          continue;\n        }\n        const destinationParameterIndex = currentOutputs[i].destinationParameterIndex;\n        const outParameterValues = !Float32Array.prototype.slice && 'subarray' in Float32Array.prototype ? JSON.parse(JSON.stringify(parameterValues.subarray(destinationParameterIndex))) // 値渡しするため、JSON.parse, JSON.stringify\n        : parameterValues.slice(destinationParameterIndex);\n        updateOutputParameterValue(outParameterValues, parameterMinimumValues[destinationParameterIndex], parameterMaximumValues[destinationParameterIndex], this._previousRigOutputs.at(settingIndex).outputs.at(i) * (1 - weight) + this._currentRigOutputs.at(settingIndex).outputs.at(i) * weight, currentOutputs[i]);\n\n        // 値を反映\n        for (let offset = destinationParameterIndex, outParamIndex = 0; offset < parameterValues.length; offset++, outParamIndex++) {\n          parameterValues[offset] = outParameterValues[outParamIndex];\n        }\n      }\n    }\n  }\n\n  /**\n   * オプションの設定\n   * @param options オプション\n   */\n  setOptions(options) {\n    this._options = options;\n  }\n\n  /**\n   * オプションの取得\n   * @return オプション\n   */\n  getOption() {\n    return this._options;\n  }\n\n  /**\n   * コンストラクタ\n   */\n  constructor() {\n    this._physicsRig = void 0;\n    // 物理演算のデータ\n    this._options = void 0;\n    // オプション\n    this._currentRigOutputs = void 0;\n    ///< 最新の振り子計算の結果\n    this._previousRigOutputs = void 0;\n    ///< 一つ前の振り子計算の結果\n    this._currentRemainTime = void 0;\n    ///< 物理演算が処理していない時間\n    this._parameterCaches = void 0;\n    ///< Evaluateで利用するパラメータのキャッシュ\n    this._parameterInputCaches = void 0;\n    this._physicsRig = null;\n\n    // set default options\n    this._options = new Options();\n    this._options.gravity.y = -1.0;\n    this._options.gravity.x = 0.0;\n    this._options.wind.x = 0.0;\n    this._options.wind.y = 0.0;\n    this._currentRigOutputs = new csmVector();\n    this._previousRigOutputs = new csmVector();\n    this._currentRemainTime = 0.0;\n    this._parameterCaches = null;\n    this._parameterInputCaches = null;\n  }\n\n  /**\n   * デストラクタ相当の処理\n   */\n  release() {\n    this._physicsRig = void 0;\n    this._physicsRig = null;\n  }\n\n  /**\n   * 初期化する\n   */\n  initialize() {\n    let strand;\n    let currentSetting;\n    let radius;\n    for (let settingIndex = 0; settingIndex < this._physicsRig.subRigCount; ++settingIndex) {\n      currentSetting = this._physicsRig.settings.at(settingIndex);\n      strand = this._physicsRig.particles.get(currentSetting.baseParticleIndex);\n\n      // Initialize the top of particle.\n      strand[0].initialPosition = new CubismVector2(0.0, 0.0);\n      strand[0].lastPosition = new CubismVector2(strand[0].initialPosition.x, strand[0].initialPosition.y);\n      strand[0].lastGravity = new CubismVector2(0.0, -1.0);\n      strand[0].lastGravity.y *= -1.0;\n      strand[0].velocity = new CubismVector2(0.0, 0.0);\n      strand[0].force = new CubismVector2(0.0, 0.0);\n\n      // Initialize particles.\n      for (let i = 1; i < currentSetting.particleCount; ++i) {\n        radius = new CubismVector2(0.0, 0.0);\n        radius.y = strand[i].radius;\n        strand[i].initialPosition = new CubismVector2(strand[i - 1].initialPosition.x + radius.x, strand[i - 1].initialPosition.y + radius.y);\n        strand[i].position = new CubismVector2(strand[i].initialPosition.x, strand[i].initialPosition.y);\n        strand[i].lastPosition = new CubismVector2(strand[i].initialPosition.x, strand[i].initialPosition.y);\n        strand[i].lastGravity = new CubismVector2(0.0, -1.0);\n        strand[i].lastGravity.y *= -1.0;\n        strand[i].velocity = new CubismVector2(0.0, 0.0);\n        strand[i].force = new CubismVector2(0.0, 0.0);\n      }\n    }\n  }\n\n  ///< UpdateParticlesが動くときの入力をキャッシュ\n}\n\n/**\n * 物理演算のオプション\n */\nexport class Options {\n  constructor() {\n    this.gravity = void 0;\n    // 重力方向\n    this.wind = void 0;\n    this.gravity = new CubismVector2(0, 0);\n    this.wind = new CubismVector2(0, 0);\n  }\n\n  // 風の方向\n}\n\n/**\n * パラメータに適用する前の物理演算の出力結果\n */\nexport class PhysicsOutput {\n  constructor() {\n    this.outputs = void 0;\n    this.outputs = new csmVector(0);\n  }\n\n  // 物理演算出力結果\n}\n\n/**\n * Gets sign.\n *\n * @param value Evaluation target value.\n *\n * @return Sign of value.\n */\nfunction sign(value) {\n  let ret = 0;\n  if (value > 0.0) {\n    ret = 1;\n  } else if (value < 0.0) {\n    ret = -1;\n  }\n  return ret;\n}\nfunction getInputTranslationXFromNormalizedParameterValue(targetTranslation, targetAngle, value, parameterMinimumValue, parameterMaximumValue, parameterDefaultValue, normalizationPosition, normalizationAngle, isInverted, weight) {\n  targetTranslation.x += normalizeParameterValue(value, parameterMinimumValue, parameterMaximumValue, parameterDefaultValue, normalizationPosition.minimum, normalizationPosition.maximum, normalizationPosition.defalut, isInverted) * weight;\n}\nfunction getInputTranslationYFromNormalizedParamterValue(targetTranslation, targetAngle, value, parameterMinimumValue, parameterMaximumValue, parameterDefaultValue, normalizationPosition, normalizationAngle, isInverted, weight) {\n  targetTranslation.y += normalizeParameterValue(value, parameterMinimumValue, parameterMaximumValue, parameterDefaultValue, normalizationPosition.minimum, normalizationPosition.maximum, normalizationPosition.defalut, isInverted) * weight;\n}\nfunction getInputAngleFromNormalizedParameterValue(targetTranslation, targetAngle, value, parameterMinimumValue, parameterMaximumValue, parameterDefaultValue, normalizaitionPosition, normalizationAngle, isInverted, weight) {\n  targetAngle.angle += normalizeParameterValue(value, parameterMinimumValue, parameterMaximumValue, parameterDefaultValue, normalizationAngle.minimum, normalizationAngle.maximum, normalizationAngle.defalut, isInverted) * weight;\n}\nfunction getOutputTranslationX(translation, particles, particleIndex, isInverted, parentGravity) {\n  let outputValue = translation.x;\n  if (isInverted) {\n    outputValue *= -1.0;\n  }\n  return outputValue;\n}\nfunction getOutputTranslationY(translation, particles, particleIndex, isInverted, parentGravity) {\n  let outputValue = translation.y;\n  if (isInverted) {\n    outputValue *= -1.0;\n  }\n  return outputValue;\n}\nfunction getOutputAngle(translation, particles, particleIndex, isInverted, parentGravity) {\n  let outputValue;\n  if (particleIndex >= 2) {\n    parentGravity = particles[particleIndex - 1].position.substract(particles[particleIndex - 2].position);\n  } else {\n    parentGravity = parentGravity.multiplyByScaler(-1.0);\n  }\n  outputValue = CubismMath.directionToRadian(parentGravity, translation);\n  if (isInverted) {\n    outputValue *= -1.0;\n  }\n  return outputValue;\n}\nfunction getRangeValue(min, max) {\n  const maxValue = CubismMath.max(min, max);\n  const minValue = CubismMath.min(min, max);\n  return CubismMath.abs(maxValue - minValue);\n}\nfunction getDefaultValue(min, max) {\n  const minValue = CubismMath.min(min, max);\n  return minValue + getRangeValue(min, max) / 2.0;\n}\nfunction getOutputScaleTranslationX(translationScale, angleScale) {\n  return JSON.parse(JSON.stringify(translationScale.x));\n}\nfunction getOutputScaleTranslationY(translationScale, angleScale) {\n  return JSON.parse(JSON.stringify(translationScale.y));\n}\nfunction getOutputScaleAngle(translationScale, angleScale) {\n  return JSON.parse(JSON.stringify(angleScale));\n}\n\n/**\n * Updates particles.\n *\n * @param strand                Target array of particle.\n * @param strandCount           Count of particle.\n * @param totalTranslation      Total translation value.\n * @param totalAngle            Total angle.\n * @param windDirection         Direction of Wind.\n * @param thresholdValue        Threshold of movement.\n * @param deltaTimeSeconds      Delta time.\n * @param airResistance         Air resistance.\n */\nfunction updateParticles(strand, strandCount, totalTranslation, totalAngle, windDirection, thresholdValue, deltaTimeSeconds, airResistance) {\n  let totalRadian;\n  let delay;\n  let radian;\n  let currentGravity;\n  let direction = new CubismVector2(0.0, 0.0);\n  let velocity = new CubismVector2(0.0, 0.0);\n  let force = new CubismVector2(0.0, 0.0);\n  let newDirection = new CubismVector2(0.0, 0.0);\n  strand[0].position = new CubismVector2(totalTranslation.x, totalTranslation.y);\n  totalRadian = CubismMath.degreesToRadian(totalAngle);\n  currentGravity = CubismMath.radianToDirection(totalRadian);\n  currentGravity.normalize();\n  for (let i = 1; i < strandCount; ++i) {\n    strand[i].force = currentGravity.multiplyByScaler(strand[i].acceleration).add(windDirection);\n    strand[i].lastPosition = new CubismVector2(strand[i].position.x, strand[i].position.y);\n    delay = strand[i].delay * deltaTimeSeconds * 30.0;\n    direction = strand[i].position.substract(strand[i - 1].position);\n    radian = CubismMath.directionToRadian(strand[i].lastGravity, currentGravity) / airResistance;\n    direction.x = CubismMath.cos(radian) * direction.x - direction.y * CubismMath.sin(radian);\n    direction.y = CubismMath.sin(radian) * direction.x + direction.y * CubismMath.cos(radian);\n    strand[i].position = strand[i - 1].position.add(direction);\n    velocity = strand[i].velocity.multiplyByScaler(delay);\n    force = strand[i].force.multiplyByScaler(delay).multiplyByScaler(delay);\n    strand[i].position = strand[i].position.add(velocity).add(force);\n    newDirection = strand[i].position.substract(strand[i - 1].position);\n    newDirection.normalize();\n    strand[i].position = strand[i - 1].position.add(newDirection.multiplyByScaler(strand[i].radius));\n    if (CubismMath.abs(strand[i].position.x) < thresholdValue) {\n      strand[i].position.x = 0.0;\n    }\n    if (delay != 0.0) {\n      strand[i].velocity = strand[i].position.substract(strand[i].lastPosition);\n      strand[i].velocity = strand[i].velocity.divisionByScalar(delay);\n      strand[i].velocity = strand[i].velocity.multiplyByScaler(strand[i].mobility);\n    }\n    strand[i].force = new CubismVector2(0.0, 0.0);\n    strand[i].lastGravity = new CubismVector2(currentGravity.x, currentGravity.y);\n  }\n}\n\n/**\n * Updates particles for stabilization.\n *\n * @param strand                Target array of particle.\n * @param strandCount           Count of particle.\n * @param totalTranslation      Total translation value.\n * @param totalAngle            Total angle.\n * @param windDirection         Direction of Wind.\n * @param thresholdValue        Threshold of movement.\n */\nfunction updateParticlesForStabilization(strand, strandCount, totalTranslation, totalAngle, windDirection, thresholdValue) {\n  let totalRadian;\n  let currentGravity;\n  let force = new CubismVector2(0.0, 0.0);\n  strand[0].position = new CubismVector2(totalTranslation.x, totalTranslation.y);\n  totalRadian = CubismMath.degreesToRadian(totalAngle);\n  currentGravity = CubismMath.radianToDirection(totalRadian);\n  currentGravity.normalize();\n  for (let i = 1; i < strandCount; ++i) {\n    strand[i].force = currentGravity.multiplyByScaler(strand[i].acceleration).add(windDirection);\n    strand[i].lastPosition = new CubismVector2(strand[i].position.x, strand[i].position.y);\n    strand[i].velocity = new CubismVector2(0.0, 0.0);\n    force = strand[i].force;\n    force.normalize();\n    force = force.multiplyByScaler(strand[i].radius);\n    strand[i].position = strand[i - 1].position.add(force);\n    if (CubismMath.abs(strand[i].position.x) < thresholdValue) {\n      strand[i].position.x = 0.0;\n    }\n    strand[i].force = new CubismVector2(0.0, 0.0);\n    strand[i].lastGravity = new CubismVector2(currentGravity.x, currentGravity.y);\n  }\n}\n\n/**\n * Updates output parameter value.\n * @param parameterValue            Target parameter value.\n * @param parameterValueMinimum     Minimum of parameter value.\n * @param parameterValueMaximum     Maximum of parameter value.\n * @param translation               Translation value.\n */\nfunction updateOutputParameterValue(parameterValue, parameterValueMinimum, parameterValueMaximum, translation, output) {\n  let outputScale;\n  let value;\n  let weight;\n  outputScale = output.getScale(output.translationScale, output.angleScale);\n  value = translation * outputScale;\n  if (value < parameterValueMinimum) {\n    if (value < output.valueBelowMinimum) {\n      output.valueBelowMinimum = value;\n    }\n    value = parameterValueMinimum;\n  } else if (value > parameterValueMaximum) {\n    if (value > output.valueExceededMaximum) {\n      output.valueExceededMaximum = value;\n    }\n    value = parameterValueMaximum;\n  }\n  weight = output.weight / MaximumWeight;\n  if (weight >= 1.0) {\n    parameterValue[0] = value;\n  } else {\n    value = parameterValue[0] * (1.0 - weight) + value * weight;\n    parameterValue[0] = value;\n  }\n}\nfunction normalizeParameterValue(value, parameterMinimum, parameterMaximum, parameterDefault, normalizedMinimum, normalizedMaximum, normalizedDefault, isInverted) {\n  let result = 0.0;\n  const maxValue = CubismMath.max(parameterMaximum, parameterMinimum);\n  if (maxValue < value) {\n    value = maxValue;\n  }\n  const minValue = CubismMath.min(parameterMaximum, parameterMinimum);\n  if (minValue > value) {\n    value = minValue;\n  }\n  const minNormValue = CubismMath.min(normalizedMinimum, normalizedMaximum);\n  const maxNormValue = CubismMath.max(normalizedMinimum, normalizedMaximum);\n  const middleNormValue = normalizedDefault;\n  const middleValue = getDefaultValue(minValue, maxValue);\n  const paramValue = value - middleValue;\n  switch (sign(paramValue)) {\n    case 1:\n      {\n        const nLength = maxNormValue - middleNormValue;\n        const pLength = maxValue - middleValue;\n        if (pLength != 0.0) {\n          result = paramValue * (nLength / pLength);\n          result += middleNormValue;\n        }\n        break;\n      }\n    case -1:\n      {\n        const nLength = minNormValue - middleNormValue;\n        const pLength = minValue - middleValue;\n        if (pLength != 0.0) {\n          result = paramValue * (nLength / pLength);\n          result += middleNormValue;\n        }\n        break;\n      }\n    case 0:\n      {\n        result = middleNormValue;\n        break;\n      }\n    default:\n      {\n        break;\n      }\n  }\n  return isInverted ? result : result * -1.0;\n}\n\n// Namespace definition for compatibility.\nimport * as $ from './cubismphysics';\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport let Live2DCubismFramework;\n(function (_Live2DCubismFramework) {\n  const CubismPhysics = _Live2DCubismFramework.CubismPhysics = $.CubismPhysics;\n  const Options = _Live2DCubismFramework.Options = $.Options;\n})(Live2DCubismFramework || (Live2DCubismFramework = {}));","map":{"version":3,"names":["CubismMath","CubismVector2","csmVector","CubismPhysicsInput","CubismPhysicsOutput","CubismPhysicsParticle","CubismPhysicsRig","CubismPhysicsSource","CubismPhysicsSubRig","CubismPhysicsTargetType","CubismPhysicsJson","PhysicsTypeTagX","PhysicsTypeTagY","PhysicsTypeTagAngle","AirResistance","MaximumWeight","MovementThreshold","MaxDeltaTime","CubismPhysics","create","buffer","size","ret","parse","_physicsRig","gravity","y","delete","physics","release","physicsJson","json","getGravity","wind","getWind","subRigCount","getSubRigCount","fps","getFps","settings","updateSize","inputs","getTotalInputCount","outputs","getTotalOutputCount","particles","getVertexCount","_currentRigOutputs","clear","_previousRigOutputs","inputIndex","outputIndex","particleIndex","i","getSize","at","normalizationPosition","minimum","getNormalizationPositionMinimumValue","maximum","getNormalizationPositionMaximumValue","defalut","getNormalizationPositionDefaultValue","normalizationAngle","getNormalizationAngleMinimumValue","getNormalizationAngleMaximumValue","getNormalizationAngleDefaultValue","inputCount","getInputCount","baseInputIndex","j","sourceParameterIndex","weight","getInputWeight","reflect","getInputReflect","getInputType","type","CubismPhysicsSource_X","getNormalizedParameterValue","getInputTranslationXFromNormalizedParameterValue","CubismPhysicsSource_Y","getInputTranslationYFromNormalizedParamterValue","CubismPhysicsSource_Angle","getInputAngleFromNormalizedParameterValue","source","targetType","CubismPhysicsTargetType_Parameter","id","getInputSourceId","outputCount","getOutputCount","baseOutputIndex","currentRigOutput","PhysicsOutput","resize","previousRigOutput","set","destinationParameterIndex","vertexIndex","getOutputVertexIndex","angleScale","getOutputAngleScale","getOutputWeight","destination","getOutputDestinationId","getOutputType","getValue","getOutputTranslationX","getScale","getOutputScaleTranslationX","getOutputTranslationY","getOutputScaleTranslationY","getOutputAngle","getOutputScaleAngle","getOutputReflect","pushBack","particleCount","getParticleCount","baseParticleIndex","mobility","getParticleMobility","delay","getParticleDelay","acceleration","getParticleAcceleration","radius","getParticleRadius","position","getParticlePosition","initialize","stabilization","model","_this$_parameterCache","_this$_parameterCache2","_this$_parameterInput","_this$_parameterInput2","totalAngle","radAngle","outputValue","totalTranslation","currentSetting","currentInputs","currentOutputs","currentParticles","parameterValues","parameterMaximumValues","parameterMinimumValues","parameterDefaultValues","getModel","parameters","values","maximumValues","minimumValues","defaultValues","_parameterCaches","length","getParameterCount","Float32Array","_parameterInputCaches","settingIndex","angle","x","get","getParameterIndex","degreesToRadian","cos","sin","updateParticlesForStabilization","_options","translation","substract","outParameterCaches","prototype","slice","JSON","stringify","subarray","updateOutputParameterValue","offset","outParamIndex","evaluate","deltaTimeSeconds","_this$_parameterCache3","_this$_parameterCache4","_this$_parameterInput3","_this$_parameterInput4","physicsDeltaTime","_currentRemainTime","inputWeight","updateParticles","alpha","interpolate","outParameterValues","setOptions","options","getOption","constructor","Options","strand","initialPosition","lastPosition","lastGravity","velocity","force","sign","value","targetTranslation","targetAngle","parameterMinimumValue","parameterMaximumValue","parameterDefaultValue","isInverted","normalizeParameterValue","normalizaitionPosition","parentGravity","multiplyByScaler","directionToRadian","getRangeValue","min","max","maxValue","minValue","abs","getDefaultValue","translationScale","strandCount","windDirection","thresholdValue","airResistance","totalRadian","radian","currentGravity","direction","newDirection","radianToDirection","normalize","add","divisionByScalar","parameterValue","parameterValueMinimum","parameterValueMaximum","output","outputScale","valueBelowMinimum","valueExceededMaximum","parameterMinimum","parameterMaximum","parameterDefault","normalizedMinimum","normalizedMaximum","normalizedDefault","result","minNormValue","maxNormValue","middleNormValue","middleValue","paramValue","nLength","pLength","$","Live2DCubismFramework","_Live2DCubismFramework"],"sources":["D:/Personal/PythonStuff/RR/RRWebsiteRenewed/my-app/src/Framework/src/physics/cubismphysics.ts"],"sourcesContent":["/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\n\nimport { CubismMath } from '../math/cubismmath';\nimport { CubismVector2 } from '../math/cubismvector2';\nimport { csmVector } from '../type/csmvector';\nimport { CubismModel } from '../model/cubismmodel';\nimport {\n  CubismPhysicsInput,\n  CubismPhysicsNormalization,\n  CubismPhysicsOutput,\n  CubismPhysicsParticle,\n  CubismPhysicsRig,\n  CubismPhysicsSource,\n  CubismPhysicsSubRig,\n  CubismPhysicsTargetType,\n} from './cubismphysicsinternal';\nimport { CubismPhysicsJson } from './cubismphysicsjson';\n\n// physics types tags.\nconst PhysicsTypeTagX = 'X';\nconst PhysicsTypeTagY = 'Y';\nconst PhysicsTypeTagAngle = 'Angle';\n\n// Constant of air resistance.\nconst AirResistance = 5.0;\n\n// Constant of maximum weight of input and output ratio.\nconst MaximumWeight = 100.0;\n\n// Constant of threshold of movement.\nconst MovementThreshold = 0.001;\n\n// Constant of maximum allowed delta time\nconst MaxDeltaTime = 5.0;\n\n/**\n * 物理演算クラス\n */\nexport class CubismPhysics {\n  /**\n   * インスタンスの作成\n   * @param buffer    physics3.jsonが読み込まれているバッファ\n   * @param size      バッファのサイズ\n   * @return 作成されたインスタンス\n   */\n  public static create(buffer: ArrayBuffer, size: number): CubismPhysics {\n    const ret: CubismPhysics = new CubismPhysics();\n\n    ret.parse(buffer, size);\n    ret._physicsRig.gravity.y = 0;\n\n    return ret;\n  }\n\n  /**\n   * インスタンスを破棄する\n   * @param physics 破棄するインスタンス\n   */\n  public static delete(physics: CubismPhysics): void {\n    if (physics != null) {\n      physics.release();\n      physics = null;\n    }\n  }\n\n  /**\n   * physics3.jsonをパースする。\n   * @param physicsJson physics3.jsonが読み込まれているバッファ\n   * @param size バッファのサイズ\n   */\n  public parse(physicsJson: ArrayBuffer, size: number): void {\n    this._physicsRig = new CubismPhysicsRig();\n\n    let json: CubismPhysicsJson = new CubismPhysicsJson(physicsJson, size);\n\n    this._physicsRig.gravity = json.getGravity();\n    this._physicsRig.wind = json.getWind();\n    this._physicsRig.subRigCount = json.getSubRigCount();\n\n    this._physicsRig.fps = json.getFps();\n\n    this._physicsRig.settings.updateSize(\n      this._physicsRig.subRigCount,\n      CubismPhysicsSubRig,\n      true\n    );\n    this._physicsRig.inputs.updateSize(\n      json.getTotalInputCount(),\n      CubismPhysicsInput,\n      true\n    );\n    this._physicsRig.outputs.updateSize(\n      json.getTotalOutputCount(),\n      CubismPhysicsOutput,\n      true\n    );\n    this._physicsRig.particles.updateSize(\n      json.getVertexCount(),\n      CubismPhysicsParticle,\n      true\n    );\n\n    this._currentRigOutputs.clear();\n    this._previousRigOutputs.clear();\n\n    let inputIndex = 0,\n      outputIndex = 0,\n      particleIndex = 0;\n\n    for (let i = 0; i < this._physicsRig.settings.getSize(); ++i) {\n      this._physicsRig.settings.at(i).normalizationPosition.minimum =\n        json.getNormalizationPositionMinimumValue(i);\n      this._physicsRig.settings.at(i).normalizationPosition.maximum =\n        json.getNormalizationPositionMaximumValue(i);\n      this._physicsRig.settings.at(i).normalizationPosition.defalut =\n        json.getNormalizationPositionDefaultValue(i);\n\n      this._physicsRig.settings.at(i).normalizationAngle.minimum =\n        json.getNormalizationAngleMinimumValue(i);\n      this._physicsRig.settings.at(i).normalizationAngle.maximum =\n        json.getNormalizationAngleMaximumValue(i);\n      this._physicsRig.settings.at(i).normalizationAngle.defalut =\n        json.getNormalizationAngleDefaultValue(i);\n\n      // Input\n      this._physicsRig.settings.at(i).inputCount = json.getInputCount(i);\n      this._physicsRig.settings.at(i).baseInputIndex = inputIndex;\n\n      for (let j = 0; j < this._physicsRig.settings.at(i).inputCount; ++j) {\n        this._physicsRig.inputs.at(inputIndex + j).sourceParameterIndex = -1;\n        this._physicsRig.inputs.at(inputIndex + j).weight = json.getInputWeight(\n          i,\n          j\n        );\n        this._physicsRig.inputs.at(inputIndex + j).reflect =\n          json.getInputReflect(i, j);\n\n        if (json.getInputType(i, j) == PhysicsTypeTagX) {\n          this._physicsRig.inputs.at(inputIndex + j).type =\n            CubismPhysicsSource.CubismPhysicsSource_X;\n          this._physicsRig.inputs.at(\n            inputIndex + j\n          ).getNormalizedParameterValue =\n            getInputTranslationXFromNormalizedParameterValue;\n        } else if (json.getInputType(i, j) == PhysicsTypeTagY) {\n          this._physicsRig.inputs.at(inputIndex + j).type =\n            CubismPhysicsSource.CubismPhysicsSource_Y;\n          this._physicsRig.inputs.at(\n            inputIndex + j\n          ).getNormalizedParameterValue =\n            getInputTranslationYFromNormalizedParamterValue;\n        } else if (json.getInputType(i, j) == PhysicsTypeTagAngle) {\n          this._physicsRig.inputs.at(inputIndex + j).type =\n            CubismPhysicsSource.CubismPhysicsSource_Angle;\n          this._physicsRig.inputs.at(\n            inputIndex + j\n          ).getNormalizedParameterValue =\n            getInputAngleFromNormalizedParameterValue;\n        }\n\n        this._physicsRig.inputs.at(inputIndex + j).source.targetType =\n          CubismPhysicsTargetType.CubismPhysicsTargetType_Parameter;\n        this._physicsRig.inputs.at(inputIndex + j).source.id =\n          json.getInputSourceId(i, j);\n      }\n      inputIndex += this._physicsRig.settings.at(i).inputCount;\n\n      // Output\n      this._physicsRig.settings.at(i).outputCount = json.getOutputCount(i);\n      this._physicsRig.settings.at(i).baseOutputIndex = outputIndex;\n\n      const currentRigOutput = new PhysicsOutput();\n      currentRigOutput.outputs.resize(\n        this._physicsRig.settings.at(i).outputCount\n      );\n\n      const previousRigOutput = new PhysicsOutput();\n      previousRigOutput.outputs.resize(\n        this._physicsRig.settings.at(i).outputCount\n      );\n\n      for (let j = 0; j < this._physicsRig.settings.at(i).outputCount; ++j) {\n        // initialize\n        currentRigOutput.outputs.set(j, 0.0);\n        previousRigOutput.outputs.set(j, 0.0);\n\n        this._physicsRig.outputs.at(outputIndex + j).destinationParameterIndex =\n          -1;\n        this._physicsRig.outputs.at(outputIndex + j).vertexIndex =\n          json.getOutputVertexIndex(i, j);\n        this._physicsRig.outputs.at(outputIndex + j).angleScale =\n          json.getOutputAngleScale(i, j);\n        this._physicsRig.outputs.at(outputIndex + j).weight =\n          json.getOutputWeight(i, j);\n        this._physicsRig.outputs.at(outputIndex + j).destination.targetType =\n          CubismPhysicsTargetType.CubismPhysicsTargetType_Parameter;\n\n        this._physicsRig.outputs.at(outputIndex + j).destination.id =\n          json.getOutputDestinationId(i, j);\n\n        if (json.getOutputType(i, j) == PhysicsTypeTagX) {\n          this._physicsRig.outputs.at(outputIndex + j).type =\n            CubismPhysicsSource.CubismPhysicsSource_X;\n          this._physicsRig.outputs.at(outputIndex + j).getValue =\n            getOutputTranslationX;\n          this._physicsRig.outputs.at(outputIndex + j).getScale =\n            getOutputScaleTranslationX;\n        } else if (json.getOutputType(i, j) == PhysicsTypeTagY) {\n          this._physicsRig.outputs.at(outputIndex + j).type =\n            CubismPhysicsSource.CubismPhysicsSource_Y;\n          this._physicsRig.outputs.at(outputIndex + j).getValue =\n            getOutputTranslationY;\n          this._physicsRig.outputs.at(outputIndex + j).getScale =\n            getOutputScaleTranslationY;\n        } else if (json.getOutputType(i, j) == PhysicsTypeTagAngle) {\n          this._physicsRig.outputs.at(outputIndex + j).type =\n            CubismPhysicsSource.CubismPhysicsSource_Angle;\n          this._physicsRig.outputs.at(outputIndex + j).getValue =\n            getOutputAngle;\n          this._physicsRig.outputs.at(outputIndex + j).getScale =\n            getOutputScaleAngle;\n        }\n\n        this._physicsRig.outputs.at(outputIndex + j).reflect =\n          json.getOutputReflect(i, j);\n      }\n\n      this._currentRigOutputs.pushBack(currentRigOutput);\n      this._previousRigOutputs.pushBack(previousRigOutput);\n\n      outputIndex += this._physicsRig.settings.at(i).outputCount;\n\n      // Particle\n      this._physicsRig.settings.at(i).particleCount = json.getParticleCount(i);\n      this._physicsRig.settings.at(i).baseParticleIndex = particleIndex;\n\n      for (let j = 0; j < this._physicsRig.settings.at(i).particleCount; ++j) {\n        this._physicsRig.particles.at(particleIndex + j).mobility =\n          json.getParticleMobility(i, j);\n        this._physicsRig.particles.at(particleIndex + j).delay =\n          json.getParticleDelay(i, j);\n        this._physicsRig.particles.at(particleIndex + j).acceleration =\n          json.getParticleAcceleration(i, j);\n        this._physicsRig.particles.at(particleIndex + j).radius =\n          json.getParticleRadius(i, j);\n        this._physicsRig.particles.at(particleIndex + j).position =\n          json.getParticlePosition(i, j);\n      }\n\n      particleIndex += this._physicsRig.settings.at(i).particleCount;\n    }\n\n    this.initialize();\n\n    json.release();\n    json = void 0;\n    json = null;\n  }\n\n  /**\n   * 現在のパラメータ値で物理演算が安定化する状態を演算する。\n   * @param model 物理演算の結果を適用するモデル\n   */\n  public stabilization(model: CubismModel): void {\n    let totalAngle: { angle: number };\n    let weight: number;\n    let radAngle: number;\n    let outputValue: number;\n    const totalTranslation: CubismVector2 = new CubismVector2();\n    let currentSetting: CubismPhysicsSubRig;\n    let currentInputs: CubismPhysicsInput[];\n    let currentOutputs: CubismPhysicsOutput[];\n    let currentParticles: CubismPhysicsParticle[];\n\n    let parameterValues: Float32Array;\n    let parameterMaximumValues: Float32Array;\n    let parameterMinimumValues: Float32Array;\n    let parameterDefaultValues: Float32Array;\n\n    parameterValues = model.getModel().parameters.values;\n    parameterMaximumValues = model.getModel().parameters.maximumValues;\n    parameterMinimumValues = model.getModel().parameters.minimumValues;\n    parameterDefaultValues = model.getModel().parameters.defaultValues;\n\n    if ((this._parameterCaches?.length ?? 0) < model.getParameterCount()) {\n      this._parameterCaches = new Float32Array(model.getParameterCount());\n    }\n\n    if ((this._parameterInputCaches?.length ?? 0) < model.getParameterCount()) {\n      this._parameterInputCaches = new Float32Array(model.getParameterCount());\n    }\n\n    for (let j = 0; j < model.getParameterCount(); ++j) {\n      this._parameterCaches[j] = parameterValues[j];\n      this._parameterInputCaches[j] = parameterValues[j];\n    }\n\n    for (\n      let settingIndex = 0;\n      settingIndex < this._physicsRig.subRigCount;\n      ++settingIndex\n    ) {\n      totalAngle = { angle: 0.0 };\n      totalTranslation.x = 0.0;\n      totalTranslation.y = 0.0;\n      currentSetting = this._physicsRig.settings.at(settingIndex);\n      currentInputs = this._physicsRig.inputs.get(\n        currentSetting.baseInputIndex\n      );\n      currentOutputs = this._physicsRig.outputs.get(\n        currentSetting.baseOutputIndex\n      );\n      currentParticles = this._physicsRig.particles.get(\n        currentSetting.baseParticleIndex\n      );\n\n      // Load input parameters\n      for (let i = 0; i < currentSetting.inputCount; ++i) {\n        weight = currentInputs[i].weight / MaximumWeight;\n\n        if (currentInputs[i].sourceParameterIndex == -1) {\n          currentInputs[i].sourceParameterIndex = model.getParameterIndex(\n            currentInputs[i].source.id\n          );\n        }\n\n        currentInputs[i].getNormalizedParameterValue(\n          totalTranslation,\n          totalAngle,\n          parameterValues[currentInputs[i].sourceParameterIndex],\n          parameterMinimumValues[currentInputs[i].sourceParameterIndex],\n          parameterMaximumValues[currentInputs[i].sourceParameterIndex],\n          parameterDefaultValues[currentInputs[i].sourceParameterIndex],\n          currentSetting.normalizationPosition,\n          currentSetting.normalizationAngle,\n          currentInputs[i].reflect,\n          weight\n        );\n\n        this._parameterCaches[currentInputs[i].sourceParameterIndex] =\n          parameterValues[currentInputs[i].sourceParameterIndex];\n      }\n\n      radAngle = CubismMath.degreesToRadian(-totalAngle.angle);\n\n      totalTranslation.x =\n        totalTranslation.x * CubismMath.cos(radAngle) -\n        totalTranslation.y * CubismMath.sin(radAngle);\n      totalTranslation.y =\n        totalTranslation.x * CubismMath.sin(radAngle) +\n        totalTranslation.y * CubismMath.cos(radAngle);\n\n      // Calculate particles position.\n      updateParticlesForStabilization(\n        currentParticles,\n        currentSetting.particleCount,\n        totalTranslation,\n        totalAngle.angle,\n        this._options.wind,\n        MovementThreshold * currentSetting.normalizationPosition.maximum\n      );\n\n      // Update output parameters.\n      for (let i = 0; i < currentSetting.outputCount; ++i) {\n        const particleIndex = currentOutputs[i].vertexIndex;\n\n        if (currentOutputs[i].destinationParameterIndex == -1) {\n          currentOutputs[i].destinationParameterIndex = model.getParameterIndex(\n            currentOutputs[i].destination.id\n          );\n        }\n\n        if (\n          particleIndex < 1 ||\n          particleIndex >= currentSetting.particleCount\n        ) {\n          continue;\n        }\n\n        let translation: CubismVector2 = new CubismVector2();\n        translation = currentParticles[particleIndex].position.substract(\n          currentParticles[particleIndex - 1].position\n        );\n\n        outputValue = currentOutputs[i].getValue(\n          translation,\n          currentParticles,\n          particleIndex,\n          currentOutputs[i].reflect,\n          this._options.gravity\n        );\n\n        this._currentRigOutputs.at(settingIndex).outputs.set(i, outputValue);\n        this._previousRigOutputs.at(settingIndex).outputs.set(i, outputValue);\n\n        const destinationParameterIndex: number =\n          currentOutputs[i].destinationParameterIndex;\n\n        const outParameterCaches: Float32Array =\n          !Float32Array.prototype.slice && 'subarray' in Float32Array.prototype\n            ? JSON.parse(\n                JSON.stringify(\n                  parameterValues.subarray(destinationParameterIndex)\n                )\n              ) // 値渡しするため、JSON.parse, JSON.stringify\n            : parameterValues.slice(destinationParameterIndex);\n\n        updateOutputParameterValue(\n          outParameterCaches,\n          parameterMinimumValues[destinationParameterIndex],\n          parameterMaximumValues[destinationParameterIndex],\n          outputValue,\n          currentOutputs[i]\n        );\n\n        // 値を反映\n        for (\n          let offset: number = destinationParameterIndex, outParamIndex = 0;\n          offset < this._parameterCaches.length;\n          offset++, outParamIndex++\n        ) {\n          parameterValues[offset] = this._parameterCaches[offset] =\n            outParameterCaches[outParamIndex];\n        }\n      }\n    }\n  }\n\n  /**\n   * 物理演算の評価\n   *\n   * Pendulum interpolation weights\n   *\n   * 振り子の計算結果は保存され、パラメータへの出力は保存された前回の結果で補間されます。\n   * The result of the pendulum calculation is saved and\n   * the output to the parameters is interpolated with the saved previous result of the pendulum calculation.\n   *\n   * 図で示すと[1]と[2]で補間されます。\n   * The figure shows the interpolation between [1] and [2].\n   *\n   * 補間の重みは最新の振り子計算タイミングと次回のタイミングの間で見た現在時間で決定する。\n   * The weight of the interpolation are determined by the current time seen between\n   * the latest pendulum calculation timing and the next timing.\n   *\n   * 図で示すと[2]と[4]の間でみた(3)の位置の重みになる。\n   * Figure shows the weight of position (3) as seen between [2] and [4].\n   *\n   * 解釈として振り子計算のタイミングと重み計算のタイミングがズレる。\n   * As an interpretation, the pendulum calculation and weights are misaligned.\n   *\n   * physics3.jsonにFPS情報が存在しない場合は常に前の振り子状態で設定される。\n   * If there is no FPS information in physics3.json, it is always set in the previous pendulum state.\n   *\n   * この仕様は補間範囲を逸脱したことが原因の震えたような見た目を回避を目的にしている。\n   * The purpose of this specification is to avoid the quivering appearance caused by deviations from the interpolation range.\n   *\n   * ------------ time -------------->\n   *\n   *                 |+++++|------| <- weight\n   * ==[1]====#=====[2]---(3)----(4)\n   *          ^ output contents\n   *\n   * 1:_previousRigOutputs\n   * 2:_currentRigOutputs\n   * 3:_currentRemainTime (now rendering)\n   * 4:next particles timing\n   * @param model 物理演算の結果を適用するモデル\n   * @param deltaTimeSeconds デルタ時間[秒]\n   */\n  public evaluate(model: CubismModel, deltaTimeSeconds: number): void {\n    let totalAngle: { angle: number };\n    let weight: number;\n    let radAngle: number;\n    let outputValue: number;\n    const totalTranslation: CubismVector2 = new CubismVector2();\n    let currentSetting: CubismPhysicsSubRig;\n    let currentInputs: CubismPhysicsInput[];\n    let currentOutputs: CubismPhysicsOutput[];\n    let currentParticles: CubismPhysicsParticle[];\n\n    if (0.0 >= deltaTimeSeconds) {\n      return;\n    }\n\n    let parameterValues: Float32Array;\n    let parameterMaximumValues: Float32Array;\n    let parameterMinimumValues: Float32Array;\n    let parameterDefaultValues: Float32Array;\n\n    let physicsDeltaTime: number;\n    this._currentRemainTime += deltaTimeSeconds;\n    if (this._currentRemainTime > MaxDeltaTime) {\n      this._currentRemainTime = 0.0;\n    }\n\n    parameterValues = model.getModel().parameters.values;\n    parameterMaximumValues = model.getModel().parameters.maximumValues;\n    parameterMinimumValues = model.getModel().parameters.minimumValues;\n    parameterDefaultValues = model.getModel().parameters.defaultValues;\n\n    if ((this._parameterCaches?.length ?? 0) < model.getParameterCount()) {\n      this._parameterCaches = new Float32Array(model.getParameterCount());\n    }\n\n    if ((this._parameterInputCaches?.length ?? 0) < model.getParameterCount()) {\n      this._parameterInputCaches = new Float32Array(model.getParameterCount());\n      for (let j = 0; j < model.getParameterCount(); ++j) {\n        this._parameterInputCaches[j] = parameterValues[j];\n      }\n    }\n\n    if (this._physicsRig.fps > 0.0) {\n      physicsDeltaTime = 1.0 / this._physicsRig.fps;\n    } else {\n      physicsDeltaTime = deltaTimeSeconds;\n    }\n\n    while (this._currentRemainTime >= physicsDeltaTime) {\n      // copyRigOutputs _currentRigOutputs to _previousRigOutputs\n      for (\n        let settingIndex = 0;\n        settingIndex < this._physicsRig.subRigCount;\n        ++settingIndex\n      ) {\n        currentSetting = this._physicsRig.settings.at(settingIndex);\n        currentOutputs = this._physicsRig.outputs.get(\n          currentSetting.baseOutputIndex\n        );\n        for (let i = 0; i < currentSetting.outputCount; ++i) {\n          this._previousRigOutputs\n            .at(settingIndex)\n            .outputs.set(\n              i,\n              this._currentRigOutputs.at(settingIndex).outputs.at(i)\n            );\n        }\n      }\n\n      // 入力キャッシュとパラメータで線形補間してUpdateParticlesするタイミングでの入力を計算する。\n      // Calculate the input at the timing to UpdateParticles by linear interpolation with the _parameterInputCache and parameterValue.\n      // _parameterCacheはグループ間での値の伝搬の役割があるので_parameterInputCacheとの分離が必要。\n      // _parameterCache needs to be separated from _parameterInputCache because of its role in propagating values between groups.\n      const inputWeight = physicsDeltaTime / this._currentRemainTime;\n      for (let j = 0; j < model.getParameterCount(); ++j) {\n        this._parameterCaches[j] =\n          this._parameterInputCaches[j] * (1.0 - inputWeight) +\n          parameterValues[j] * inputWeight;\n        this._parameterInputCaches[j] = this._parameterCaches[j];\n      }\n\n      for (\n        let settingIndex = 0;\n        settingIndex < this._physicsRig.subRigCount;\n        ++settingIndex\n      ) {\n        totalAngle = { angle: 0.0 };\n        totalTranslation.x = 0.0;\n        totalTranslation.y = 0.0;\n        currentSetting = this._physicsRig.settings.at(settingIndex);\n        currentInputs = this._physicsRig.inputs.get(\n          currentSetting.baseInputIndex\n        );\n        currentOutputs = this._physicsRig.outputs.get(\n          currentSetting.baseOutputIndex\n        );\n        currentParticles = this._physicsRig.particles.get(\n          currentSetting.baseParticleIndex\n        );\n\n        // Load input parameters\n        for (let i = 0; i < currentSetting.inputCount; ++i) {\n          weight = currentInputs[i].weight / MaximumWeight;\n\n          if (currentInputs[i].sourceParameterIndex == -1) {\n            currentInputs[i].sourceParameterIndex = model.getParameterIndex(\n              currentInputs[i].source.id\n            );\n          }\n\n          currentInputs[i].getNormalizedParameterValue(\n            totalTranslation,\n            totalAngle,\n            this._parameterCaches[currentInputs[i].sourceParameterIndex],\n            parameterMinimumValues[currentInputs[i].sourceParameterIndex],\n            parameterMaximumValues[currentInputs[i].sourceParameterIndex],\n            parameterDefaultValues[currentInputs[i].sourceParameterIndex],\n            currentSetting.normalizationPosition,\n            currentSetting.normalizationAngle,\n            currentInputs[i].reflect,\n            weight\n          );\n        }\n\n        radAngle = CubismMath.degreesToRadian(-totalAngle.angle);\n\n        totalTranslation.x =\n          totalTranslation.x * CubismMath.cos(radAngle) -\n          totalTranslation.y * CubismMath.sin(radAngle);\n        totalTranslation.y =\n          totalTranslation.x * CubismMath.sin(radAngle) +\n          totalTranslation.y * CubismMath.cos(radAngle);\n\n        // Calculate particles position.\n        updateParticles(\n          currentParticles,\n          currentSetting.particleCount,\n          totalTranslation,\n          totalAngle.angle,\n          this._options.wind,\n          MovementThreshold * currentSetting.normalizationPosition.maximum,\n          physicsDeltaTime,\n          AirResistance\n        );\n\n        // Update output parameters.\n        for (let i = 0; i < currentSetting.outputCount; ++i) {\n          const particleIndex = currentOutputs[i].vertexIndex;\n\n          if (currentOutputs[i].destinationParameterIndex == -1) {\n            currentOutputs[i].destinationParameterIndex =\n              model.getParameterIndex(currentOutputs[i].destination.id);\n          }\n\n          if (\n            particleIndex < 1 ||\n            particleIndex >= currentSetting.particleCount\n          ) {\n            continue;\n          }\n\n          const translation: CubismVector2 = new CubismVector2();\n          translation.x =\n            currentParticles[particleIndex].position.x -\n            currentParticles[particleIndex - 1].position.x;\n          translation.y =\n            currentParticles[particleIndex].position.y -\n            currentParticles[particleIndex - 1].position.y;\n\n          outputValue = currentOutputs[i].getValue(\n            translation,\n            currentParticles,\n            particleIndex,\n            currentOutputs[i].reflect,\n            this._options.gravity\n          );\n\n          this._currentRigOutputs.at(settingIndex).outputs.set(i, outputValue);\n\n          const destinationParameterIndex: number =\n            currentOutputs[i].destinationParameterIndex;\n          const outParameterCaches: Float32Array =\n            !Float32Array.prototype.slice &&\n            'subarray' in Float32Array.prototype\n              ? JSON.parse(\n                  JSON.stringify(\n                    this._parameterCaches.subarray(destinationParameterIndex)\n                  )\n                ) // 値渡しするため、JSON.parse, JSON.stringify\n              : this._parameterCaches.slice(destinationParameterIndex);\n\n          updateOutputParameterValue(\n            outParameterCaches,\n            parameterMinimumValues[destinationParameterIndex],\n            parameterMaximumValues[destinationParameterIndex],\n            outputValue,\n            currentOutputs[i]\n          );\n\n          // 値を反映\n          for (\n            let offset: number = destinationParameterIndex, outParamIndex = 0;\n            offset < this._parameterCaches.length;\n            offset++, outParamIndex++\n          ) {\n            this._parameterCaches[offset] = outParameterCaches[outParamIndex];\n          }\n        }\n      }\n      this._currentRemainTime -= physicsDeltaTime;\n    }\n\n    const alpha: number = this._currentRemainTime / physicsDeltaTime;\n    this.interpolate(model, alpha);\n  }\n\n  /**\n   * 物理演算結果の適用\n   * 振り子演算の最新の結果と一つ前の結果から指定した重みで適用する。\n   * @param model 物理演算の結果を適用するモデル\n   * @param weight 最新結果の重み\n   */\n  public interpolate(model: CubismModel, weight: number): void {\n    let currentOutputs: CubismPhysicsOutput[];\n    let currentSetting: CubismPhysicsSubRig;\n    let parameterValues: Float32Array;\n    let parameterMaximumValues: Float32Array;\n    let parameterMinimumValues: Float32Array;\n\n    parameterValues = model.getModel().parameters.values;\n    parameterMaximumValues = model.getModel().parameters.maximumValues;\n    parameterMinimumValues = model.getModel().parameters.minimumValues;\n\n    for (\n      let settingIndex = 0;\n      settingIndex < this._physicsRig.subRigCount;\n      ++settingIndex\n    ) {\n      currentSetting = this._physicsRig.settings.at(settingIndex);\n      currentOutputs = this._physicsRig.outputs.get(\n        currentSetting.baseOutputIndex\n      );\n\n      // Load input parameters.\n      for (let i = 0; i < currentSetting.outputCount; ++i) {\n        if (currentOutputs[i].destinationParameterIndex == -1) {\n          continue;\n        }\n\n        const destinationParameterIndex: number =\n          currentOutputs[i].destinationParameterIndex;\n        const outParameterValues: Float32Array =\n          !Float32Array.prototype.slice && 'subarray' in Float32Array.prototype\n            ? JSON.parse(\n                JSON.stringify(\n                  parameterValues.subarray(destinationParameterIndex)\n                )\n              ) // 値渡しするため、JSON.parse, JSON.stringify\n            : parameterValues.slice(destinationParameterIndex);\n\n        updateOutputParameterValue(\n          outParameterValues,\n          parameterMinimumValues[destinationParameterIndex],\n          parameterMaximumValues[destinationParameterIndex],\n          this._previousRigOutputs.at(settingIndex).outputs.at(i) *\n            (1 - weight) +\n            this._currentRigOutputs.at(settingIndex).outputs.at(i) * weight,\n          currentOutputs[i]\n        );\n\n        // 値を反映\n        for (\n          let offset: number = destinationParameterIndex, outParamIndex = 0;\n          offset < parameterValues.length;\n          offset++, outParamIndex++\n        ) {\n          parameterValues[offset] = outParameterValues[outParamIndex];\n        }\n      }\n    }\n  }\n\n  /**\n   * オプションの設定\n   * @param options オプション\n   */\n  public setOptions(options: Options): void {\n    this._options = options;\n  }\n\n  /**\n   * オプションの取得\n   * @return オプション\n   */\n  public getOption(): Options {\n    return this._options;\n  }\n\n  /**\n   * コンストラクタ\n   */\n  public constructor() {\n    this._physicsRig = null;\n\n    // set default options\n    this._options = new Options();\n    this._options.gravity.y = -1.0;\n    this._options.gravity.x = 0.0;\n    this._options.wind.x = 0.0;\n    this._options.wind.y = 0.0;\n    this._currentRigOutputs = new csmVector<PhysicsOutput>();\n    this._previousRigOutputs = new csmVector<PhysicsOutput>();\n    this._currentRemainTime = 0.0;\n    this._parameterCaches = null;\n    this._parameterInputCaches = null;\n  }\n\n  /**\n   * デストラクタ相当の処理\n   */\n  public release(): void {\n    this._physicsRig = void 0;\n    this._physicsRig = null;\n  }\n\n  /**\n   * 初期化する\n   */\n  public initialize(): void {\n    let strand: CubismPhysicsParticle[];\n    let currentSetting: CubismPhysicsSubRig;\n    let radius: CubismVector2;\n\n    for (\n      let settingIndex = 0;\n      settingIndex < this._physicsRig.subRigCount;\n      ++settingIndex\n    ) {\n      currentSetting = this._physicsRig.settings.at(settingIndex);\n      strand = this._physicsRig.particles.get(currentSetting.baseParticleIndex);\n\n      // Initialize the top of particle.\n      strand[0].initialPosition = new CubismVector2(0.0, 0.0);\n      strand[0].lastPosition = new CubismVector2(\n        strand[0].initialPosition.x,\n        strand[0].initialPosition.y\n      );\n      strand[0].lastGravity = new CubismVector2(0.0, -1.0);\n      strand[0].lastGravity.y *= -1.0;\n      strand[0].velocity = new CubismVector2(0.0, 0.0);\n      strand[0].force = new CubismVector2(0.0, 0.0);\n\n      // Initialize particles.\n      for (let i = 1; i < currentSetting.particleCount; ++i) {\n        radius = new CubismVector2(0.0, 0.0);\n        radius.y = strand[i].radius;\n        strand[i].initialPosition = new CubismVector2(\n          strand[i - 1].initialPosition.x + radius.x,\n          strand[i - 1].initialPosition.y + radius.y\n        );\n        strand[i].position = new CubismVector2(\n          strand[i].initialPosition.x,\n          strand[i].initialPosition.y\n        );\n        strand[i].lastPosition = new CubismVector2(\n          strand[i].initialPosition.x,\n          strand[i].initialPosition.y\n        );\n        strand[i].lastGravity = new CubismVector2(0.0, -1.0);\n        strand[i].lastGravity.y *= -1.0;\n        strand[i].velocity = new CubismVector2(0.0, 0.0);\n        strand[i].force = new CubismVector2(0.0, 0.0);\n      }\n    }\n  }\n\n  _physicsRig: CubismPhysicsRig; // 物理演算のデータ\n  _options: Options; // オプション\n\n  _currentRigOutputs: csmVector<PhysicsOutput>; ///< 最新の振り子計算の結果\n  _previousRigOutputs: csmVector<PhysicsOutput>; ///< 一つ前の振り子計算の結果\n\n  _currentRemainTime: number; ///< 物理演算が処理していない時間\n\n  _parameterCaches: Float32Array; ///< Evaluateで利用するパラメータのキャッシュ\n  _parameterInputCaches: Float32Array; ///< UpdateParticlesが動くときの入力をキャッシュ\n}\n\n/**\n * 物理演算のオプション\n */\nexport class Options {\n  constructor() {\n    this.gravity = new CubismVector2(0, 0);\n    this.wind = new CubismVector2(0, 0);\n  }\n\n  gravity: CubismVector2; // 重力方向\n  wind: CubismVector2; // 風の方向\n}\n\n/**\n * パラメータに適用する前の物理演算の出力結果\n */\nexport class PhysicsOutput {\n  constructor() {\n    this.outputs = new csmVector<number>(0);\n  }\n\n  outputs: csmVector<number>; // 物理演算出力結果\n}\n\n/**\n * Gets sign.\n *\n * @param value Evaluation target value.\n *\n * @return Sign of value.\n */\nfunction sign(value: number): number {\n  let ret = 0;\n\n  if (value > 0.0) {\n    ret = 1;\n  } else if (value < 0.0) {\n    ret = -1;\n  }\n\n  return ret;\n}\n\nfunction getInputTranslationXFromNormalizedParameterValue(\n  targetTranslation: CubismVector2,\n  targetAngle: { angle: number },\n  value: number,\n  parameterMinimumValue: number,\n  parameterMaximumValue: number,\n  parameterDefaultValue: number,\n  normalizationPosition: CubismPhysicsNormalization,\n  normalizationAngle: CubismPhysicsNormalization,\n  isInverted: boolean,\n  weight: number\n): void {\n  targetTranslation.x +=\n    normalizeParameterValue(\n      value,\n      parameterMinimumValue,\n      parameterMaximumValue,\n      parameterDefaultValue,\n      normalizationPosition.minimum,\n      normalizationPosition.maximum,\n      normalizationPosition.defalut,\n      isInverted\n    ) * weight;\n}\n\nfunction getInputTranslationYFromNormalizedParamterValue(\n  targetTranslation: CubismVector2,\n  targetAngle: { angle: number },\n  value: number,\n  parameterMinimumValue: number,\n  parameterMaximumValue: number,\n  parameterDefaultValue: number,\n  normalizationPosition: CubismPhysicsNormalization,\n  normalizationAngle: CubismPhysicsNormalization,\n  isInverted: boolean,\n  weight: number\n): void {\n  targetTranslation.y +=\n    normalizeParameterValue(\n      value,\n      parameterMinimumValue,\n      parameterMaximumValue,\n      parameterDefaultValue,\n      normalizationPosition.minimum,\n      normalizationPosition.maximum,\n      normalizationPosition.defalut,\n      isInverted\n    ) * weight;\n}\n\nfunction getInputAngleFromNormalizedParameterValue(\n  targetTranslation: CubismVector2,\n  targetAngle: { angle: number },\n  value: number,\n  parameterMinimumValue: number,\n  parameterMaximumValue: number,\n  parameterDefaultValue: number,\n  normalizaitionPosition: CubismPhysicsNormalization,\n  normalizationAngle: CubismPhysicsNormalization,\n  isInverted: boolean,\n  weight: number\n): void {\n  targetAngle.angle +=\n    normalizeParameterValue(\n      value,\n      parameterMinimumValue,\n      parameterMaximumValue,\n      parameterDefaultValue,\n      normalizationAngle.minimum,\n      normalizationAngle.maximum,\n      normalizationAngle.defalut,\n      isInverted\n    ) * weight;\n}\n\nfunction getOutputTranslationX(\n  translation: CubismVector2,\n  particles: CubismPhysicsParticle[],\n  particleIndex: number,\n  isInverted: boolean,\n  parentGravity: CubismVector2\n): number {\n  let outputValue: number = translation.x;\n\n  if (isInverted) {\n    outputValue *= -1.0;\n  }\n\n  return outputValue;\n}\n\nfunction getOutputTranslationY(\n  translation: CubismVector2,\n  particles: CubismPhysicsParticle[],\n  particleIndex: number,\n  isInverted: boolean,\n  parentGravity: CubismVector2\n): number {\n  let outputValue: number = translation.y;\n\n  if (isInverted) {\n    outputValue *= -1.0;\n  }\n  return outputValue;\n}\n\nfunction getOutputAngle(\n  translation: CubismVector2,\n  particles: CubismPhysicsParticle[],\n  particleIndex: number,\n  isInverted: boolean,\n  parentGravity: CubismVector2\n): number {\n  let outputValue: number;\n\n  if (particleIndex >= 2) {\n    parentGravity = particles[particleIndex - 1].position.substract(\n      particles[particleIndex - 2].position\n    );\n  } else {\n    parentGravity = parentGravity.multiplyByScaler(-1.0);\n  }\n\n  outputValue = CubismMath.directionToRadian(parentGravity, translation);\n\n  if (isInverted) {\n    outputValue *= -1.0;\n  }\n\n  return outputValue;\n}\n\nfunction getRangeValue(min: number, max: number): number {\n  const maxValue: number = CubismMath.max(min, max);\n  const minValue: number = CubismMath.min(min, max);\n\n  return CubismMath.abs(maxValue - minValue);\n}\n\nfunction getDefaultValue(min: number, max: number): number {\n  const minValue: number = CubismMath.min(min, max);\n  return minValue + getRangeValue(min, max) / 2.0;\n}\n\nfunction getOutputScaleTranslationX(\n  translationScale: CubismVector2,\n  angleScale: number\n): number {\n  return JSON.parse(JSON.stringify(translationScale.x));\n}\n\nfunction getOutputScaleTranslationY(\n  translationScale: CubismVector2,\n  angleScale: number\n): number {\n  return JSON.parse(JSON.stringify(translationScale.y));\n}\n\nfunction getOutputScaleAngle(\n  translationScale: CubismVector2,\n  angleScale: number\n): number {\n  return JSON.parse(JSON.stringify(angleScale));\n}\n\n/**\n * Updates particles.\n *\n * @param strand                Target array of particle.\n * @param strandCount           Count of particle.\n * @param totalTranslation      Total translation value.\n * @param totalAngle            Total angle.\n * @param windDirection         Direction of Wind.\n * @param thresholdValue        Threshold of movement.\n * @param deltaTimeSeconds      Delta time.\n * @param airResistance         Air resistance.\n */\nfunction updateParticles(\n  strand: CubismPhysicsParticle[],\n  strandCount: number,\n  totalTranslation: CubismVector2,\n  totalAngle: number,\n  windDirection: CubismVector2,\n  thresholdValue: number,\n  deltaTimeSeconds: number,\n  airResistance: number\n) {\n  let totalRadian: number;\n  let delay: number;\n  let radian: number;\n  let currentGravity: CubismVector2;\n  let direction: CubismVector2 = new CubismVector2(0.0, 0.0);\n  let velocity: CubismVector2 = new CubismVector2(0.0, 0.0);\n  let force: CubismVector2 = new CubismVector2(0.0, 0.0);\n  let newDirection: CubismVector2 = new CubismVector2(0.0, 0.0);\n\n  strand[0].position = new CubismVector2(\n    totalTranslation.x,\n    totalTranslation.y\n  );\n\n  totalRadian = CubismMath.degreesToRadian(totalAngle);\n  currentGravity = CubismMath.radianToDirection(totalRadian);\n  currentGravity.normalize();\n\n  for (let i = 1; i < strandCount; ++i) {\n    strand[i].force = currentGravity\n      .multiplyByScaler(strand[i].acceleration)\n      .add(windDirection);\n\n    strand[i].lastPosition = new CubismVector2(\n      strand[i].position.x,\n      strand[i].position.y\n    );\n\n    delay = strand[i].delay * deltaTimeSeconds * 30.0;\n\n    direction = strand[i].position.substract(strand[i - 1].position);\n\n    radian =\n      CubismMath.directionToRadian(strand[i].lastGravity, currentGravity) /\n      airResistance;\n\n    direction.x =\n      CubismMath.cos(radian) * direction.x -\n      direction.y * CubismMath.sin(radian);\n    direction.y =\n      CubismMath.sin(radian) * direction.x +\n      direction.y * CubismMath.cos(radian);\n\n    strand[i].position = strand[i - 1].position.add(direction);\n\n    velocity = strand[i].velocity.multiplyByScaler(delay);\n    force = strand[i].force.multiplyByScaler(delay).multiplyByScaler(delay);\n\n    strand[i].position = strand[i].position.add(velocity).add(force);\n\n    newDirection = strand[i].position.substract(strand[i - 1].position);\n    newDirection.normalize();\n\n    strand[i].position = strand[i - 1].position.add(\n      newDirection.multiplyByScaler(strand[i].radius)\n    );\n\n    if (CubismMath.abs(strand[i].position.x) < thresholdValue) {\n      strand[i].position.x = 0.0;\n    }\n\n    if (delay != 0.0) {\n      strand[i].velocity = strand[i].position.substract(strand[i].lastPosition);\n      strand[i].velocity = strand[i].velocity.divisionByScalar(delay);\n      strand[i].velocity = strand[i].velocity.multiplyByScaler(\n        strand[i].mobility\n      );\n    }\n\n    strand[i].force = new CubismVector2(0.0, 0.0);\n    strand[i].lastGravity = new CubismVector2(\n      currentGravity.x,\n      currentGravity.y\n    );\n  }\n}\n\n/**\n * Updates particles for stabilization.\n *\n * @param strand                Target array of particle.\n * @param strandCount           Count of particle.\n * @param totalTranslation      Total translation value.\n * @param totalAngle            Total angle.\n * @param windDirection         Direction of Wind.\n * @param thresholdValue        Threshold of movement.\n */\nfunction updateParticlesForStabilization(\n  strand: CubismPhysicsParticle[],\n  strandCount: number,\n  totalTranslation: CubismVector2,\n  totalAngle: number,\n  windDirection: CubismVector2,\n  thresholdValue: number\n) {\n  let totalRadian: number;\n  let currentGravity: CubismVector2;\n  let force: CubismVector2 = new CubismVector2(0.0, 0.0);\n\n  strand[0].position = new CubismVector2(\n    totalTranslation.x,\n    totalTranslation.y\n  );\n\n  totalRadian = CubismMath.degreesToRadian(totalAngle);\n  currentGravity = CubismMath.radianToDirection(totalRadian);\n  currentGravity.normalize();\n\n  for (let i = 1; i < strandCount; ++i) {\n    strand[i].force = currentGravity\n      .multiplyByScaler(strand[i].acceleration)\n      .add(windDirection);\n\n    strand[i].lastPosition = new CubismVector2(\n      strand[i].position.x,\n      strand[i].position.y\n    );\n\n    strand[i].velocity = new CubismVector2(0.0, 0.0);\n    force = strand[i].force;\n    force.normalize();\n\n    force = force.multiplyByScaler(strand[i].radius);\n    strand[i].position = strand[i - 1].position.add(force);\n\n    if (CubismMath.abs(strand[i].position.x) < thresholdValue) {\n      strand[i].position.x = 0.0;\n    }\n\n    strand[i].force = new CubismVector2(0.0, 0.0);\n    strand[i].lastGravity = new CubismVector2(\n      currentGravity.x,\n      currentGravity.y\n    );\n  }\n}\n\n/**\n * Updates output parameter value.\n * @param parameterValue            Target parameter value.\n * @param parameterValueMinimum     Minimum of parameter value.\n * @param parameterValueMaximum     Maximum of parameter value.\n * @param translation               Translation value.\n */\nfunction updateOutputParameterValue(\n  parameterValue: Float32Array,\n  parameterValueMinimum: number,\n  parameterValueMaximum: number,\n  translation: number,\n  output: CubismPhysicsOutput\n): void {\n  let outputScale: number;\n  let value: number;\n  let weight: number;\n\n  outputScale = output.getScale(output.translationScale, output.angleScale);\n\n  value = translation * outputScale;\n\n  if (value < parameterValueMinimum) {\n    if (value < output.valueBelowMinimum) {\n      output.valueBelowMinimum = value;\n    }\n\n    value = parameterValueMinimum;\n  } else if (value > parameterValueMaximum) {\n    if (value > output.valueExceededMaximum) {\n      output.valueExceededMaximum = value;\n    }\n\n    value = parameterValueMaximum;\n  }\n\n  weight = output.weight / MaximumWeight;\n\n  if (weight >= 1.0) {\n    parameterValue[0] = value;\n  } else {\n    value = parameterValue[0] * (1.0 - weight) + value * weight;\n    parameterValue[0] = value;\n  }\n}\n\nfunction normalizeParameterValue(\n  value: number,\n  parameterMinimum: number,\n  parameterMaximum: number,\n  parameterDefault: number,\n  normalizedMinimum: number,\n  normalizedMaximum: number,\n  normalizedDefault: number,\n  isInverted: boolean\n) {\n  let result = 0.0;\n\n  const maxValue: number = CubismMath.max(parameterMaximum, parameterMinimum);\n\n  if (maxValue < value) {\n    value = maxValue;\n  }\n\n  const minValue: number = CubismMath.min(parameterMaximum, parameterMinimum);\n\n  if (minValue > value) {\n    value = minValue;\n  }\n\n  const minNormValue: number = CubismMath.min(\n    normalizedMinimum,\n    normalizedMaximum\n  );\n  const maxNormValue: number = CubismMath.max(\n    normalizedMinimum,\n    normalizedMaximum\n  );\n  const middleNormValue: number = normalizedDefault;\n\n  const middleValue: number = getDefaultValue(minValue, maxValue);\n  const paramValue: number = value - middleValue;\n\n  switch (sign(paramValue)) {\n    case 1: {\n      const nLength: number = maxNormValue - middleNormValue;\n      const pLength: number = maxValue - middleValue;\n\n      if (pLength != 0.0) {\n        result = paramValue * (nLength / pLength);\n        result += middleNormValue;\n      }\n\n      break;\n    }\n    case -1: {\n      const nLength: number = minNormValue - middleNormValue;\n      const pLength: number = minValue - middleValue;\n\n      if (pLength != 0.0) {\n        result = paramValue * (nLength / pLength);\n        result += middleNormValue;\n      }\n\n      break;\n    }\n    case 0: {\n      result = middleNormValue;\n\n      break;\n    }\n    default: {\n      break;\n    }\n  }\n\n  return isInverted ? result : result * -1.0;\n}\n\n// Namespace definition for compatibility.\nimport * as $ from './cubismphysics';\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport namespace Live2DCubismFramework {\n  export const CubismPhysics = $.CubismPhysics;\n  export type CubismPhysics = $.CubismPhysics;\n  export const Options = $.Options;\n  export type Options = $.Options;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}