{"ast":null,"code":"/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\n\nimport { strtod } from '../live2dcubismframework';\nimport { csmMap } from '../type/csmmap';\nimport { csmString } from '../type/csmstring';\nimport { csmVector } from '../type/csmvector';\nimport { CubismLogInfo } from './cubismdebug';\n\n// StaticInitializeNotForClientCall()で初期化する\nconst CSM_JSON_ERROR_TYPE_MISMATCH = 'Error: type mismatch';\nconst CSM_JSON_ERROR_INDEX_OF_BOUNDS = 'Error: index out of bounds';\n\n/**\n * パースしたJSONエレメントの要素の基底クラス。\n */\nexport class Value {\n  /**\n   * コンストラクタ\n   */\n  constructor() {\n    this._stringBuffer = void 0;\n  }\n\n  /**\n   * 要素を文字列型で返す(csmString型)\n   */\n\n  /**\n   * 要素を文字列型で返す(string)\n   */\n  getRawString(defaultValue, indent) {\n    return this.getString(defaultValue, indent);\n  }\n\n  /**\n   * 要素を数値型で返す(number)\n   */\n  toInt() {\n    let defaultValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    return defaultValue;\n  }\n\n  /**\n   * 要素を数値型で返す(number)\n   */\n  toFloat() {\n    let defaultValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    return defaultValue;\n  }\n\n  /**\n   * 要素を真偽値で返す(boolean)\n   */\n  toBoolean() {\n    let defaultValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return defaultValue;\n  }\n\n  /**\n   * サイズを返す\n   */\n  getSize() {\n    return 0;\n  }\n\n  /**\n   * 要素を配列で返す(Value[])\n   */\n  getArray() {\n    let defaultValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    return defaultValue;\n  }\n\n  /**\n   * 要素をコンテナで返す(array)\n   */\n  getVector() {\n    let defaultValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new csmVector();\n    return defaultValue;\n  }\n\n  /**\n   * 要素をマップで返す(csmMap<csmString, Value>)\n   */\n  getMap(defaultValue) {\n    return defaultValue;\n  }\n\n  /**\n   * 添字演算子[index]\n   */\n  getValueByIndex(index) {\n    return Value.errorValue.setErrorNotForClientCall(CSM_JSON_ERROR_TYPE_MISMATCH);\n  }\n\n  /**\n   * 添字演算子[string | csmString]\n   */\n  getValueByString(s) {\n    return Value.nullValue.setErrorNotForClientCall(CSM_JSON_ERROR_TYPE_MISMATCH);\n  }\n\n  /**\n   * マップのキー一覧をコンテナで返す\n   *\n   * @return マップのキーの一覧\n   */\n  getKeys() {\n    return Value.s_dummyKeys;\n  }\n\n  /**\n   * Valueの種類がエラー値ならtrue\n   */\n  isError() {\n    return false;\n  }\n\n  /**\n   * Valueの種類がnullならtrue\n   */\n  isNull() {\n    return false;\n  }\n\n  /**\n   * Valueの種類が真偽値ならtrue\n   */\n  isBool() {\n    return false;\n  }\n\n  /**\n   * Valueの種類が数値型ならtrue\n   */\n  isFloat() {\n    return false;\n  }\n\n  /**\n   * Valueの種類が文字列ならtrue\n   */\n  isString() {\n    return false;\n  }\n\n  /**\n   * Valueの種類が配列ならtrue\n   */\n  isArray() {\n    return false;\n  }\n\n  /**\n   * Valueの種類がマップ型ならtrue\n   */\n  isMap() {\n    return false;\n  }\n\n  /**\n   * 引数の値と等しければtrue\n   */\n\n  equals(value) {\n    return false;\n  }\n\n  /**\n   * Valueの値が静的ならtrue、静的なら解放しない\n   */\n  isStatic() {\n    return false;\n  }\n\n  /**\n   * Valueにエラー値をセットする\n   */\n  setErrorNotForClientCall(errorStr) {\n    return JsonError.errorValue;\n  }\n\n  /**\n   * 初期化用メソッド\n   */\n  static staticInitializeNotForClientCall() {\n    JsonBoolean.trueValue = new JsonBoolean(true);\n    JsonBoolean.falseValue = new JsonBoolean(false);\n    Value.errorValue = new JsonError('ERROR', true);\n    Value.nullValue = new JsonNullvalue();\n    Value.s_dummyKeys = new csmVector();\n  }\n\n  /**\n   * リリース用メソッド\n   */\n  static staticReleaseNotForClientCall() {\n    JsonBoolean.trueValue = null;\n    JsonBoolean.falseValue = null;\n    Value.errorValue = null;\n    Value.nullValue = null;\n    Value.s_dummyKeys = null;\n  }\n\n  // 一時的な返り値として返すNULL。   CubismFramework::Disposeするまではdeleteしない\n\n  // 明示的に連想配列をany型で指定\n}\n\n/**\n * Ascii文字のみ対応した最小限の軽量JSONパーサ。\n * 仕様はJSONのサブセットとなる。\n * 設定ファイル(model3.json)などのロード用\n *\n * [未対応項目]\n * ・日本語などの非ASCII文字\n * ・eによる指数表現\n */\n// 文字列バッファ\nValue.s_dummyKeys = void 0;\n// ダミーキー\nValue.errorValue = void 0;\n// 一時的な返り値として返すエラー。 CubismFramework::Disposeするまではdeleteしない\nValue.nullValue = void 0;\nexport class CubismJson {\n  /**\n   * コンストラクタ\n   */\n  constructor(buffer, length) {\n    this._parseCallback = CubismJsonExtension.parseJsonObject;\n    // パース時に使う処理のコールバック関数\n    this._error = void 0;\n    // パース時のエラー\n    this._lineCount = void 0;\n    // エラー報告に用いる行数カウント\n    this._root = void 0;\n    this._error = null;\n    this._lineCount = 0;\n    this._root = null;\n    if (buffer != undefined) {\n      this.parseBytes(buffer, length, this._parseCallback);\n    }\n  }\n\n  /**\n   * バイトデータから直接ロードしてパースする\n   *\n   * @param buffer バッファ\n   * @param size バッファサイズ\n   * @return CubismJsonクラスのインスタンス。失敗したらNULL\n   */\n  static create(buffer, size) {\n    const json = new CubismJson();\n    const succeeded = json.parseBytes(buffer, size, json._parseCallback);\n    if (!succeeded) {\n      CubismJson.delete(json);\n      return null;\n    } else {\n      return json;\n    }\n  }\n\n  /**\n   * パースしたJSONオブジェクトの解放処理\n   *\n   * @param instance CubismJsonクラスのインスタンス\n   */\n  static delete(instance) {\n    instance = null;\n  }\n\n  /**\n   * パースしたJSONのルート要素を返す\n   */\n  getRoot() {\n    return this._root;\n  }\n\n  /**\n   *  UnicodeのバイナリをStringに変換\n   *\n   * @param buffer 変換するバイナリデータ\n   * @return 変換後の文字列\n   */\n  static arrayBufferToString(buffer) {\n    const uint8Array = new Uint8Array(buffer);\n    let str = '';\n    for (let i = 0, len = uint8Array.length; i < len; ++i) {\n      str += '%' + this.pad(uint8Array[i].toString(16));\n    }\n    str = decodeURIComponent(str);\n    return str;\n  }\n\n  /**\n   * エンコード、パディング\n   */\n  static pad(n) {\n    return n.length < 2 ? '0' + n : n;\n  }\n\n  /**\n   * JSONのパースを実行する\n   * @param buffer    パース対象のデータバイト\n   * @param size      データバイトのサイズ\n   * return true : 成功\n   * return false: 失敗\n   */\n  parseBytes(buffer, size, parseCallback) {\n    const endPos = new Array(1); // 参照渡しにするため配列\n    const decodeBuffer = CubismJson.arrayBufferToString(buffer);\n    if (parseCallback == undefined) {\n      this._root = this.parseValue(decodeBuffer, size, 0, endPos);\n    } else {\n      // TypeScript標準のJSONパーサを使う\n      this._root = parseCallback(JSON.parse(decodeBuffer), new JsonMap());\n    }\n    if (this._error) {\n      let strbuf = '\\0';\n      strbuf = 'Json parse error : @line ' + (this._lineCount + 1) + '\\n';\n      this._root = new JsonString(strbuf);\n      CubismLogInfo('{0}', this._root.getRawString());\n      return false;\n    } else if (this._root == null) {\n      this._root = new JsonError(new csmString(this._error), false); // rootは解放されるのでエラーオブジェクトを別途作成する\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * パース時のエラー値を返す\n   */\n  getParseError() {\n    return this._error;\n  }\n\n  /**\n   * ルート要素の次の要素がファイルの終端だったらtrueを返す\n   */\n  checkEndOfFile() {\n    return this._root.getArray()[1].equals('EOF');\n  }\n\n  /**\n   * JSONエレメントからValue(float,String,Value*,Array,null,true,false)をパースする\n   * エレメントの書式に応じて内部でParseString(), ParseObject(), ParseArray()を呼ぶ\n   *\n   * @param   buffer      JSONエレメントのバッファ\n   * @param   length      パースする長さ\n   * @param   begin       パースを開始する位置\n   * @param   outEndPos   パース終了時の位置\n   * @return      パースから取得したValueオブジェクト\n   */\n  parseValue(buffer, length, begin, outEndPos) {\n    if (this._error) return null;\n    let o = null;\n    let i = begin;\n    let f;\n    for (; i < length; i++) {\n      const c = buffer[i];\n      switch (c) {\n        case '-':\n        case '.':\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          {\n            const afterString = new Array(1); // 参照渡しにするため\n            f = strtod(buffer.slice(i), afterString);\n            outEndPos[0] = buffer.indexOf(afterString[0]);\n            return new JsonFloat(f);\n          }\n        case '\"':\n          return new JsonString(this.parseString(buffer, length, i + 1, outEndPos));\n        // \\\"の次の文字から\n        case '[':\n          o = this.parseArray(buffer, length, i + 1, outEndPos);\n          return o;\n        case '{':\n          o = this.parseObject(buffer, length, i + 1, outEndPos);\n          return o;\n        case 'n':\n          // null以外にない\n          if (i + 3 < length) {\n            o = new JsonNullvalue(); // 解放できるようにする\n            outEndPos[0] = i + 4;\n          } else {\n            this._error = 'parse null';\n          }\n          return o;\n        case 't':\n          // true以外にない\n          if (i + 3 < length) {\n            o = JsonBoolean.trueValue;\n            outEndPos[0] = i + 4;\n          } else {\n            this._error = 'parse true';\n          }\n          return o;\n        case 'f':\n          // false以外にない\n          if (i + 4 < length) {\n            o = JsonBoolean.falseValue;\n            outEndPos[0] = i + 5;\n          } else {\n            this._error = \"illegal ',' position\";\n          }\n          return o;\n        case ',':\n          // Array separator\n          this._error = \"illegal ',' position\";\n          return null;\n        case ']':\n          // 不正な｝だがスキップする。配列の最後に不要な , があると思われる\n          outEndPos[0] = i; // 同じ文字を再処理\n          return null;\n        case '\\n':\n          this._lineCount++;\n        case ' ':\n        case '\\t':\n        case '\\r':\n        default:\n          // スキップ\n          break;\n      }\n    }\n    this._error = 'illegal end of value';\n    return null;\n  }\n\n  /**\n   * 次の「\"」までの文字列をパースする。\n   *\n   * @param   string  ->  パース対象の文字列\n   * @param   length  ->  パースする長さ\n   * @param   begin   ->  パースを開始する位置\n   * @param  outEndPos   ->  パース終了時の位置\n   * @return      パースした文F字列要素\n   */\n  parseString(string, length, begin, outEndPos) {\n    if (this._error) return null;\n    let i = begin;\n    let c, c2;\n    const ret = new csmString('');\n    let bufStart = begin; // sbufに登録されていない文字の開始位置\n\n    for (; i < length; i++) {\n      c = string[i];\n      switch (c) {\n        case '\"':\n          {\n            // 終端の”、エスケープ文字は別に処理されるのでここに来ない\n            outEndPos[0] = i + 1; // ”の次の文字\n            ret.append(string.slice(bufStart), i - bufStart); // 前の文字までを登録する\n            return ret.s;\n          }\n        case '//':\n          {\n            // エスケープの場合\n            i++; // ２文字をセットで扱う\n\n            if (i - 1 > bufStart) {\n              ret.append(string.slice(bufStart), i - bufStart); // 前の文字までを登録する\n            }\n\n            bufStart = i + 1; // エスケープ（２文字)の次の文字から\n\n            if (i < length) {\n              c2 = string[i];\n              switch (c2) {\n                case '\\\\':\n                  ret.expansion(1, '\\\\');\n                  break;\n                case '\"':\n                  ret.expansion(1, '\"');\n                  break;\n                case '/':\n                  ret.expansion(1, '/');\n                  break;\n                case 'b':\n                  ret.expansion(1, '\\b');\n                  break;\n                case 'f':\n                  ret.expansion(1, '\\f');\n                  break;\n                case 'n':\n                  ret.expansion(1, '\\n');\n                  break;\n                case 'r':\n                  ret.expansion(1, '\\r');\n                  break;\n                case 't':\n                  ret.expansion(1, '\\t');\n                  break;\n                case 'u':\n                  this._error = 'parse string/unicord escape not supported';\n                  break;\n                default:\n                  break;\n              }\n            } else {\n              this._error = 'parse string/escape error';\n            }\n          }\n        default:\n          {\n            break;\n          }\n      }\n    }\n    this._error = 'parse string/illegal end';\n    return null;\n  }\n\n  /**\n   * JSONのオブジェクトエレメントをパースしてValueオブジェクトを返す\n   *\n   * @param buffer    JSONエレメントのバッファ\n   * @param length    パースする長さ\n   * @param begin     パースを開始する位置\n   * @param outEndPos パース終了時の位置\n   * @return パースから取得したValueオブジェクト\n   */\n  parseObject(buffer, length, begin, outEndPos) {\n    if (this._error) return null;\n    const ret = new JsonMap();\n\n    // Key: Value\n    let key = '';\n    let i = begin;\n    let c = '';\n    const localRetEndPos2 = Array(1);\n    let ok = false;\n\n    // , が続く限りループ\n    for (; i < length; i++) {\n      FOR_LOOP: for (; i < length; i++) {\n        c = buffer[i];\n        switch (c) {\n          case '\"':\n            key = this.parseString(buffer, length, i + 1, localRetEndPos2);\n            if (this._error) {\n              return null;\n            }\n            i = localRetEndPos2[0];\n            ok = true;\n            break FOR_LOOP;\n          //-- loopから出る\n          case '}':\n            // 閉じカッコ\n            outEndPos[0] = i + 1;\n            return ret;\n          // 空\n          case ':':\n            this._error = \"illegal ':' position\";\n            break;\n          case '\\n':\n            this._lineCount++;\n          default:\n            break;\n          // スキップする文字\n        }\n      }\n\n      if (!ok) {\n        this._error = 'key not found';\n        return null;\n      }\n      ok = false;\n\n      // : をチェック\n      FOR_LOOP2: for (; i < length; i++) {\n        c = buffer[i];\n        switch (c) {\n          case ':':\n            ok = true;\n            i++;\n            break FOR_LOOP2;\n          case '}':\n            this._error = \"illegal '}' position\";\n            break;\n          case '\\n':\n            this._lineCount++;\n          // case ' ': case '\\t' : case '\\r':\n          default:\n            break;\n          // スキップする文字\n        }\n      }\n\n      if (!ok) {\n        this._error = \"':' not found\";\n        return null;\n      }\n\n      // 値をチェック\n      const value = this.parseValue(buffer, length, i, localRetEndPos2);\n      if (this._error) {\n        return null;\n      }\n      i = localRetEndPos2[0];\n\n      // ret.put(key, value);\n      ret.put(key, value);\n      FOR_LOOP3: for (; i < length; i++) {\n        c = buffer[i];\n        switch (c) {\n          case ',':\n            break FOR_LOOP3;\n          case '}':\n            outEndPos[0] = i + 1;\n            return ret;\n          // 正常終了\n          case '\\n':\n            this._lineCount++;\n          default:\n            break;\n          // スキップ\n        }\n      }\n    }\n\n    this._error = 'illegal end of perseObject';\n    return null;\n  }\n\n  /**\n   * 次の「\"」までの文字列をパースする。\n   * @param buffer    JSONエレメントのバッファ\n   * @param length    パースする長さ\n   * @param begin     パースを開始する位置\n   * @param outEndPos パース終了時の位置\n   * @return パースから取得したValueオブジェクト\n   */\n  parseArray(buffer, length, begin, outEndPos) {\n    if (this._error) return null;\n    let ret = new JsonArray();\n\n    // key : value\n    let i = begin;\n    let c;\n    const localRetEndpos2 = new Array(1);\n\n    // , が続く限りループ\n    for (; i < length; i++) {\n      // : をチェック\n      const value = this.parseValue(buffer, length, i, localRetEndpos2);\n      if (this._error) {\n        return null;\n      }\n      i = localRetEndpos2[0];\n      if (value) {\n        ret.add(value);\n      }\n\n      // FOR_LOOP3:\n      // boolean breakflag = false;\n      FOR_LOOP: for (; i < length; i++) {\n        c = buffer[i];\n        switch (c) {\n          case ',':\n            // breakflag = true;\n            // break; // 次のKEY, VAlUEへ\n            break FOR_LOOP;\n          case ']':\n            outEndPos[0] = i + 1;\n            return ret;\n          // 終了\n          case '\\n':\n            ++this._lineCount;\n          //case ' ': case '\\t': case '\\r':\n          default:\n            break;\n          // スキップ\n        }\n      }\n    }\n\n    ret = void 0;\n    this._error = 'illegal end of parseObject';\n    return null;\n  }\n\n  // パースされたルート要素\n}\n\n/**\n * パースしたJSONの要素をfloat値として扱う\n */\nexport class JsonFloat extends Value {\n  /**\n   * コンストラクタ\n   */\n  constructor(v) {\n    super();\n    this._value = void 0;\n    this._value = v;\n  }\n\n  /**\n   * Valueの種類が数値型ならtrue\n   */\n  isFloat() {\n    return true;\n  }\n\n  /**\n   * 要素を文字列で返す(csmString型)\n   */\n  getString(defaultValue, indent) {\n    const strbuf = '\\0';\n    this._value = parseFloat(strbuf);\n    this._stringBuffer = strbuf;\n    return this._stringBuffer;\n  }\n\n  /**\n   * 要素を数値型で返す(number)\n   */\n  toInt() {\n    let defaultValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    return parseInt(this._value.toString());\n  }\n\n  /**\n   * 要素を数値型で返す(number)\n   */\n  toFloat() {\n    let defaultValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.0;\n    return this._value;\n  }\n\n  /**\n   * 引数の値と等しければtrue\n   */\n\n  equals(value) {\n    if ('number' === typeof value) {\n      // int\n      if (Math.round(value)) {\n        return false;\n      }\n      // float\n      else {\n        return value == this._value;\n      }\n    }\n    return false;\n  }\n\n  // JSON要素の値\n}\n\n/**\n * パースしたJSONの要素を真偽値として扱う\n */\nexport class JsonBoolean extends Value {\n  /**\n   * Valueの種類が真偽値ならtrue\n   */\n  isBool() {\n    return true;\n  }\n\n  /**\n   * 要素を真偽値で返す(boolean)\n   */\n  toBoolean() {\n    let defaultValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return this._boolValue;\n  }\n\n  /**\n   * 要素を文字列で返す(csmString型)\n   */\n  getString(defaultValue, indent) {\n    this._stringBuffer = this._boolValue ? 'true' : 'false';\n    return this._stringBuffer;\n  }\n\n  /**\n   * 引数の値と等しければtrue\n   */\n\n  equals(value) {\n    if ('boolean' === typeof value) {\n      return value == this._boolValue;\n    }\n    return false;\n  }\n\n  /**\n   * Valueの値が静的ならtrue, 静的なら解放しない\n   */\n  isStatic() {\n    return true;\n  }\n\n  /**\n   * 引数付きコンストラクタ\n   */\n  constructor(v) {\n    super();\n    // false\n    this._boolValue = void 0;\n    this._boolValue = v;\n  }\n\n  // JSON要素の値\n}\n\n/**\n * パースしたJSONの要素を文字列として扱う\n */\nJsonBoolean.trueValue = void 0;\n// true\nJsonBoolean.falseValue = void 0;\nexport class JsonString extends Value {\n  /**\n   * 引数付きコンストラクタ\n   */\n\n  constructor(s) {\n    super();\n    if ('string' === typeof s) {\n      this._stringBuffer = s;\n    }\n    if (s instanceof csmString) {\n      this._stringBuffer = s.s;\n    }\n  }\n\n  /**\n   * Valueの種類が文字列ならtrue\n   */\n  isString() {\n    return true;\n  }\n\n  /**\n   * 要素を文字列で返す(csmString型)\n   */\n  getString(defaultValue, indent) {\n    return this._stringBuffer;\n  }\n\n  /**\n   * 引数の値と等しければtrue\n   */\n\n  equals(value) {\n    if ('string' === typeof value) {\n      return this._stringBuffer == value;\n    }\n    if (value instanceof csmString) {\n      return this._stringBuffer == value.s;\n    }\n    return false;\n  }\n}\n\n/**\n * JSONパース時のエラー結果。文字列型のようにふるまう\n */\nexport class JsonError extends JsonString {\n  /**\n   * Valueの値が静的ならtrue、静的なら解放しない\n   */\n  isStatic() {\n    return this._isStatic;\n  }\n\n  /**\n   * エラー情報をセットする\n   */\n  setErrorNotForClientCall(s) {\n    this._stringBuffer = s;\n    return this;\n  }\n\n  /**\n   * 引数付きコンストラクタ\n   */\n  constructor(s, isStatic) {\n    if ('string' === typeof s) {\n      super(s);\n      this._isStatic = void 0;\n    } else {\n      super(s);\n      this._isStatic = void 0;\n    }\n    this._isStatic = isStatic;\n  }\n\n  /**\n   * Valueの種類がエラー値ならtrue\n   */\n  isError() {\n    return true;\n  }\n\n  // 静的なValueかどうか\n}\n\n/**\n * パースしたJSONの要素をNULL値として持つ\n */\nexport class JsonNullvalue extends Value {\n  /**\n   * Valueの種類がNULL値ならtrue\n   */\n  isNull() {\n    return true;\n  }\n\n  /**\n   * 要素を文字列で返す(csmString型)\n   */\n  getString(defaultValue, indent) {\n    return this._stringBuffer;\n  }\n\n  /**\n   * Valueの値が静的ならtrue, 静的なら解放しない\n   */\n  isStatic() {\n    return true;\n  }\n\n  /**\n   * Valueにエラー値をセットする\n   */\n  setErrorNotForClientCall(s) {\n    this._stringBuffer = s;\n    return JsonError.nullValue;\n  }\n\n  /**\n   * コンストラクタ\n   */\n  constructor() {\n    super();\n    this._stringBuffer = 'NullValue';\n  }\n}\n\n/**\n * パースしたJSONの要素を配列として持つ\n */\nexport class JsonArray extends Value {\n  /**\n   * コンストラクタ\n   */\n  constructor() {\n    super();\n    this._array = void 0;\n    this._array = new csmVector();\n  }\n\n  /**\n   * デストラクタ相当の処理\n   */\n  release() {\n    for (let ite = this._array.begin(); ite.notEqual(this._array.end()); ite.preIncrement()) {\n      let v = ite.ptr();\n      if (v && !v.isStatic()) {\n        v = void 0;\n        v = null;\n      }\n    }\n  }\n\n  /**\n   * Valueの種類が配列ならtrue\n   */\n  isArray() {\n    return true;\n  }\n\n  /**\n   * 添字演算子[index]\n   */\n  getValueByIndex(index) {\n    if (index < 0 || this._array.getSize() <= index) {\n      return Value.errorValue.setErrorNotForClientCall(CSM_JSON_ERROR_INDEX_OF_BOUNDS);\n    }\n    const v = this._array.at(index);\n    if (v == null) {\n      return Value.nullValue;\n    }\n    return v;\n  }\n\n  /**\n   * 添字演算子[string | csmString]\n   */\n  getValueByString(s) {\n    return Value.errorValue.setErrorNotForClientCall(CSM_JSON_ERROR_TYPE_MISMATCH);\n  }\n\n  /**\n   * 要素を文字列で返す(csmString型)\n   */\n  getString(defaultValue, indent) {\n    const stringBuffer = indent + '[\\n';\n    for (let ite = this._array.begin(); ite.notEqual(this._array.end()); ite.increment()) {\n      const v = ite.ptr();\n      this._stringBuffer += indent + '' + v.getString(indent + ' ') + '\\n';\n    }\n    this._stringBuffer = stringBuffer + indent + ']\\n';\n    return this._stringBuffer;\n  }\n\n  /**\n   * 配列要素を追加する\n   * @param v 追加する要素\n   */\n  add(v) {\n    this._array.pushBack(v);\n  }\n\n  /**\n   * 要素をコンテナで返す(csmVector<Value>)\n   */\n  getVector() {\n    let defaultValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    return this._array;\n  }\n\n  /**\n   * 要素の数を返す\n   */\n  getSize() {\n    return this._array.getSize();\n  }\n\n  // JSON要素の値\n}\n\n/**\n * パースしたJSONの要素をマップとして持つ\n */\nexport class JsonMap extends Value {\n  /**\n   * コンストラクタ\n   */\n  constructor() {\n    super();\n    this._map = void 0;\n    // JSON要素の値\n    this._keys = void 0;\n    this._map = new csmMap();\n  }\n\n  /**\n   * デストラクタ相当の処理\n   */\n  release() {\n    const ite = this._map.begin();\n    while (ite.notEqual(this._map.end())) {\n      let v = ite.ptr().second;\n      if (v && !v.isStatic()) {\n        v = void 0;\n        v = null;\n      }\n      ite.preIncrement();\n    }\n  }\n\n  /**\n   * Valueの値がMap型ならtrue\n   */\n  isMap() {\n    return true;\n  }\n\n  /**\n   * 添字演算子[string | csmString]\n   */\n  getValueByString(s) {\n    if (s instanceof csmString) {\n      const ret = this._map.getValue(s.s);\n      if (ret == null) {\n        return Value.nullValue;\n      }\n      return ret;\n    }\n    for (let iter = this._map.begin(); iter.notEqual(this._map.end()); iter.preIncrement()) {\n      if (iter.ptr().first == s) {\n        if (iter.ptr().second == null) {\n          return Value.nullValue;\n        }\n        return iter.ptr().second;\n      }\n    }\n    return Value.nullValue;\n  }\n\n  /**\n   * 添字演算子[index]\n   */\n  getValueByIndex(index) {\n    return Value.errorValue.setErrorNotForClientCall(CSM_JSON_ERROR_TYPE_MISMATCH);\n  }\n\n  /**\n   * 要素を文字列で返す(csmString型)\n   */\n  getString(defaultValue, indent) {\n    this._stringBuffer = indent + '{\\n';\n    const ite = this._map.begin();\n    while (ite.notEqual(this._map.end())) {\n      const key = ite.ptr().first;\n      const v = ite.ptr().second;\n      this._stringBuffer += indent + ' ' + key + ' : ' + v.getString(indent + '   ') + ' \\n';\n      ite.preIncrement();\n    }\n    this._stringBuffer += indent + '}\\n';\n    return this._stringBuffer;\n  }\n\n  /**\n   * 要素をMap型で返す\n   */\n  getMap(defaultValue) {\n    return this._map;\n  }\n\n  /**\n   * Mapに要素を追加する\n   */\n  put(key, v) {\n    this._map.setValue(key, v);\n  }\n\n  /**\n   * Mapからキーのリストを取得する\n   */\n  getKeys() {\n    if (!this._keys) {\n      this._keys = new csmVector();\n      const ite = this._map.begin();\n      while (ite.notEqual(this._map.end())) {\n        const key = ite.ptr().first;\n        this._keys.pushBack(key);\n        ite.preIncrement();\n      }\n    }\n    return this._keys;\n  }\n\n  /**\n   * Mapの要素数を取得する\n   */\n  getSize() {\n    return this._keys.getSize();\n  }\n\n  // JSON要素の値\n}\n\n// Namespace definition for compatibility.\nimport * as $ from './cubismjson';\nimport { CubismJsonExtension } from './cubismjsonextension';\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport let Live2DCubismFramework;\n(function (_Live2DCubismFramework) {\n  const CubismJson = _Live2DCubismFramework.CubismJson = $.CubismJson;\n  const JsonArray = _Live2DCubismFramework.JsonArray = $.JsonArray;\n  const JsonBoolean = _Live2DCubismFramework.JsonBoolean = $.JsonBoolean;\n  const JsonError = _Live2DCubismFramework.JsonError = $.JsonError;\n  const JsonFloat = _Live2DCubismFramework.JsonFloat = $.JsonFloat;\n  const JsonMap = _Live2DCubismFramework.JsonMap = $.JsonMap;\n  const JsonNullvalue = _Live2DCubismFramework.JsonNullvalue = $.JsonNullvalue;\n  const JsonString = _Live2DCubismFramework.JsonString = $.JsonString;\n  const Value = _Live2DCubismFramework.Value = $.Value;\n})(Live2DCubismFramework || (Live2DCubismFramework = {}));","map":{"version":3,"names":["strtod","csmMap","csmString","csmVector","CubismLogInfo","CSM_JSON_ERROR_TYPE_MISMATCH","CSM_JSON_ERROR_INDEX_OF_BOUNDS","Value","constructor","_stringBuffer","getRawString","defaultValue","indent","getString","toInt","arguments","length","undefined","toFloat","toBoolean","getSize","getArray","getVector","getMap","getValueByIndex","index","errorValue","setErrorNotForClientCall","getValueByString","s","nullValue","getKeys","s_dummyKeys","isError","isNull","isBool","isFloat","isString","isArray","isMap","equals","value","isStatic","errorStr","JsonError","staticInitializeNotForClientCall","JsonBoolean","trueValue","falseValue","JsonNullvalue","staticReleaseNotForClientCall","CubismJson","buffer","_parseCallback","CubismJsonExtension","parseJsonObject","_error","_lineCount","_root","parseBytes","create","size","json","succeeded","delete","instance","getRoot","arrayBufferToString","uint8Array","Uint8Array","str","i","len","pad","toString","decodeURIComponent","n","parseCallback","endPos","Array","decodeBuffer","parseValue","JSON","parse","JsonMap","strbuf","JsonString","getParseError","checkEndOfFile","begin","outEndPos","o","f","c","afterString","slice","indexOf","JsonFloat","parseString","parseArray","parseObject","string","c2","ret","bufStart","append","expansion","key","localRetEndPos2","ok","FOR_LOOP","FOR_LOOP2","put","FOR_LOOP3","JsonArray","localRetEndpos2","add","v","_value","parseFloat","parseInt","Math","round","_boolValue","_isStatic","_array","release","ite","notEqual","end","preIncrement","ptr","at","stringBuffer","increment","pushBack","_map","_keys","second","getValue","iter","first","setValue","$","Live2DCubismFramework","_Live2DCubismFramework"],"sources":["C:/Users/cleyc/OneDrive/Documents/RR/RRWebsiteRenewed/my-app/src/js/Framework/src/utils/cubismjson.ts"],"sourcesContent":["/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\n\nimport { strtod } from '../live2dcubismframework';\nimport { csmMap, iterator as csmMap_iterator } from '../type/csmmap';\nimport { csmString } from '../type/csmstring';\nimport { csmVector, iterator as csmVector_iterator } from '../type/csmvector';\nimport { CubismLogInfo } from './cubismdebug';\n\n// StaticInitializeNotForClientCall()で初期化する\nconst CSM_JSON_ERROR_TYPE_MISMATCH = 'Error: type mismatch';\nconst CSM_JSON_ERROR_INDEX_OF_BOUNDS = 'Error: index out of bounds';\n\n/**\n * パースしたJSONエレメントの要素の基底クラス。\n */\nexport abstract class Value {\n  /**\n   * コンストラクタ\n   */\n  public constructor() {}\n\n  /**\n   * 要素を文字列型で返す(csmString型)\n   */\n  public abstract getString(defaultValue?: string, indent?: string): string;\n\n  /**\n   * 要素を文字列型で返す(string)\n   */\n  public getRawString(defaultValue?: string, indent?: string): string {\n    return this.getString(defaultValue, indent);\n  }\n\n  /**\n   * 要素を数値型で返す(number)\n   */\n  public toInt(defaultValue = 0): number {\n    return defaultValue;\n  }\n\n  /**\n   * 要素を数値型で返す(number)\n   */\n  public toFloat(defaultValue = 0): number {\n    return defaultValue;\n  }\n\n  /**\n   * 要素を真偽値で返す(boolean)\n   */\n  public toBoolean(defaultValue = false): boolean {\n    return defaultValue;\n  }\n\n  /**\n   * サイズを返す\n   */\n  public getSize(): number {\n    return 0;\n  }\n\n  /**\n   * 要素を配列で返す(Value[])\n   */\n  public getArray(defaultValue: Value[] = null): Value[] {\n    return defaultValue;\n  }\n\n  /**\n   * 要素をコンテナで返す(array)\n   */\n  public getVector(defaultValue = new csmVector<Value>()): csmVector<Value> {\n    return defaultValue;\n  }\n\n  /**\n   * 要素をマップで返す(csmMap<csmString, Value>)\n   */\n  public getMap(defaultValue?: csmMap<string, Value>): csmMap<string, Value> {\n    return defaultValue;\n  }\n\n  /**\n   * 添字演算子[index]\n   */\n  public getValueByIndex(index: number): Value {\n    return Value.errorValue.setErrorNotForClientCall(\n      CSM_JSON_ERROR_TYPE_MISMATCH\n    );\n  }\n\n  /**\n   * 添字演算子[string | csmString]\n   */\n  public getValueByString(s: string | csmString): Value {\n    return Value.nullValue.setErrorNotForClientCall(\n      CSM_JSON_ERROR_TYPE_MISMATCH\n    );\n  }\n\n  /**\n   * マップのキー一覧をコンテナで返す\n   *\n   * @return マップのキーの一覧\n   */\n  public getKeys(): csmVector<string> {\n    return Value.s_dummyKeys;\n  }\n\n  /**\n   * Valueの種類がエラー値ならtrue\n   */\n  public isError(): boolean {\n    return false;\n  }\n\n  /**\n   * Valueの種類がnullならtrue\n   */\n  public isNull(): boolean {\n    return false;\n  }\n\n  /**\n   * Valueの種類が真偽値ならtrue\n   */\n  public isBool(): boolean {\n    return false;\n  }\n\n  /**\n   * Valueの種類が数値型ならtrue\n   */\n  public isFloat(): boolean {\n    return false;\n  }\n\n  /**\n   * Valueの種類が文字列ならtrue\n   */\n  public isString(): boolean {\n    return false;\n  }\n\n  /**\n   * Valueの種類が配列ならtrue\n   */\n  public isArray(): boolean {\n    return false;\n  }\n\n  /**\n   * Valueの種類がマップ型ならtrue\n   */\n  public isMap(): boolean {\n    return false;\n  }\n\n  /**\n   * 引数の値と等しければtrue\n   */\n  public equals(value: csmString): boolean;\n  public equals(value: string): boolean;\n  public equals(value: number): boolean;\n  public equals(value: boolean): boolean;\n  public equals(value: any): boolean {\n    return false;\n  }\n\n  /**\n   * Valueの値が静的ならtrue、静的なら解放しない\n   */\n  public isStatic(): boolean {\n    return false;\n  }\n\n  /**\n   * Valueにエラー値をセットする\n   */\n  public setErrorNotForClientCall(errorStr: string): Value {\n    return JsonError.errorValue;\n  }\n\n  /**\n   * 初期化用メソッド\n   */\n  public static staticInitializeNotForClientCall(): void {\n    JsonBoolean.trueValue = new JsonBoolean(true);\n    JsonBoolean.falseValue = new JsonBoolean(false);\n    Value.errorValue = new JsonError('ERROR', true);\n    Value.nullValue = new JsonNullvalue();\n    Value.s_dummyKeys = new csmVector<string>();\n  }\n\n  /**\n   * リリース用メソッド\n   */\n  public static staticReleaseNotForClientCall(): void {\n    JsonBoolean.trueValue = null;\n    JsonBoolean.falseValue = null;\n    Value.errorValue = null;\n    Value.nullValue = null;\n    Value.s_dummyKeys = null;\n  }\n\n  protected _stringBuffer: string; // 文字列バッファ\n\n  private static s_dummyKeys: csmVector<string>; // ダミーキー\n\n  public static errorValue: Value; // 一時的な返り値として返すエラー。 CubismFramework::Disposeするまではdeleteしない\n  public static nullValue: Value; // 一時的な返り値として返すNULL。   CubismFramework::Disposeするまではdeleteしない\n\n  [key: string]: any; // 明示的に連想配列をany型で指定\n}\n\n/**\n * Ascii文字のみ対応した最小限の軽量JSONパーサ。\n * 仕様はJSONのサブセットとなる。\n * 設定ファイル(model3.json)などのロード用\n *\n * [未対応項目]\n * ・日本語などの非ASCII文字\n * ・eによる指数表現\n */\nexport class CubismJson {\n  /**\n   * コンストラクタ\n   */\n  public constructor(buffer?: ArrayBuffer, length?: number) {\n    this._error = null;\n    this._lineCount = 0;\n    this._root = null;\n\n    if (buffer != undefined) {\n      this.parseBytes(buffer, length, this._parseCallback);\n    }\n  }\n\n  /**\n   * バイトデータから直接ロードしてパースする\n   *\n   * @param buffer バッファ\n   * @param size バッファサイズ\n   * @return CubismJsonクラスのインスタンス。失敗したらNULL\n   */\n  public static create(buffer: ArrayBuffer, size: number) {\n    const json = new CubismJson();\n    const succeeded: boolean = json.parseBytes(\n      buffer,\n      size,\n      json._parseCallback\n    );\n\n    if (!succeeded) {\n      CubismJson.delete(json);\n      return null;\n    } else {\n      return json;\n    }\n  }\n\n  /**\n   * パースしたJSONオブジェクトの解放処理\n   *\n   * @param instance CubismJsonクラスのインスタンス\n   */\n  public static delete(instance: CubismJson) {\n    instance = null;\n  }\n\n  /**\n   * パースしたJSONのルート要素を返す\n   */\n  public getRoot(): Value {\n    return this._root;\n  }\n\n  /**\n   *  UnicodeのバイナリをStringに変換\n   *\n   * @param buffer 変換するバイナリデータ\n   * @return 変換後の文字列\n   */\n  public static arrayBufferToString(buffer: ArrayBuffer): string {\n    const uint8Array: Uint8Array = new Uint8Array(buffer);\n    let str = '';\n\n    for (let i = 0, len: number = uint8Array.length; i < len; ++i) {\n      str += '%' + this.pad(uint8Array[i].toString(16));\n    }\n\n    str = decodeURIComponent(str);\n    return str;\n  }\n\n  /**\n   * エンコード、パディング\n   */\n  private static pad(n: string): string {\n    return n.length < 2 ? '0' + n : n;\n  }\n\n  /**\n   * JSONのパースを実行する\n   * @param buffer    パース対象のデータバイト\n   * @param size      データバイトのサイズ\n   * return true : 成功\n   * return false: 失敗\n   */\n  public parseBytes(\n    buffer: ArrayBuffer,\n    size: number,\n    parseCallback?: parseJsonObject\n  ): boolean {\n    const endPos: number[] = new Array<number>(1); // 参照渡しにするため配列\n    const decodeBuffer: string = CubismJson.arrayBufferToString(buffer);\n\n    if (parseCallback == undefined) {\n      this._root = this.parseValue(decodeBuffer, size, 0, endPos);\n    } else {\n      // TypeScript標準のJSONパーサを使う\n      this._root = parseCallback(JSON.parse(decodeBuffer), new JsonMap());\n    }\n\n    if (this._error) {\n      let strbuf = '\\0';\n      strbuf = 'Json parse error : @line ' + (this._lineCount + 1) + '\\n';\n      this._root = new JsonString(strbuf);\n\n      CubismLogInfo('{0}', this._root.getRawString());\n      return false;\n    } else if (this._root == null) {\n      this._root = new JsonError(new csmString(this._error), false); // rootは解放されるのでエラーオブジェクトを別途作成する\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * パース時のエラー値を返す\n   */\n  public getParseError(): string {\n    return this._error;\n  }\n\n  /**\n   * ルート要素の次の要素がファイルの終端だったらtrueを返す\n   */\n  public checkEndOfFile(): boolean {\n    return this._root.getArray()[1].equals('EOF');\n  }\n\n  /**\n   * JSONエレメントからValue(float,String,Value*,Array,null,true,false)をパースする\n   * エレメントの書式に応じて内部でParseString(), ParseObject(), ParseArray()を呼ぶ\n   *\n   * @param   buffer      JSONエレメントのバッファ\n   * @param   length      パースする長さ\n   * @param   begin       パースを開始する位置\n   * @param   outEndPos   パース終了時の位置\n   * @return      パースから取得したValueオブジェクト\n   */\n  protected parseValue(\n    buffer: string,\n    length: number,\n    begin: number,\n    outEndPos: number[]\n  ) {\n    if (this._error) return null;\n\n    let o: Value = null;\n    let i: number = begin;\n    let f: number;\n\n    for (; i < length; i++) {\n      const c: string = buffer[i];\n      switch (c) {\n        case '-':\n        case '.':\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9': {\n          const afterString: string[] = new Array(1); // 参照渡しにするため\n          f = strtod(buffer.slice(i), afterString);\n          outEndPos[0] = buffer.indexOf(afterString[0]);\n          return new JsonFloat(f);\n        }\n        case '\"':\n          return new JsonString(\n            this.parseString(buffer, length, i + 1, outEndPos)\n          ); // \\\"の次の文字から\n        case '[':\n          o = this.parseArray(buffer, length, i + 1, outEndPos);\n          return o;\n        case '{':\n          o = this.parseObject(buffer, length, i + 1, outEndPos);\n          return o;\n        case 'n': // null以外にない\n          if (i + 3 < length) {\n            o = new JsonNullvalue(); // 解放できるようにする\n            outEndPos[0] = i + 4;\n          } else {\n            this._error = 'parse null';\n          }\n          return o;\n        case 't': // true以外にない\n          if (i + 3 < length) {\n            o = JsonBoolean.trueValue;\n            outEndPos[0] = i + 4;\n          } else {\n            this._error = 'parse true';\n          }\n          return o;\n        case 'f': // false以外にない\n          if (i + 4 < length) {\n            o = JsonBoolean.falseValue;\n            outEndPos[0] = i + 5;\n          } else {\n            this._error = \"illegal ',' position\";\n          }\n          return o;\n        case ',': // Array separator\n          this._error = \"illegal ',' position\";\n          return null;\n        case ']': // 不正な｝だがスキップする。配列の最後に不要な , があると思われる\n          outEndPos[0] = i; // 同じ文字を再処理\n          return null;\n        case '\\n':\n          this._lineCount++;\n        case ' ':\n        case '\\t':\n        case '\\r':\n        default:\n          // スキップ\n          break;\n      }\n    }\n\n    this._error = 'illegal end of value';\n    return null;\n  }\n\n  /**\n   * 次の「\"」までの文字列をパースする。\n   *\n   * @param   string  ->  パース対象の文字列\n   * @param   length  ->  パースする長さ\n   * @param   begin   ->  パースを開始する位置\n   * @param  outEndPos   ->  パース終了時の位置\n   * @return      パースした文F字列要素\n   */\n  protected parseString(\n    string: string,\n    length: number,\n    begin: number,\n    outEndPos: number[]\n  ): string {\n    if (this._error) return null;\n\n    let i = begin;\n    let c: string, c2: string;\n    const ret: csmString = new csmString('');\n    let bufStart: number = begin; // sbufに登録されていない文字の開始位置\n\n    for (; i < length; i++) {\n      c = string[i];\n\n      switch (c) {\n        case '\"': {\n          // 終端の”、エスケープ文字は別に処理されるのでここに来ない\n          outEndPos[0] = i + 1; // ”の次の文字\n          ret.append(string.slice(bufStart), i - bufStart); // 前の文字までを登録する\n          return ret.s;\n        }\n        case '//': {\n          // エスケープの場合\n          i++; // ２文字をセットで扱う\n\n          if (i - 1 > bufStart) {\n            ret.append(string.slice(bufStart), i - bufStart); // 前の文字までを登録する\n          }\n          bufStart = i + 1; // エスケープ（２文字)の次の文字から\n\n          if (i < length) {\n            c2 = string[i];\n\n            switch (c2) {\n              case '\\\\':\n                ret.expansion(1, '\\\\');\n                break;\n              case '\"':\n                ret.expansion(1, '\"');\n                break;\n              case '/':\n                ret.expansion(1, '/');\n                break;\n              case 'b':\n                ret.expansion(1, '\\b');\n                break;\n              case 'f':\n                ret.expansion(1, '\\f');\n                break;\n              case 'n':\n                ret.expansion(1, '\\n');\n                break;\n              case 'r':\n                ret.expansion(1, '\\r');\n                break;\n              case 't':\n                ret.expansion(1, '\\t');\n                break;\n              case 'u':\n                this._error = 'parse string/unicord escape not supported';\n                break;\n              default:\n                break;\n            }\n          } else {\n            this._error = 'parse string/escape error';\n          }\n        }\n        default: {\n          break;\n        }\n      }\n    }\n\n    this._error = 'parse string/illegal end';\n    return null;\n  }\n\n  /**\n   * JSONのオブジェクトエレメントをパースしてValueオブジェクトを返す\n   *\n   * @param buffer    JSONエレメントのバッファ\n   * @param length    パースする長さ\n   * @param begin     パースを開始する位置\n   * @param outEndPos パース終了時の位置\n   * @return パースから取得したValueオブジェクト\n   */\n  protected parseObject(\n    buffer: string,\n    length: number,\n    begin: number,\n    outEndPos: number[]\n  ): Value {\n    if (this._error) return null;\n    const ret: JsonMap = new JsonMap();\n\n    // Key: Value\n    let key = '';\n    let i: number = begin;\n    let c = '';\n    const localRetEndPos2: number[] = Array(1);\n    let ok = false;\n\n    // , が続く限りループ\n    for (; i < length; i++) {\n      FOR_LOOP: for (; i < length; i++) {\n        c = buffer[i];\n\n        switch (c) {\n          case '\"':\n            key = this.parseString(buffer, length, i + 1, localRetEndPos2);\n            if (this._error) {\n              return null;\n            }\n\n            i = localRetEndPos2[0];\n            ok = true;\n            break FOR_LOOP; //-- loopから出る\n          case '}': // 閉じカッコ\n            outEndPos[0] = i + 1;\n            return ret; // 空\n          case ':':\n            this._error = \"illegal ':' position\";\n            break;\n          case '\\n':\n            this._lineCount++;\n          default:\n            break; // スキップする文字\n        }\n      }\n      if (!ok) {\n        this._error = 'key not found';\n        return null;\n      }\n\n      ok = false;\n\n      // : をチェック\n      FOR_LOOP2: for (; i < length; i++) {\n        c = buffer[i];\n\n        switch (c) {\n          case ':':\n            ok = true;\n            i++;\n            break FOR_LOOP2;\n          case '}':\n            this._error = \"illegal '}' position\";\n            break;\n          case '\\n':\n            this._lineCount++;\n          // case ' ': case '\\t' : case '\\r':\n          default:\n            break; // スキップする文字\n        }\n      }\n\n      if (!ok) {\n        this._error = \"':' not found\";\n        return null;\n      }\n\n      // 値をチェック\n      const value: Value = this.parseValue(buffer, length, i, localRetEndPos2);\n      if (this._error) {\n        return null;\n      }\n\n      i = localRetEndPos2[0];\n\n      // ret.put(key, value);\n      ret.put(key, value);\n\n      FOR_LOOP3: for (; i < length; i++) {\n        c = buffer[i];\n\n        switch (c) {\n          case ',':\n            break FOR_LOOP3;\n          case '}':\n            outEndPos[0] = i + 1;\n            return ret; // 正常終了\n          case '\\n':\n            this._lineCount++;\n          default:\n            break; // スキップ\n        }\n      }\n    }\n\n    this._error = 'illegal end of perseObject';\n    return null;\n  }\n\n  /**\n   * 次の「\"」までの文字列をパースする。\n   * @param buffer    JSONエレメントのバッファ\n   * @param length    パースする長さ\n   * @param begin     パースを開始する位置\n   * @param outEndPos パース終了時の位置\n   * @return パースから取得したValueオブジェクト\n   */\n  protected parseArray(\n    buffer: string,\n    length: number,\n    begin: number,\n    outEndPos: number[]\n  ): Value {\n    if (this._error) return null;\n    let ret: JsonArray = new JsonArray();\n\n    // key : value\n    let i: number = begin;\n    let c: string;\n    const localRetEndpos2: number[] = new Array(1);\n\n    // , が続く限りループ\n    for (; i < length; i++) {\n      // : をチェック\n      const value: Value = this.parseValue(buffer, length, i, localRetEndpos2);\n\n      if (this._error) {\n        return null;\n      }\n      i = localRetEndpos2[0];\n\n      if (value) {\n        ret.add(value);\n      }\n\n      // FOR_LOOP3:\n      // boolean breakflag = false;\n      FOR_LOOP: for (; i < length; i++) {\n        c = buffer[i];\n\n        switch (c) {\n          case ',':\n            // breakflag = true;\n            // break; // 次のKEY, VAlUEへ\n            break FOR_LOOP;\n          case ']':\n            outEndPos[0] = i + 1;\n            return ret; // 終了\n          case '\\n':\n            ++this._lineCount;\n          //case ' ': case '\\t': case '\\r':\n          default:\n            break; // スキップ\n        }\n      }\n    }\n\n    ret = void 0;\n    this._error = 'illegal end of parseObject';\n    return null;\n  }\n\n  _parseCallback: parseJsonObject = CubismJsonExtension.parseJsonObject; // パース時に使う処理のコールバック関数\n\n  _error: string; // パース時のエラー\n  _lineCount: number; // エラー報告に用いる行数カウント\n  _root: Value; // パースされたルート要素\n}\n\ninterface parseJsonObject {\n  (obj: Value, map: JsonMap): JsonMap;\n}\n\n/**\n * パースしたJSONの要素をfloat値として扱う\n */\nexport class JsonFloat extends Value {\n  /**\n   * コンストラクタ\n   */\n  constructor(v: number) {\n    super();\n\n    this._value = v;\n  }\n\n  /**\n   * Valueの種類が数値型ならtrue\n   */\n  public isFloat(): boolean {\n    return true;\n  }\n\n  /**\n   * 要素を文字列で返す(csmString型)\n   */\n  public getString(defaultValue: string, indent: string): string {\n    const strbuf = '\\0';\n    this._value = parseFloat(strbuf);\n    this._stringBuffer = strbuf;\n\n    return this._stringBuffer;\n  }\n\n  /**\n   * 要素を数値型で返す(number)\n   */\n  public toInt(defaultValue = 0): number {\n    return parseInt(this._value.toString());\n  }\n\n  /**\n   * 要素を数値型で返す(number)\n   */\n  public toFloat(defaultValue = 0.0): number {\n    return this._value;\n  }\n\n  /**\n   * 引数の値と等しければtrue\n   */\n  public equals(value: csmString): boolean;\n  public equals(value: string): boolean;\n  public equals(value: number): boolean;\n  public equals(value: boolean): boolean;\n  public equals(value: any): boolean {\n    if ('number' === typeof value) {\n      // int\n      if (Math.round(value)) {\n        return false;\n      }\n      // float\n      else {\n        return value == this._value;\n      }\n    }\n    return false;\n  }\n\n  private _value: number; // JSON要素の値\n}\n\n/**\n * パースしたJSONの要素を真偽値として扱う\n */\nexport class JsonBoolean extends Value {\n  /**\n   * Valueの種類が真偽値ならtrue\n   */\n  public isBool(): boolean {\n    return true;\n  }\n\n  /**\n   * 要素を真偽値で返す(boolean)\n   */\n  public toBoolean(defaultValue = false): boolean {\n    return this._boolValue;\n  }\n\n  /**\n   * 要素を文字列で返す(csmString型)\n   */\n  public getString(defaultValue: string, indent: string): string {\n    this._stringBuffer = this._boolValue ? 'true' : 'false';\n\n    return this._stringBuffer;\n  }\n\n  /**\n   * 引数の値と等しければtrue\n   */\n  public equals(value: csmString): boolean;\n  public equals(value: string): boolean;\n  public equals(value: number): boolean;\n  public equals(value: boolean): boolean;\n  public equals(value: any): boolean {\n    if ('boolean' === typeof value) {\n      return value == this._boolValue;\n    }\n    return false;\n  }\n\n  /**\n   * Valueの値が静的ならtrue, 静的なら解放しない\n   */\n  public isStatic(): boolean {\n    return true;\n  }\n\n  /**\n   * 引数付きコンストラクタ\n   */\n  public constructor(v: boolean) {\n    super();\n\n    this._boolValue = v;\n  }\n\n  static trueValue: JsonBoolean; // true\n  static falseValue: JsonBoolean; // false\n\n  private _boolValue: boolean; // JSON要素の値\n}\n\n/**\n * パースしたJSONの要素を文字列として扱う\n */\nexport class JsonString extends Value {\n  /**\n   * 引数付きコンストラクタ\n   */\n  public constructor(s: string);\n  public constructor(s: csmString);\n  public constructor(s: any) {\n    super();\n\n    if ('string' === typeof s) {\n      this._stringBuffer = s;\n    }\n\n    if (s instanceof csmString) {\n      this._stringBuffer = s.s;\n    }\n  }\n\n  /**\n   * Valueの種類が文字列ならtrue\n   */\n  public isString(): boolean {\n    return true;\n  }\n\n  /**\n   * 要素を文字列で返す(csmString型)\n   */\n  public getString(defaultValue: string, indent: string): string {\n    return this._stringBuffer;\n  }\n\n  /**\n   * 引数の値と等しければtrue\n   */\n  public equals(value: csmString): boolean;\n  public equals(value: string): boolean;\n  public equals(value: number): boolean;\n  public equals(value: boolean): boolean;\n  public equals(value: any): boolean {\n    if ('string' === typeof value) {\n      return this._stringBuffer == value;\n    }\n\n    if (value instanceof csmString) {\n      return this._stringBuffer == value.s;\n    }\n\n    return false;\n  }\n}\n\n/**\n * JSONパース時のエラー結果。文字列型のようにふるまう\n */\nexport class JsonError extends JsonString {\n  /**\n   * Valueの値が静的ならtrue、静的なら解放しない\n   */\n  public isStatic(): boolean {\n    return this._isStatic;\n  }\n\n  /**\n   * エラー情報をセットする\n   */\n  public setErrorNotForClientCall(s: string): Value {\n    this._stringBuffer = s;\n    return this;\n  }\n\n  /**\n   * 引数付きコンストラクタ\n   */\n  public constructor(s: csmString | string, isStatic: boolean) {\n    if ('string' === typeof s) {\n      super(s);\n    } else {\n      super(s);\n    }\n    this._isStatic = isStatic;\n  }\n\n  /**\n   * Valueの種類がエラー値ならtrue\n   */\n  public isError(): boolean {\n    return true;\n  }\n\n  protected _isStatic: boolean; // 静的なValueかどうか\n}\n\n/**\n * パースしたJSONの要素をNULL値として持つ\n */\nexport class JsonNullvalue extends Value {\n  /**\n   * Valueの種類がNULL値ならtrue\n   */\n  public isNull(): boolean {\n    return true;\n  }\n\n  /**\n   * 要素を文字列で返す(csmString型)\n   */\n  public getString(defaultValue: string, indent: string): string {\n    return this._stringBuffer;\n  }\n\n  /**\n   * Valueの値が静的ならtrue, 静的なら解放しない\n   */\n  public isStatic(): boolean {\n    return true;\n  }\n\n  /**\n   * Valueにエラー値をセットする\n   */\n  public setErrorNotForClientCall(s: string): Value {\n    this._stringBuffer = s;\n    return JsonError.nullValue;\n  }\n\n  /**\n   * コンストラクタ\n   */\n  public constructor() {\n    super();\n\n    this._stringBuffer = 'NullValue';\n  }\n}\n\n/**\n * パースしたJSONの要素を配列として持つ\n */\nexport class JsonArray extends Value {\n  /**\n   * コンストラクタ\n   */\n  public constructor() {\n    super();\n    this._array = new csmVector<Value>();\n  }\n\n  /**\n   * デストラクタ相当の処理\n   */\n  public release(): void {\n    for (\n      let ite: csmVector_iterator<Value> = this._array.begin();\n      ite.notEqual(this._array.end());\n      ite.preIncrement()\n    ) {\n      let v: Value = ite.ptr();\n\n      if (v && !v.isStatic()) {\n        v = void 0;\n        v = null;\n      }\n    }\n  }\n\n  /**\n   * Valueの種類が配列ならtrue\n   */\n  public isArray(): boolean {\n    return true;\n  }\n\n  /**\n   * 添字演算子[index]\n   */\n  public getValueByIndex(index: number): Value {\n    if (index < 0 || this._array.getSize() <= index) {\n      return Value.errorValue.setErrorNotForClientCall(\n        CSM_JSON_ERROR_INDEX_OF_BOUNDS\n      );\n    }\n\n    const v: Value = this._array.at(index);\n\n    if (v == null) {\n      return Value.nullValue;\n    }\n\n    return v;\n  }\n\n  /**\n   * 添字演算子[string | csmString]\n   */\n  public getValueByString(s: string | csmString): Value {\n    return Value.errorValue.setErrorNotForClientCall(\n      CSM_JSON_ERROR_TYPE_MISMATCH\n    );\n  }\n\n  /**\n   * 要素を文字列で返す(csmString型)\n   */\n  public getString(defaultValue: string, indent: string): string {\n    const stringBuffer: string = indent + '[\\n';\n\n    for (\n      let ite: csmVector_iterator<Value> = this._array.begin();\n      ite.notEqual(this._array.end());\n      ite.increment()\n    ) {\n      const v: Value = ite.ptr();\n      this._stringBuffer += indent + '' + v.getString(indent + ' ') + '\\n';\n    }\n\n    this._stringBuffer = stringBuffer + indent + ']\\n';\n\n    return this._stringBuffer;\n  }\n\n  /**\n   * 配列要素を追加する\n   * @param v 追加する要素\n   */\n  public add(v: Value): void {\n    this._array.pushBack(v);\n  }\n\n  /**\n   * 要素をコンテナで返す(csmVector<Value>)\n   */\n  public getVector(defaultValue: csmVector<Value> = null): csmVector<Value> {\n    return this._array;\n  }\n\n  /**\n   * 要素の数を返す\n   */\n  public getSize(): number {\n    return this._array.getSize();\n  }\n\n  private _array: csmVector<Value>; // JSON要素の値\n}\n\n/**\n * パースしたJSONの要素をマップとして持つ\n */\nexport class JsonMap extends Value {\n  /**\n   * コンストラクタ\n   */\n  public constructor() {\n    super();\n    this._map = new csmMap<string, Value>();\n  }\n\n  /**\n   * デストラクタ相当の処理\n   */\n  public release(): void {\n    const ite: csmMap_iterator<string, Value> = this._map.begin();\n\n    while (ite.notEqual(this._map.end())) {\n      let v: Value = ite.ptr().second;\n\n      if (v && !v.isStatic()) {\n        v = void 0;\n        v = null;\n      }\n\n      ite.preIncrement();\n    }\n  }\n\n  /**\n   * Valueの値がMap型ならtrue\n   */\n  public isMap(): boolean {\n    return true;\n  }\n\n  /**\n   * 添字演算子[string | csmString]\n   */\n  public getValueByString(s: string | csmString): Value {\n    if (s instanceof csmString) {\n      const ret: Value = this._map.getValue(s.s);\n      if (ret == null) {\n        return Value.nullValue;\n      }\n      return ret;\n    }\n\n    for (\n      let iter: csmMap_iterator<string, Value> = this._map.begin();\n      iter.notEqual(this._map.end());\n      iter.preIncrement()\n    ) {\n      if (iter.ptr().first == s) {\n        if (iter.ptr().second == null) {\n          return Value.nullValue;\n        }\n        return iter.ptr().second;\n      }\n    }\n\n    return Value.nullValue;\n  }\n\n  /**\n   * 添字演算子[index]\n   */\n  public getValueByIndex(index: number): Value {\n    return Value.errorValue.setErrorNotForClientCall(\n      CSM_JSON_ERROR_TYPE_MISMATCH\n    );\n  }\n\n  /**\n   * 要素を文字列で返す(csmString型)\n   */\n  public getString(defaultValue: string, indent: string) {\n    this._stringBuffer = indent + '{\\n';\n\n    const ite: csmMap_iterator<string, Value> = this._map.begin();\n    while (ite.notEqual(this._map.end())) {\n      const key = ite.ptr().first;\n      const v: Value = ite.ptr().second;\n\n      this._stringBuffer +=\n        indent + ' ' + key + ' : ' + v.getString(indent + '   ') + ' \\n';\n      ite.preIncrement();\n    }\n\n    this._stringBuffer += indent + '}\\n';\n\n    return this._stringBuffer;\n  }\n\n  /**\n   * 要素をMap型で返す\n   */\n  public getMap(defaultValue?: csmMap<string, Value>): csmMap<string, Value> {\n    return this._map;\n  }\n\n  /**\n   * Mapに要素を追加する\n   */\n  public put(key: string, v: Value): void {\n    this._map.setValue(key, v);\n  }\n\n  /**\n   * Mapからキーのリストを取得する\n   */\n  public getKeys(): csmVector<string> {\n    if (!this._keys) {\n      this._keys = new csmVector<string>();\n\n      const ite: csmMap_iterator<string, Value> = this._map.begin();\n\n      while (ite.notEqual(this._map.end())) {\n        const key: string = ite.ptr().first;\n        this._keys.pushBack(key);\n        ite.preIncrement();\n      }\n    }\n    return this._keys;\n  }\n\n  /**\n   * Mapの要素数を取得する\n   */\n  public getSize(): number {\n    return this._keys.getSize();\n  }\n\n  private _map: csmMap<string, Value>; // JSON要素の値\n  private _keys: csmVector<string>; // JSON要素の値\n}\n\n// Namespace definition for compatibility.\nimport * as $ from './cubismjson';\nimport { CubismJsonExtension } from './cubismjsonextension';\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport namespace Live2DCubismFramework {\n  export const CubismJson = $.CubismJson;\n  export type CubismJson = $.CubismJson;\n  export const JsonArray = $.JsonArray;\n  export type JsonArray = $.JsonArray;\n  export const JsonBoolean = $.JsonBoolean;\n  export type JsonBoolean = $.JsonBoolean;\n  export const JsonError = $.JsonError;\n  export type JsonError = $.JsonError;\n  export const JsonFloat = $.JsonFloat;\n  export type JsonFloat = $.JsonFloat;\n  export const JsonMap = $.JsonMap;\n  export type JsonMap = $.JsonMap;\n  export const JsonNullvalue = $.JsonNullvalue;\n  export type JsonNullvalue = $.JsonNullvalue;\n  export const JsonString = $.JsonString;\n  export type JsonString = $.JsonString;\n  export const Value = $.Value;\n  export type Value = $.Value;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}